# JavaScript

Est√© cap√≠tulo est√° basado en el Curso de **"Aprende JavaScript"** en la url [AprendeJavaScript.dev](https://aprendejavascript.dev/) creado por Miguel √Ångel [statick](https://porfolio.dev/#sobre-mi), el cual es un desarrollador FullStack y Creador de Contenido, sin m√°s que agregar comencemos.

## ¬øQu√© es JavaScript?

JavaScript es uno de los lenguajes de programaci√≥n m√°s usados y populares del mundo. Naci√≥ en 1995 para darle interactividad a las p√°ginas web y desde entonces ha evolucionado hasta convertirse en un lenguaje de programaci√≥n de prop√≥sito general. Dicho de otra forma: se puede usar casi para cualquier cosa.

## ¬øQu√© es programar?

Es el acto de construir un programa o conjunto de instrucciones para decirle a una computadora qu√© y c√≥mo queremos que haga algo. No es diferente a cuando "programamos" la lavadora, s√≥lo que en vez de pulsar un bot√≥n, vamos a usar texto. A este texto se le conoce como "c√≥digo".

## ¬øPor qu√© aprender JavaScript?

JavaScript es, a d√≠a de hoy, el √∫nico lenguaje de programaci√≥n que todos los navegadores web entienden sin necesidad de realizar ning√∫n paso previo. Esto hace que casi cualquier p√°gina web que visitas tiene alguna l√≠nea de JavaScript en su interior.

Su curva de aprendizaje para iniciarte es muy corta ya que en muy poco tiempo puedes empezar a hacer cosas interesantes. Para alcanzar a ser un buen programador en JavaScript necesitar√°s a√±os de pr√°ctica, pero para empezar a hacer cosas interesantes bastar√° con poco tiempo.

Por si fuera poco, JavaScript es uno de los lenguajes de programaci√≥n m√°s demandados en el mercado laboral. Es normal, ya que es un lenguaje muy vers√°til y que se puede usar para casi cualquier cosa.

Adem√°s, con JavaScript vas a poder desarrollar casi cualquier cosa que te propongas. Desde aplicaciones web, m√≥viles y de escritorio a backend, videojuegos, inteligencia artificial, Internet de las cosas. Todo un mundo de posibilidades con un s√≥lo lenguaje.

## Quiz

:::::: question
**¬øJavaScript s√≥lo se puede usar para crear p√°ginas web?**

::::: choices
::: choice
Verdadero
:::

::: {.choice .correct-choice}
Falso
:::
:::::
::::::

::::::: question
**¬øQu√© es programar en el mundo del software?**

:::::: choices
::: choice
Crear p√°ginas web y que el usuario pueda usarlas
:::

::: {.choice .correct-choice}
Es el acto de construir un programa o conjunto de instrucciones para decirle a una comptuadora qu√© y c√≥mo queremos que haga algo
:::

::: choice
Cualquier cosa que hagamos en un ordenador
:::
::::::
:::::::

# La consola del navegador

Ahora es necesario utilizar un navegador web, ya que vamos a empezar a escribir c√≥digo JavaScript.

Todos los navegadores tienen una herramienta llamada **consola**. La consola nos permite ejecutar c√≥digo JavaScript en tiempo real y ver el resultado. Tambi√©n ah√≠ podemos ver los errores, advertencias y trazas que se producen en nuestro c√≥digo.

Aunque podemos ejecutar c√≥digo JavaScript de otras formas, para empezar, vamos a usar esta herramienta que nos ofrece el navegador.

::: callout-tip
Recuerda que llamamos c√≥digo a las instrucciones que le damos a la computadora para que haga algo.
:::

## C√≥mo abrir la consola

Para abrir la consola del navegador debes hacer lo siguiente:

1.  Abre tu navegador web favorito, por ejemplo, Google Chrome, Firefox, Safari o Edge.

2.  Ve a la p√°gina **about:blank** en la barra de direcciones. As√≠ evitaremos que la p√°gina web que hemos cargado nos moleste.

3.  Haz **click derecho** en cualquier parte de la p√°gina y selecciona la opci√≥n **Inspeccionar Elemento** o **Inspect**.

Aqu√≠ podr√°s ejecutar tu c√≥digo JavaScript y ver el resultado. Es lo que usaremos en un inicio. M√°s adelante pasaremos a usar un editor como **VSCode**.

En **Google Chrome** o **Brave**, este es el aspecto de la consola

![](images/paste-28.png)

En **Firefox**, este es el aspecto de la consola

![](images/paste-29.png)

## Quiz

:::::: question
**¬øPara qu√© sirve la consola del navegador?**

::::: choices
::: choice
La consola sirve para poder jugar con JavaScript. Es la √∫nica forma de poder ejecutar nuestro c√≥digo y por eso todos los navegadores lo incorporan.
:::

::: {.choice .correct-choice}
La consola nos permite ejecutar c√≥digo JavaScript en tiempo real y ver el resultado. Tambi√©n ah√≠ podemos ver los errores, advertencias y trazas que se producen en nuestro c√≥digo.
:::
:::::
::::::

# Editores y entornos de desarrollo

En la actualidad existen muchos editores de c√≥digo y entornos de desarrollo que nos permiten escribir c√≥digo de forma m√°s c√≥moda y eficiente. Algunos de los m√°s populares son:

-   **Visual Studio Code**: Es uno de los editores de c√≥digo m√°s populares y es el que usaremos en este curso.

    ::: center
    ![](images/paste-41.png)
    :::

-   **Runjs**: Un entorno de desarrollo online que nos permite escribir c√≥digo JavaScript y ver el resultado en tiempo real.

    ::: center
    ![](images/paste-38.png)
    :::

-   **Zed Code Editor**: Un editor de c√≥digo muy sencillo y minimalista.

    ::: center
    ![](images/paste-39.png)
    :::

# Tipos de Datos

En JavaScript, como cualquier otro lenguaje de programaci√≥n, vamos a querer trasladar la informaci√≥n del mundo real a nuestro c√≥digo. Para ello, necesitamos entender qu√© tipos de datos existen en el lenguaje para poder representar la informaci√≥n que necesitamos.

En JavaScript tenemos 9 tipos de datos que se dividen en dos grandes grupos: **primitivos** o **no primitivos**.

## Tipos Primitivos.

Dentro de los tipos primitivos tenemos 7 tipos de datos:

-   number
-   string
-   boolean
-   null
-   undefined
-   symbol
-   bigint

No te preocupes, no tienes ni recordarlos ni entenderlos todos ahora. En esta lecci√≥n vamos a ver los tres primeros que son, sin ninguna duda, los que m√°s vamos a usar al inicio del curso.

## N√∫meros

Los n√∫meros (tipo number) son los datos m√°s b√°sicos que podemos representar en JavaScript. En JavaScript, no hay una diferencia entre n√∫meros enteros y n√∫meros decimales, todos los n√∫meros son de tipo number:

``` javascript
7
3.14
19.95
2.998e8
-1
```

## Operadores aritm√©ticos

Con los n√∫meros, puedes usar los operadores aritm√©ticos para realizar operaciones matem√°ticas. En JavaScript tenemos los siguientes operadores aritm√©ticos:

-   +: suma
-   -: resta
-   \*: multiplicaci√≥n
-   /: divisi√≥n
-   %: m√≥dulo (resto de la divisi√≥n)
-   \*\*: exponente

Al usar los operadores aritm√©ticos, el resultado siempre ser√° un n√∫mero. Por ejemplo:

``` javascript
2 + 2 // 4
4 - 2 // 2
3 * 2 // 6
2 / 2 // 1
2 % 2 // 0
3 ** 3 // 27
```

## ¬øQu√© significa el // que ves en los ejemplos?

Es un comentario. En JavaScript, los comentarios se escriben con **//** y todo lo que escribas despu√©s de\`*//* ser√° ignorado por el navegador. Los comentarios son muy √∫tiles para explicar qu√© hace nuestro c√≥digo.

Al igual que las matem√°ticas, las operaciones siguen un orden de precedencia. Por ejemplo, si queremos calcular el resultado de **2 + 2 \* 3**, primero se multiplicar√° **2 \* 3** y luego se sumar√° **2 + 6**. El resultado ser√° **8**.

Tambi√©n puedes usar par√©ntesis para cambiar el orden de las operaciones.

``` javascript
2 + 2 * 3 // 8
(2 + 2) * 3 // 12
```

## Cadenas de texto

La cadena de texto (tipo string) es otro tipo de dato muy com√∫n. En JavaScript, las cadenas de texto se representan entre **comillas simples**, **dobles** o **acentos graves**:

``` javascript
'Est√°s aprendiendo JavaScript'

"JavaScript te va a gustar"

`Esto es una cadena de texto`
```

Las comillas simples y dobles funcionan igual, pero al usar **acentos graves** podemos escribir cadenas de texto que ocupen varias l√≠neas:

``` javascript
`Esto es una cadena de texto
que ocupa varias l√≠neas. Puedes escribir
tantas l√≠neas como quieras`
```

## Concatenaci√≥n

Para unir dos cadenas de texto, podemos usar el operador +:

``` javascript
'Est√°s aprendiendo ' + 'JavaScript' // 'Est√°s aprendiendo JavaScript'
```

Como ves, el operador **+** de concatenaci√≥n de cadenas de texto es visualmente el mismo que el operador **+** de **suma de n√∫meros**. El operador **+** funciona de forma diferente dependiendo del tipo de dato que estemos usando.

## Booleanos

Los booleanos representa s√≥lo dos valores: true (verdadero) o false (falso). Por ejemplo:

-   ¬øLa luz est√° encendida (true) o apagada (false)?
-   ¬øEst√° lloviendo (true) o no est√° lloviendo (false)?
-   ¬øEst√° el usuario logueado (true) o no est√° logueado (false)?

Estos son ejemplos de preguntas que podemos responder con un valor booleano.

-   true
-   false

## Quiz

:::::: question
**¬øCu√°ntos tipos de datos existen en JavaScript?**

::::: choices
::: choice
S√≥lo existen 2 tipos de datos
:::

::: {.choice .correct-choice}
9 tipos de datos que se dividen en dos grandes grupos
:::
:::::
::::::

::::::: question
**¬øCu√°ntos valores se pueden representar en el tipo de dato Boolean?**

:::::: choices
::: choice
true y false
:::

::: {.choice .correct-choice}
Cualquier valor que se te ocurra
:::

::: choice
N√∫meros, cadenas de texto y verdadero/falso.
:::
::::::
:::::::

::::::: question
**El operador + se utiliza para...**

:::::: choices
::: choice
S√≥lo sirve para sumar dos n√∫meros
:::

::: choice
Concatenar dos textos
:::

::: {.choice .correct-choice}
Depende del tipo de dato que se est√© utilizando
:::
::::::
:::::::

# Los operadores de comparaci√≥n

Los operadores de comparaci√≥n en JavaScript nos permiten comparar dos valores. Siempre devuelven un valor booleano (true o false).

Por ejemplo, podemos comparar si un n√∫mero es mayor que otro con el operador **\>**, o si un n√∫mero es menor que otro con el operador **\<**.

``` javascript
5 > 3 // true
5 < 3 // false
```

Tambi√©n tenemos los operadores **\>=** y **\<=** que nos permiten comparar si un n√∫mero es mayor o igual que otro, o si un n√∫mero es menor o igual que otro.

``` javascript
5 >= 3 // true
5 >= 5 // true
5 <= 3 // false
5 <= 5 // true
```

Para saber si dos valores son iguales podemos usar el operador **===** o, para saber si son diferentes, el operador **!==**.

``` javascript
5 === 5 // true
5 !== 5 // false
```

## Actividad

1.  Escribe un c√≥digo que compruebe si 10 es mayor o igual que 9

2.  Comprueba que 0 es igual a 0

<details>

<summary>Respuesta</summary>

R1.

``` javascript
10 >= 9 // true
```

R2.

``` javascript
0 === 0 // true
```

</detais>

## Comparando cadenas de texto

No s√≥lo podemos usar los comparadores para comparar n√∫meros, tambi√©n podemos usarlos para comparar cadenas de texto y otros tipos de datos.

``` javascript
'JavaScript' === 'JavaScript' // true
'JavaScript' === 'Java' // false
"JavaScript" !== 'PHP' // true
`Estoy Aprendiendo JavaScript` === 'Estoy Aprendiendo JavaScript' // true
```

::: callout-tip
F√≠jate que puedes comparar cadenas de texto que usan comillas simples, dobles o acentos graves. Al final, siguen siendo cadenas de texto y lo importante es que sean iguales.
:::

## ¬øY si usamos el operador \> con cadenas de texto?

Aunque no es muy com√∫n, podemos usar los operadores **\>** , **\>=**, **\<** y **\<=** para comparar cadenas de texto.

JavaScript comparar√° las cadenas de texto seg√∫n el valor de su c√≥digo Unicode.

Por ejemplo, la letra **A** tiene un valor de **65** y la letra **B** tiene un valor de **66**. Por lo tanto, la letra **A** es menor que la letra **B**. Pero ten cuidado, ya que las letras may√∫sculas tienen un valor menor que las letras min√∫sculas.

``` javascript
'Alfa' > 'Beta' // false
'Omega' > 'Beta' // true
'alfa' > 'Alfa' // true
```

## Comparando booleanos

Tambi√©n podemos comparar booleanos con los operadores de comparaci√≥n.

``` javascript
true === true // true
true === false // false
false !== false // false
```

Por si te preguntas c√≥mo se comportan los operadores de mayor o menor que (**\>** y **\<**) con booleanos te dir√© que, aunque no tiene sentido, debes saber que true es mayor que false.

``` javascript
true > false // true
false < true // true
true > true // false
false < false // false
```

## Comparando valores de diferentes tipos

Por ahora hemos visto c√≥mo comparar valores de un mismo tipo, pero ¬øQu√© pasa si queremos comparar valores de diferentes tipos? En JavaScript es algo que es posible pero no suele ser recomendable.

En clases posteriores veremos c√≥mo funciona este tipo de mecanismo y explicaremos el operador de igualdad d√©bil **==** y el operador de desigualdad d√©bil **!=** pero, por ahora, nos limitaremos a utilizar siempre el operador de igualdad estricta **===** y el operador de desigualdad estricta **!==**.

## Quiz

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: question
**¬øCu√°l es el resultado de 24 \> 12?**

::::: choices
::: {.choice .correct-choice}
true
:::

::: choice
false
:::
:::::

:::::: question
**Los operadores de compraci√≥n solo se pueden usar con n√∫meros**

::::: choices
::: choice
S√≠, s√≥lo ah√≠ tiene sentido
:::

::: {.choice .correct-choice}
No, se pueden usar con otros tipos de datos como cadenas de textos o boleanos
:::
:::::
::::::

# Operadores l√≥gicos en JavaScript

Los operadores l√≥gicos en JavaScript (y en muchos otros lenguajes de programaci√≥n) se utilizan para evaluar expresiones l√≥gicas.

En JavaScript, hay tres operadores l√≥gicos: AND (&&), OR (\|\|) y NOT (!).

## Operador l√≥gico AND &&

El operador l√≥gico AND se indica con &&. Devuelve true cuando ambos valores que conecta son true.

``` javascript
true && true // ‚Üí true
true && false // ‚Üí false
false && false // ‚Üí false
```

Un ejemplo en la vida real ser√≠a preguntar. **¬øEst√°n todas las luces encendidas?** Se comprueba cada luz y si todas est√°n encendidas (true), entonces la respuesta es **true**. Si alguna luz est√° apagada (false), entonces la respuesta es **false**.

## Operador l√≥gico OR \|\|

El operador l√≥gico OR se indica con \|\| y devuelve true cuando cualquiera de los valores que conecta es true.

``` javascript
true || true // ‚Üí true
true || false // ‚Üí true
false || false // ‚Üí false
```

Un ejemplo en la vida real ser√≠a preguntar. **¬øHay alguna luz encendida?** Se comprueba cada luz y si alguna est√° encendida (true), entonces la respuesta es **true**. S√≥lo si todas las luces est√°n apagadas (false), entonces la respuesta es **false**.

## Operador l√≥gico NOT !

El operador l√≥gico NOT se indica con ! e invierte el valor de un valor booleano. Se pone delante del valor que queremos invertir.

``` javascript
!true // ‚Üí false
!false // ‚Üí true
```

Un ejemplo en la vida real ser√≠a pulsar el interruptor de la luz. Si la luz est√° encendida (true), entonces pulsando el interruptor la apagamos (false). Si la luz est√° apagada (false), entonces pulsando el interruptor la encendemos (true).

## Combinando operadores l√≥gicos, aritm√©ticos y de comparaci√≥n

Los operadores l√≥gicos y los operadores de comparaci√≥n se pueden combinar para crear expresiones m√°s complejas. Por ejemplo, podemos preguntar si un n√∫mero est√° entre dos valores.

``` javascript
2 < 3 && 3 < 4 // ‚Üí true
```

En este caso, la expresi√≥n se eval√∫a como **true** porque **2 \< 3** es **true** y **3 \< 4** es **true**. Si cualquiera de las dos expresiones fuera **false**, entonces la expresi√≥n ser√≠a **false**.

Tambi√©n puedes usar par√©ntesis para agrupar operaciones y usar operadores l√≥gicos y aritm√©ticos.

``` javascript
(2 + 2) < 3 && (10 < (8 * 2)) // ‚Üí false
```

Igualmente, es importante que sepas que las operaciones aritm√©ticas tienen precedencia sobre las operaciones de comparaci√≥n.

``` javascript
2 + 2 < 3 && 10 < 8 * 2
// Primero se hacen las operaciones aritm√©ticas:
// ‚Üí 4 < 3 && 10 < 16
// Ahora las comparaciones:
// ‚Üí false && true
// Finalmente:
// ‚Üí false
```

## Actividad

1.  Comprueba si 7 es mayor que 8 y menor que 10

2.  Tenemos un producto en una tienda. Cuesta 1500 y tenemos un descuento del 25%. Tengo \$1150 en mi billetera. Escribe un c√≥digo que me diga si puedo comprarlo. No utilizar parentesis.

<details>

<summary>Respuesta</summary>

R1.

``` javascript
7 > 8 && 7 < 10 // false
```

R2.

``` javascript
1150 >= 1500 * 0.75 // false
```

</details>

# Dos o m√°s operandos

Aunque todos los ejemplos que has visto hasta ahora usan dos operandos, los operadores l√≥gicos tambi√©n pueden usarse con m√°s de dos operandos.

``` javascript
true && true && true // ‚Üí true
```

Tambi√©n puedes mezclar operadores l√≥gicos:

``` javascript
true && true || false // ‚Üí true
!true && !true // ‚Üí false
false && true || !true // ‚Üí false
```

Ahora te puede costar un poco entender qu√© est√° pasando, pero con la pr√°ctica te ir√° resultando m√°s f√°cil. Prueba a hacer los ejercicios y a jugar con los operadores l√≥gicos para que te vayan quedando m√°s claros.

## Quiz

:::::: question
**¬øQu√© operador l√≥gico se utiliza para comprobar si dos o m√°s condiciones son verdaderas?**

::::: choices
::: choice
OR (\|\|)
:::

::: {.choice .correct-choice}
AND (&&)
:::
:::::
::::::

:::::: question
**¬øQu√© operador l√≥gico se utiliza para invertir el valor de un booleano?**

::::: choices
::: choice
OR (\|\|)
:::

::: {.choice .correct-choice}
NOT (!)
:::
:::::
::::::

:::::: question
**¬øQu√© valor devuelve la expresi√≥n false \|\| true?**

::::: choices
::: choice
false
:::

::: {.choice .correct-choice}
true
:::
:::::
::::::

# Variables

A la hora de crear programas, es vital poder almacenar la informaci√≥n para poder utilizarla en un futuro. En JavaScript, usamos variables para conseguirlo.

Para crear una variable podemos usar la palabra reservada **let** y le damos un nombre a la variable. Por ejemplo:

``` javascript
let numero
```

Tenemos una variable llamada numero pero no le hemos asignado ning√∫n valor. Para asignarle un valor, usamos el operador de asignaci√≥n =:

``` javascript
let numero = 1
```

Ahora, podemos referirnos a la variable numero y obtener el valor que le hemos asignado.

``` javascript
numero + 1 // -> 1 + 1
```

Tambi√©n podemos reasignarle un valor a la variable:

``` javascript
numero = 5
numero + 1 // -> 5 + 1
```

::: callout-tip
¬°Ojo! Si no guardas el valor de esta nueva operaci√≥n, el valor de la variable **numero** seguir√° siendo **5**.

``` javascript
numero = 5
numero + 1 // -> 5 + 1
numero + 1 // -> 5 + 1
```
:::

Ten en cuenta que el valor de la variable no tiene porque ser un n√∫mero. Puede ser cualquier tipo de dato, como un texto o un booleano.

``` javascript
let welcomeText = 'Hola'
let isCool = true
```

## Actividad

1.  Crea una variable llamada mensaje y as√≠gnale el valor "Hola JavaScript"

2.  Crea una variable llamada resultado y as√≠gnale la suma de 2 y 3

<details>

<summary>Respuesta</summary>

R1.

``` javascript
let mensaje = 'Hola JavaScript'
```

R2.

``` javascript
let resultado = 2 + 3
```

</details>

## Constantes const

Las constantes son variables que no pueden ser reasignadas. Para crear una constante, usamos la palabra reservada const:

``` javascript
const PI = 3.1415
```

Si intentas reasignar el valor de una constante, obtendr√°s un error:

``` javascript
PI = 3 // -> TypeError: Assignment to constant variable.
```

Como no se pueden reasignar, las constantes siempre deben ser inicializadas con alg√∫n valor. Esto es otra diferencia respecto a let, que no es necesario inicializarla con un valor.

``` javascript
let numero // ‚úÖ
const RADIUS // ‚ùå SyntaxError: Missing initializer in const declaration
```

Son muy √∫tiles para almacenar valores que no van a cambiar. Siempre que puedas, procura usar constantes para que tu c√≥digo sea m√°s predecible.

## Actividad

1.  Crea una constante llamada IS_DISABLED y as√≠gnale el booleano true

<details>

<summary>Respuesta</summary>

``` javascript
const IS_DISABLED = true
```

</details>

## Variables var

En JavaScript, tambi√©n podemos crear variables usando la palabra reservada **var**. Es la forma m√°s antigua y es normal que encuentres muchos tutoriales que lo usen. Sin embargo, a d√≠a de hoy, no es recomendable usar **var** ya que tiene comportamientos extra√±os que pueden causar errores en tu c√≥digo.

En una clase posterior te explicar√© cu√°l es la diferencia entre **let**, **const** y **var** adem√°s de por qu√©, siempre que puedas, deber√≠as evitar var.

## El nombre de las variables

En JavaScript, los nombres de las variables pueden contener letras, n√∫meros y el gui√≥n bajo (\_). Adem√°s, el primer car√°cter del nombre de la variable no puede ser un n√∫mero.

Es importante tener en cuenta que los nombres de las variables son sensibles a las may√∫sculas y min√∫sculas, lo que significa que **miVariable** y **mivariable** son dos variables diferentes en JavaScript.

``` javascript
let miVariable = 1
let mivariable = 2
miVariable + mivariable // -> 1 + 2
```

Tambi√©n es importante que los nombres de las variables sean descriptivos. Por ejemplo, si queremos almacenar el nombre de un usuario, podemos llamar a la variable userName. De esta forma, cuando leamos el c√≥digo, sabremos que la variable contiene el nombre de un usuario.

``` javascript
let n = 'Pepe' // ‚ùå Mal, no es descriptivo
let userName = 'Juan' // ‚úÖ Bien, se entiende
```

## Convenciones y nomenclaturas

En JavaScript, existen diferentes nomenclaturas para nombrar las variables: **camelCase**, **snake_case** y **SCREAMING_CASE**.

**camelCase** es la forma m√°s com√∫n de nombrar las variables en JavaScript. Consiste en escribir la primera palabra en min√∫sculas y las siguientes palabras con su primera letra en may√∫sculas. Por ejemplo:

``` javascript
let camelCase = 1
let camelCaseIsCool = 2
let userName = 'statick'
```

**snake_case** es una forma de nombrar que consiste en escribir todas las palabras en min√∫sculas y separarlas con guiones bajos. Por ejemplo:

``` javascript
let snake_case = 1
let snake_case_is_cool = 2
let user_name = 'statick'
```

En algunos lenguajes de programaci√≥n es muy com√∫n usar snake_case para nombrar las variables. En JavaScript no lo es tanto, pero todav√≠a puedes encontrar c√≥digo que lo use.

Lo m√°s habitual, y es buena idea, es usarlo en los nombres de archivos. Por ejemplo, **mi_archivo.js**. Esto es porque algunos sistemas operativos distinguen entre may√∫sculas y min√∫sculas y, por tanto, **mi_archivo.js** y **Mi_archivo.js** son dos archivos diferentes.

::: callout-tip
Tambi√©n existe kebab-case, que es una forma de nombrar que consiste en escribir todas las palabras en min√∫sculas y separarlas con guiones. Por ejemplo: mi-archivo.js. Es muy similar a snake_case pero con guiones en vez de guiones bajos. No se puede usar para nombrar variables pero s√≠ es com√∫n usarlo en los nombres de archivos.
:::

**SCREAMING_CASE** es una forma de nombrar que consiste en escribir todas las palabras en may√∫sculas y separarlas con guiones bajos. Por ejemplo:

``` javascript
const SCREAMING_CASE = 1
const SCREAMING_CASE_IS_COOL = 2
const USER_NAME = 'statick'
```

Para las constantes, con valores que no van a cambiar, es muy com√∫n usar **SCREAMING_CASE**. As√≠ se puede distinguir f√°cilmente de las variables que s√≠ cambian de valor. Por eso, no debes usarla para nombrar variables con **let**.

## Quiz

:::::: question
**¬øQu√© es una variable?**

::::: choices
::: {.choice .correct-choice}
En JavaScript, una variable es un contenedor de informaci√≥n que se utiliza para almacenar datos en un programa.
:::

::: choice
Una variable es un tipo de dato que se utiliza para almacenar informaci√≥n en un programa.
:::
:::::
::::::

:::::: question
**¬øQu√© peculiaridad tienen las variables const en JavaScript?**

::::: choices
::: {.choice .correct-choice}
No se pueden reasignar
:::

::: choice
S√≥lo pueden guardar n√∫meros
:::
:::::
::::::

::::::: question
**Siempre hay que asignar un valor a una variable**

:::::: choices
::: choice
S√≠, siempre
:::

::: choice
No, nunca
:::

::: {.choice .correct-choice}
S√≥lo si es una variable const
:::
::::::
:::::::

## null y undefined

¬øRecuerdas que te he comentado que existen diferentes tipos de datos en JavaScript? Hemos visto n√∫meros, cadenas de texto y booleanos.

En esta clase vas a aprender otros dos tipos de datos que, aunque son similares, tienen ligeras diferencias. Son **null** y **undefined**.

La particularidad de estos dos tipos de datos es que cada uno s√≥lo tiene un valor. El tipo **null** s√≥lo puede tener el valor **null** y el tipo **undefined** s√≥lo puede tener el valor undefined.

::: callout-tip
Es como el tipo booleano que pod√≠a ser **true** y **false** pero, en este caso, s√≥lo tiene un valor.
:::

## La diferencia entre null y undefined

Mientras que null es un valor que significa que algo no tiene valor, undefined significa que algo no ha sido definido. Por ejemplo, si creamos una variable sin asignarle ning√∫n valor, su valor ser√° undefined:

``` javascript
let rolloDePapel // -> undefined
```

Tambi√©n podemos asignar directamente el valor undefined a una variable:

``` javascript
let rolloDePapel = undefined // -> undefined
```

En cambio, para que una variable tenga el valor null, s√≥lo podemos conseguirlo asign√°ndole expl√≠citamente ese valor:

``` javascript
let rolloDePapel = null
```

Un caso bastante ilustrativo para entender la diferencia entre null y undefined es el siguiente:

![](images/paste-30.png)

## Actividad

1.  Crea una variable con let llamada capacidad y as√≠gnale un valor null

2.  Crea una variable con let llamada dinero y aseg√∫rate que tenga un valor de undefined

<details>

<summary>Respuesta</summary>

R1.

``` javascript
let capacidad = null
```

R2.

``` javascript
let dinero
```

</details>

## Comparaciones con null y undefined

Al usar la igualdad estricta que hemos visto en la clase anterior, null y undefined son considerados diferentes entre s√≠:

``` javascript
null === undefined // -\> false
```

S√≥lo cuando comparamos null con null o undefined con undefined obtenemos true:

``` javascript
null === null // -\> true undefined === undefined // -\> true
```

## Quiz

:::::: question
**null y undefined son dos valores que significan lo mismo.**

::::: choices
::: choice
S√≠, ambos indican la ausencia de valor.
:::

::: {.choice .correct-choice}
No, null es un valor que indica algo vac√≠o, mientras que undefined indica algo que no est√° definido todav√≠a.
:::
:::::
::::::

::::::: question
**¬øQu√© valor tiene una variable a la que no se le ha asignado nada al declararla?**

:::::: choices
::: choice
Un valor null
:::

::: {.choice .correct-choice}
Un valor undefined
:::

::: choice
No se puede declarar a una variable sin asignar un valor
:::
::::::
:::::::

# Operador typeof

El operador **typeof** devuelve una cadena de texto que indica el tipo de un operando. Puede ser usado con cualquier tipo de operando, incluyendo variables y literales.

``` javascript
const MAGIC_NUMBER = 7
typeof MAGIC_NUMBER // "number"
```

Tambi√©n puedes usarlo directamente con los valores que quieras comprobar:

``` javascript
typeof undefined // "undefined"
typeof true // "boolean"
typeof 42 // "number"
typeof "Hola mundo" // "string"
```

## Actividad

1.  Tengo una variable llamada userName. Excribe el c√≥digo necesario para ver su tipo.

<details>

<summary>Respuesta</summary>

``` javascript
let userName
typeof userName // "undefined"
```

</details>

Existe, sin embargo, un valor especial en JavaScript, **null**, que es considerado un bug en el lenguaje. El operador **typeof** devuelve **"object"** cuando se usa con **null**:

``` javascript
typeof null // "object"
```

Lo correcto ser√≠a que **typeof null** devolviera **"null"**, pero es un [error hist√≥rico que no se puede corregir sin romper el c√≥digo existente](https://2ality.com/2013/10/typeof-null.html).

Por eso, si quieres comprobar si una variable es **null**, debes usar la comparaci√≥n estricta **===**:

``` javascript
const foo = null
foo === null // true
```

Otra pregunta es... ¬øQu√© es ese **object**? Es un tipo de dato que est√° en el centro de JavaScript y que veremos en detalle m√°s adelante.

## Usando con operadores de comparaci√≥n

El operador **typeof** es muy √∫til cuando se usa con operadores de comparaci√≥n. Por ejemplo, para comprobar si una variable es del tipo que esperamos:

``` javascript
const age = 42
typeof age === "number" // true
```

Una vez que tenemos expresiones l√≥gicas, podemos empezar a encadenar operadores l√≥gicos para comprobar m√∫ltiples condiciones:

``` javascript
const age = 42
typeof age === "number" && age > 18 // true
```

## Actividad

1.  Tengo una variable llamada dogId pero no tengo claro si es una cadena de texto. Escribe el c√≥digo necesario para asegurarte.

<details>

<summary>Respuesta</summary>

``` javascript
typeof dogId === "string" // false
```

</details>

## Quiz

:::::: question
**¬øPara qu√© sirve el operador typeof en JavaScript?**

::::: choices
::: choice
Nos permite leer el valor de una variable
:::

::: {.choice .correct-choice}
Nos da el tipo de dato de una variable
:::
:::::
::::::

:::::: question
**El operador typeof siempre devuelve una cadena de texto con el tipo del operando.**

::::: choices
::: {.choice .correct-choice}
Si, siempre devuelve una cadena de texto
:::

::: choice
Depende del tipo de dato que le pasemos, Si le pasamos un n√∫mero, nos devolver√° un number
:::
:::::
::::::

## Comentarios

En JavaScript, los comentarios son **una forma de agregar explicaciones al c√≥digo que se ignora al ejecutar el programa**.

Los comentarios son √∫tiles para explicar el por qu√© del c√≥digo, documentar los cambios realizados en el c√≥digo y hacer que el c√≥digo sea m√°s f√°cil de entender para otros desarrolladores.

Hay **dos tipos de comentarios en JavaScript**: los comentarios de una sola l√≠nea y los comentarios de varias l√≠neas.

## Comentarios de una sola l√≠nea //

Los comentarios de una sola l√≠nea comienzan con **//** y se utilizan para agregar una explicaci√≥n en una sola l√≠nea de c√≥digo. Por ejemplo:

``` javascript
// S√≥lo usamos 6 decimales
const PI = 3.141592

// Iniciamos el radio por 10, pero puede cambiar
let radio = 10
```

Tambi√©n puedes a√±adir un comentario de una sola l√≠nea al final de una l√≠nea de c√≥digo. Por ejemplo:

``` javascript
const PI = 3.141592 // S√≥lo usamos 6 decimales
```

## Comentarios de varias l√≠neas /\* \*/

Los comentarios de varias l√≠neas comienzan con /\* y terminan con \*/. Se utilizan para agregar notas explicativas que ocupan varias l√≠neas de c√≥digo. Por ejemplo:

``` javascript
/*
  Este es un comentario de varias l√≠neas.
  Se utiliza para agregar notas explicativas que ocupan varias l√≠neas de c√≥digo.
*/
```

Ten en cuenta que tambi√©n puedes lograr varias l√≠neas usando el tipo de comentario //, s√≥lo que en este caso, cada l√≠nea de c√≥digo debe comenzar con //. Por ejemplo:

``` javascript
// Este es un comentario de varias l√≠neas.
// Se utiliza para agregar notas explicativas que ocupan varias l√≠neas de c√≥digo.
```

Es importante tener en cuenta que **los comentarios no afectan el funcionamiento del c√≥digo**. Es decir, si se eliminan los comentarios, el c√≥digo seguir√° funcionando de la misma manera.

Es recomendable utilizar comentarios con moderaci√≥n y de manera efectiva para hacer que el c√≥digo sea m√°s f√°cil de entender y mantener. **Los comentarios deben ser claros y concisos, y deben explicar lo que hace el c√≥digo sin repetir lo que ya es obvio**.

Es mejor que tu c√≥digo sea lo suficientemente claro como para no necesitar comentarios, pero si es necesario, **utiliza comentarios para explicar el por qu√© del c√≥digo, no el qu√©**.

## Quiz

:::::: question
**¬øPara qu√© sirven los comentarios en JavaScript?**

::::: choices
::: {.choice .correct-choice}
Sirven para documentar nuestro c√≥digo y explicar qu√© hace cada parte de √©l
:::

::: choice
Para cambiar el comportamiento de nuestro c√≥digo
:::
:::::
::::::

:::::: question
**¬øC√≥mo se escriben los comentarios en JavaScript?**

::::: choices
::: choice
Puedes usar \# para escribir comentarios de una l√≠nea o varias
:::

::: {.choice .correct-choice}
Puedes usar // para escribir comentarios de una l√≠nea o /\* \*/ para escribir comentarios de varias l√≠neas
:::
:::::
::::::

## console.log()

**console.log()** es una funci√≥n integrada en *JavaScript* que se utiliza para imprimir mensajes en la consola del navegador o del editor de c√≥digo. Se utiliza principalmente para depurar el c√≥digo y para **imprimir valores de variables y mensajes para ayudar en el proceso de desarrollo**.

::: callout-tip
En programaci√≥n, una funci√≥n es un conjunto de instrucciones que se pueden usar una y otra vez para hacer una tarea espec√≠fica. Muchas veces, las funciones se utilizan para evitar repetir c√≥digo y son parametrizables. M√°s adelante tendremos una secci√≥n s√≥lo para ellas.
:::

## Sintaxis

Para poder mostrar estos mensajes en consola, debes escribir **console.log()** y dentro de los par√©ntesis, el mensaje que quieres mostrar.

``` javascript
console.log('Hola, JavaScript')
// -> 'Hola, JavaScript'
```

Tambi√©n puedes averiguar el valor de una variable, escribiendo el nombre de la variable dentro de los par√©ntesis.

``` javascript
const nombre = 'JavaScript'
console.log(nombre)
// -> 'JavaScript'
```

Como ya sabes concatenar cadenas de texto, puedes mostrar un mensaje y el valor de una variable en el mismo **console.log()**.

``` javascript
const nombre = 'JavaScript'
console.log('Hola, ' + nombre)
// -> 'Hola, JavaScript'
```

Adem√°s, puedes mostrar varios mensajes y valores de variables en el mismo **console.log()** separ√°ndolos por comas.

``` javascript
const nombre = 'JavaScript'
const version = 2023
console.log(nombre, version)
// -> 'JavaScript 2023'
```

## M√°s m√©todos de console

Adem√°s de **console.log()**, existen otros m√©todos que puedes utilizar para imprimir mensajes en la consola. Algunos de ellos son:

::: callout-tip
-   **console.error():** Imprime un mensaje de error en la consola.

-   **console.warn():** Imprime un mensaje de advertencia en la consola.

-   **console.info():** Imprime un mensaje de informaci√≥n en la consola.
:::

Como ves, la sintaxis es la misma que **console.log()**, s√≥lo cambia el nombre del m√©todo.

::: callout-tip
Aunque puedes usar **console.log()** para imprimir cualquier tipo de mensaje, es recomendable utilizar los m√©todos que acabamos de ver para imprimir mensajes de error, advertencia e informaci√≥n ya que tienen un formato especial que los hace m√°s f√°ciles de identificar.
:::

``` javascript
console.error('Error')
// ‚ùå Error
console.warn('Advertencia')
// ‚ö†Ô∏è Advertencia
console.info('Informaci√≥n')
// ‚ÑπÔ∏è Informaci√≥n
```

Prueba estos m√©todos en la consola del navegador y observa los resultados.

## Quiz

::::::: question
**¬øCu√°l es la sintaxis adecuada para imprimir un mensaje en la consola del navegador?**

:::::: choices
::: choice
console("mensaje")
:::

::: {.choice .correct-choice}
console.log("mensaje")
:::

::: choice
console.write("mensaje")
:::
::::::
:::::::

::::::: question
**¬øC√≥mo podr√≠as usar console.log() para imprimir m√∫ltiples valores o variables en una sola l√≠nea de c√≥digo?**

:::::: choices
::: choice
Utilizando una sintaxis especial que formatea los valores o variables en una sola l√≠nea de c√≥digo
:::

::: choice
No es posible imprimir m√∫ltiples valores o variables en una sola l√≠nea de c√≥digo con console.log()
:::

::: {.choice .correct-choice}
Separando cada valor o variable con comas dentro de los par√©ntesis de console.log()
:::
::::::
:::::::

::::::: question
**¬øCu√°l es la diferencia entre console.log() y console.error() en JavaScript?**

:::::: choices
::: {.choice .correct-choice}
console.log() se utiliza para imprimir mensajes en la consola del navegador, mientras que console.error() se utiliza para imprimir mensajes de error.
:::

::: choice
console.log() se utiliza para imprimir mensajes de error en la consola del navegador, mientras que console.error() se utiliza para imprimir mensajes normales
:::

::: choice
No hay diferencia entre console.log() y console.error() en JavaScript
:::
::::::
:::::::

# C√≥digo Condicional con if

El c√≥digo condicional es un bloque de c√≥digo que se ejecuta s√≥lo si se cumple una condici√≥n. En JavaScript usamos la palabra reservada if para crear un bloque condicional, as√≠:

``` javascript
if (condici√≥n) {
  // c√≥digo que se ejecuta si la condici√≥n es verdadera
}
```

Como ves, ponemos la condici√≥n entre par√©ntesis y el c√≥digo se ejecuta si la condici√≥n entre llaves es **true**. Si la condici√≥n es **false**, el c√≥digo no se ejecuta.

Imagina que quieres mostrar un mensaje si la edad de un usuario es mayor o igual a 18 a√±os. Podr√≠as hacerlo as√≠:

``` javascript
const edad = 18

if (edad >= 18) {
  console.log('Eres mayor de edad')
}
```

## else

Es posible utilizar la palabra clave **else** para ejecutar un bloque de c√≥digo diferente si la condici√≥n es falsa:

``` javascript
const edad = 17

if (edad >= 18) {
  console.log('Eres mayor de edad')
} else {
  console.log('Eres menor de edad')
}
```

Esto es √∫til para ejecutar un bloque de c√≥digo u otro dependiendo de si se cumple o no una condici√≥n. else if

Tambi√©n podemos utilizar la palabra clave **else if** para comprobar m√°s de una condici√≥n:

``` javascript
const edad = 17

if (edad >= 18) {
  console.log('Eres mayor de edad')
} else if (edad >= 16) {
  console.log('Eres casi mayor de edad')
} else {
  console.log('Eres menor de edad')
}
```

El programa comprueba la primera condici√≥n. Si es **true**, ejecuta el c√≥digo dentro del bloque **if**. Si es **false**, comprueba la siguiente condici√≥n. Si es **true**, ejecuta el c√≥digo dentro del bloque **else if**. Si es false, ejecuta el c√≥digo dentro del bloque **else**.

Dicho de otra forma, entrar√° en el primer bloque que cumpla la condici√≥n y no entrar√° en los dem√°s. Si no cumple ninguna, entonces entrar√° en el bloque **else**.

## Anidaci√≥n de condicionales

Es posible anidar condicionales dentro de otros condicionales. Por ejemplo:

``` javascript
const edad = 17
const tieneCarnet = true

if (edad >= 18) {
  if (tieneCarnet) {
    console.log('Puedes conducir')
  } else {
    console.log('No puedes conducir')
  }
} else {
  console.log('No puedes conducir')
}
```

En muchas ocasiones vas a querer evitar la anidaci√≥n innecesaria de condicionales ya que se hacen dif√≠ciles de leer y mantener. En estos casos es mejor utilizar operadores l√≥gicos para crear la condici√≥n:

``` javascript
const edad = 17
const tieneCarnet = true

// si es mayor de edad y tiene carnet entonces...
if (edad >= 18 && tieneCarnet) {
  console.log('Puedes conducir')
} else {
  console.log('No puedes conducir')
}
```

Otra t√©cnica muy interesante es la de guardar el resultado de la condici√≥n en una variable, para que tus condiciones sean mucho m√°s legibles:

``` javascript
const edad = 17
const tieneCarnet = true
const puedeConducir = edad >= 18 && tieneCarnet

if (puedeConducir) {
  console.log('Puedes conducir')
} else {
  console.log('No puedes conducir')
}
```

::: callout-tip
¬°Wow! ¬øHas visto c√≥mo hemos mejorado la legibilidad de nuestro c√≥digo? ¬°Es mucho m√°s f√°cil de leer y entender! A este tipo de t√©cnica se le llama *refactorizaci√≥n* y consiste en mejorar el c√≥digo sin cambiar su comportamiento.
:::

## La importancia de las llaves

Es importante que sepas que las llaves **{ }** no siempre son obligatorios. Si el bloque de c√≥digo s√≥lo tiene una l√≠nea, puedes omitir las llaves:

``` javascript
const edad = 17

if (edad >= 18)
  console.log('Eres mayor de edad')
else
  console.log('Eres menor de edad')
```

Tambi√©n lo puedes escribir en la misma l√≠nea:

``` javascript
const edad = 18

if (edad >= 18) console.log('Eres mayor de edad')
else console.log('Eres menor de edad')
```

Sin embargo, **te recomiendo que mientras est√©s aprendiendo siempre escribas las llaves**. Esto te ayudar√° a evitar errores y a que tu c√≥digo sea m√°s legible.

## Quiz

:::::: question
**¬øQu√© es un bloque condicional en JavaScript?**

::::: choices
::: {.choice .correct-choice}
Un bloque de c√≥digo que se ejecuta s√≥lo si se cumple una condici√≥n
:::

::: choice
Un bloque de c√≥digo que se ejecuta siempre
:::
:::::
::::::

::::::: question
**¬øQu√© palabra clave se utiliza en JavaScript para crear un bloque condicional?**

:::::: choices
::: choice
if
:::

::: {.choice .correct-choice}
else
:::

::: choice
then
:::
::::::
:::::::

::::::: question
**¬øQu√© palabra clave se utiliza en JavaScript para ejecutar un bloque de c√≥digo si la condici√≥n de un bloque condicional es falsa?**

:::::: choices
::: choice
if
:::

::: choice
then
:::

::: {.choice .correct-choice}
else
:::
::::::
:::::::

## Actividad

1.  Crea una variable llamada **temperatura** y as√≠gnale un valor num√©rico. Escribe un bloque condicional que imprima en la consola si la temperatura es mayor o igual a 25 grados.

2.  Crea una variable llamada **esVerano** y as√≠gnale un valor booleano. Escribe un bloque condicional que imprima en la consola si es verano o no.

<details>

<summary>Respuesta</summary>

R1.

``` javascript
const temperatura = 25

if (temperatura >= 25) {
  console.log('Hace calor')
}
```

R2.

``` javascript
const esVerano = true

if (esVerano) {
  console.log('Es verano')
}
```

</details>

# Bucles con while

Un bucle es una **estructura de control** que permite repetir un bloque de instrucciones. Vamos, **repetir una tarea tantas veces como queramos**.

En JavaScript, existen varias formas de lograrlo, y una de ellas es el bucle con **while**. El bucle **while** es una estructura de control de flujo que ejecuta una secci√≥n de c√≥digo mientras se cumple una determinada condici√≥n.

En esta clase, vamos a explicar c√≥mo funciona el bucle **while** en JavaScript y c√≥mo podemos utilizarlo en nuestros programas.

## Sintaxis

La sintaxis del bucle **while** es similar a la de un condicional **if**. La √∫nica diferencia es que, en lugar de ejecutar el c√≥digo una sola vez, se ejecuta mientras se cumpla la condici√≥n.

``` javascript
while (condici√≥n) {
  // c√≥digo a ejecutar mientras se cumpla la condici√≥n
}
```

El bucle comienza evaluando la condici√≥n dentro de los par√©ntesis. Si la condici√≥n es **true**, se ejecuta el c√≥digo dentro de las llaves.

Despu√©s de ejecutar el c√≥digo, la condici√≥n se eval√∫a de nuevo, y si sigue siendo verdadera, el c√≥digo dentro de las llaves se ejecuta de nuevo. **Este proceso se repite hasta que la condici√≥n se eval√∫a como falsa**.

Ten en cuenta que, si la condici√≥n es falsa desde el principio, el c√≥digo dentro de las llaves nunca se ejecutar√°.

::: callout-tip
A cada vuelta del bucle se le llama **iteraci√≥n**. Una iteraci√≥n es la repetici√≥n de un proceso o acci√≥n un n√∫mero determinado de veces, de manera ordenada y sistem√°tica.
:::

## Ejemplo de uso de while

Vamos a crear la cuenta atr√°s de un cohete. Creamos una variable **cuentaAtras** que contenga el n√∫mero de segundos que faltan para el lanzamiento. En este caso, vamos a empezar con 10 segundos.

``` javascript
let cuentaAtras = 10
```

Para quitarle un segundo a la cuenta atr√°s, vamos a utilizar el operador de resta (**-**) y el operador de asignaci√≥n (**=**).

``` javascript
let cuentaAtras = 10
cuentaAtras = cuentaAtras - 1
console.log(cuentaAtras) // -> 9
```

Sabiendo esto y c√≥mo funciona el bucle while, podemos crear la cuenta atr√°s del cohete.

``` javascript
// iniciamos la variable fuera del bucle
let cuentaAtras = 10

// mientras la cuenta atr√°s sea mayor que 0
while (cuentaAtras > 0) {
  // mostramos el valor de la cuenta atr√°s en cada iteraci√≥n
  console.log(cuentaAtras)
  // restamos 1 a la cuenta atr√°s
  cuentaAtras = cuentaAtras - 1
}

console.log('¬°Despegue! üöÄ')
```

Si ejecutas este c√≥digo en consola, deber√≠as ver los n√∫meros del 10 al 1, y despu√©s el mensaje de despegue.

## Cuidado con los bucles infinitos

Los bucles **while** son muy potentes, pero tambi√©n pueden ser peligrosos. Si la condici√≥n nunca se eval√∫a como falsa, el bucle se ejecutar√° infinitamente.

``` javascript
while (true) {
  console.log('¬°Hola hasta el infinito!')
}
```

Esto evaluar√° la condici√≥n **true** como verdadera, y ejecutar√° el c√≥digo dentro de las llaves una y otra vez.

## Saliendo de un bucle con break

Podemos controlar cu√°ndo queremos salir de un bucle utilizando la palabra reservada **break**. Cuando el int√©rprete de JavaScript encuentra la palabra **break**, sale del bucle y contin√∫a ejecutando el c√≥digo que haya despu√©s.

``` javascript
let cuentaAtras = 10

while (cuentaAtras > 0) {
  console.log(cuentaAtras)
  cuentaAtras = cuentaAtras - 1

  // si la cuenta atr√°s es 5, salimos del bucle
  if (cuentaAtras === 5) {
    break // <---- salimos del bucle
  }
}
```

¬øCu√°l es el valor de **cuentaAtras** en este c√≥digo? Veamos, el bucle estaba haciendo una cuenta atr√°s... pero le hemos dicho que cuando tuviese el valor **5** saliese del bucle. Por lo tanto, el valor de **cuentaAtras** es **5**.

Usar **break** puede ser √∫til en bucles si queremos salir de ellos por alguna condici√≥n en concreto o para evitar justamente los bucles infinitos.

## Saltando una iteraci√≥n con continue

Igual que tenemos la posibilidad de "romper" el bucle con **break**, tambi√©n podemos saltarnos una iteraci√≥n con **continue**. Cuando el int√©rprete de JavaScript encuentra la palabra **continue**, salta a la siguiente iteraci√≥n del bucle.

``` javascript
let cuentaAtras = 10

while (cuentaAtras > 0) {
  cuentaAtras = cuentaAtras - 1

  // si la cuenta atr√°s es un n√∫mero par...
  if (cuentaAtras % 2 === 0) {
    continue // <---- saltamos a la siguiente iteraci√≥n
  }

  console.log(cuentaAtras)
}
```

¬øQu√© aparece en la salida de la consola? El bucle est√° haciendo una cuenta atr√°s... pero le hemos dicho que si el n√∫mero es par, se salte esa iteraci√≥n y deje de ejecutar el c√≥digo que le sigue.

Por ello, los n√∫meros pares no aparecen en la consola.

## Anidaci√≥n de bucles

Podemos anidar bucles dentro de otros bucles. Imagina que en nuestra cuenta atr√°s para el cohete, tenemos que revisar que 3 cosas est√°n en sus par√°metros: el ox√≠geno, el combustible y la temperatura.

``` javascript
const NUMERO_REVISIONES = 3
let cuentaAtras = 10

// mientras la cuenta atr√°s sea mayor que 0
while (cuentaAtras > 0) {
  // mostramos el valor de la cuenta atr√°s
  console.log(cuentaAtras)

  // creamos una variable para contar las revisiones realizadas
  // y la inicializamos a cero
  let revisionesRealizadas = 0

  // hasta que no hayamos realizado las 3 revisiones...
  while (revisionesRealizadas < NUMERO_REVISIONES) {
    // y sumamos 1 a las revisiones realizadas
    revisionesRealizadas = revisionesRealizadas + 1
    console.log(revisionesRealizadas + ' revisiones realizadas...')
  }

  // ahora podemos restar 1 a la cuenta atr√°s
  cuentaAtras = cuentaAtras - 1
}
```

::: callout-tip
¬øPor qu√© la constante la hemos puesto toda en may√∫sculas? Como ya explicamos en la clase de introducci√≥n a JavaScript, es una convenci√≥n para indicar que es una constante y que no va a cambiar.
:::

Adem√°s del bucle anidado, hay algo tambi√©n muy interesante en el c√≥digo anterior y es la creaci√≥n de la variable **let revisionesRealizadas**.

Ten en cuenta que esa variable se crear√° y se inicializar√° a **0** en cada iteraci√≥n del bucle.

Las variables creadas con **let** y **const** que se crean dentro de un bucle, solo existen dentro de ese bucle. Cuando el bucle termina, la variable desaparece. De hecho si intentas acceder a ella fuera del bucle, te dar√° un error.

``` javascript
let cuentaAtras = 10

while (cuentaAtras > 0) {
  let revisionesRealizadas = 3
  console.log(revisionesRealizadas)
  cuentaAtras = cuentaAtras - 1
}

console.log(revisionesRealizadas) // -> ERROR: ReferenceError
```

Esto tambi√©n pasa con otras estructuras de control. Eso es porque el alcance de las variables creadas con **let** y **const** es el bloque entre **{ }** en el que se crean. Lo iremos viendo m√°s adelante para que vayas practicando, no te preocupes.

## Quiz

:::::: question
**¬øCu√°l es la sintaxis correcta para utilizar un bucle while en JavaScript?**

::::: choices
::: {.choice .correct-choice}
![](images/paste-31.png)
:::

::: choice
![](images/paste-34.png)
:::
:::::
::::::

::::::: question
**¬øCu√°l es la palabra reservada que se utiliza para salir de un bucle en JavaScript?**

:::::: choices
::: {.choice .correct-choice}
break
:::

::: choice
continue
:::

::: choice
exit
:::
::::::
:::::::

:::::::: question
**¬øCu√°ntas veces saldr√° en consola la palabra 'Caf√©'?**

::: center
![](images/paste-36.png)
:::

:::::: choices
::: {.choice .correct-choice}
6
:::

::: choice
4
:::

::: choice
5
:::
::::::
::::::::

# Bucles con do while

Aunque no es muy famoso ni muy utilizado, es interesante que sepas que existe en JavaScript un bucle que se ejecuta al menos una vez, y luego se repite mientras se cumpla una condici√≥n. Este bucle se llama **do while** y tiene la siguiente sintaxis:

``` javascript
do {
  // c√≥digo que se ejecuta al menos una vez
} while (condici√≥n);
```

Vamos a aprovechar para hacer m√°s interesante la clase. Por eso te voy a presentar una funci√≥n integradas en JavaScript que nos van a dar mucho juego: **confirm**.

# confirm

La funci√≥n **confirm** muestra un cuadro de di√°logo con dos botones: "Aceptar" y "Cancelar". Si el usuario pulsa "Aceptar", la funci√≥n devuelve **true**. Si pulsa "Cancelar", devuelve **false**.

``` javascript
confirm("¬øTe gusta JavaScript?");
```

Llamar a la funci√≥n **confirm** es una expresi√≥n y, por lo tanto, produce un valor que podemos guardar en una variable.

``` javascript
let respuesta = confirm("¬øTe gusta JavaScript?")
console.log(respuesta) // -> true o false
```

# Usando do while

Vamos a hacer un programa que saldr√° de un bucle **do while** cuando el usuario pulse "Cancelar" en el cuadro de di√°logo que muestra la funci√≥n **confirm**.

``` javascript
let respuesta

do {
  respuesta = confirm("¬øTe gusta JavaScript?");
} while (respuesta)
```

::: callout-tip
¬øPor qu√© hay que poner la variable **respuesta** fuera? Porque si no, no podr√≠a ser usada en la condici√≥n del bucle. Ya vas viendo lo que coment√°mos antes del √°mbito de las variables.
:::

Si el usuario pulsa "Aceptar", la variable **respuesta** valdr√° **true** y el bucle se repetir√°. Si el usuario pulsa "Cancelar", la variable **respuesta** valdr√° **false** y el bucle se detendr√°.

## Quiz

::::::: question
¬øCu√°ntas veces como m√≠nimo se ejecutar√° el c√≥digo dentro de un bucle do{ ... } while?

:::::: choices
::: choice
Ninguna vez
:::

::: choice
Depende de la condici√≥n
:::

::: {.choice .correct-choice}
Una vez
:::
::::::
:::::::

# Expresiones y declaraciones

En JavaScript, existen dos tipos de elementos fundamentales para escribir c√≥digo: **expresiones** y **declaraciones**. Aunque estos t√©rminos pueden parecer confusos al principio, son conceptos clave para comprender c√≥mo funciona JavaScript.

# Declaraciones

Las declaraciones en JavaScript son sentencias que definen la creaci√≥n de una variable, funci√≥n o clase. **Podr√≠amos decir que las declaraciones son como las instrucciones que le damos a JavaScript para que haga algo**.

::: callout-tip
Las funciones y las clases las veremos m√°s adelante en el curso, no te preocupes.
:::

Por ejemplo, una declaraci√≥n de variable es una sentencia que le da un nombre y un valor a una variable. El siguiente c√≥digo es un ejemplo de una declaraci√≥n de variable:

``` javascript
let nombre = "Juan"
```

Este c√≥digo no lo puedes usar con el m√©todo **console.log**, ya que no produce ning√∫n valor. Si lo intentas, obtendr√°s un error:

``` javascript
console.log(let nombre = "Juan") // SyntaxError
```

# Expresiones

**Las expresiones en JavaScript son sentencias que producen un valor**. Las expresiones pueden ser tan simples como un solo n√∫mero o una cadena de texto, o tan complejas como el c√°lculo de una operaci√≥n matem√°tica, la evaluaci√≥n de diferentes valores o la llamada a una funci√≥n.

Por ejemplo, una expresi√≥n num√©rica es una sentencia que produce un n√∫mero:

``` javascript
2 + 3 // -> 5
```

De hecho, lo que guardamos en las variables son expresiones. Por ejemplo, en el siguiente c√≥digo, la expresi√≥n **2 + 3** se eval√∫a y el resultado se guarda en la variable **resultado**:

``` javascript
let resultado = 2 + 3
```

En ese c√≥digo tenemos la declaraci√≥n que queremos guardar en la variable resultado el **resultado** de la expresi√≥n **2 + 3**.

# ¬øPor qu√© es importante la diferencia?

La diferencia entre declaraciones y expresiones es importante ya que no podemos usar una declaraci√≥n donde se espera una expresi√≥n y viceversa.

Por ejemplo, ya hemos conocido las estructuras de control **if** y **while**. Ambas esperan una expresi√≥n que se eval√∫a a un valor booleano. Por lo tanto, no podemos usar una declaraci√≥n en su lugar:

``` javascript
// ‚ùå Ambos c√≥digos est√°n mal y sirven para
// ilustrar que no debes usar declaraciones
// cuando espera expresiones

if (let nombre = "Juan") { // ‚ùå SyntaxError
  console.log("Hola, Juan")
}

while (let i = 0) { // ‚ùå SyntaxError
  console.log("Iteraci√≥n")
  i = i + 1
}
```

# Quiz

::::::: question
¬øQu√© son las declaraciones en JavaScript y para qu√© se utilizan?

:::::: choices
::: {.choice .correct-choice}
Las declaraciones en JavaScript son sentencias que definen la creaci√≥n de una variable, funci√≥n o clase para que puedan ser usadas posteriormente en el c√≥digo.
:::

::: choice
Las declaraciones en JavaScript son sentencias que producen un valor. Se utilizan para calcular un valor y devolverlo en una expresi√≥n.
:::

::: choice
Las declaraciones en JavaScript son sentencias que se utilizan para realizar operaciones matem√°ticas complejas.
:::
::::::
:::::::

::::::: question
¬øQu√© son las expresiones en JavaScript y para qu√© se utilizan?

:::::: choices
::: choice
Las expresiones en JavaScript son sentencias que definen la creaci√≥n de una variable
:::

::: {.choice .correct-choice}
Las expresiones en JavaScript son sentencias que producen un valor.
:::

::: choice
Las expresiones s√≥lo se usan como condiciones de los condicionales if y los bucles.
:::
::::::
:::::::

# Bucles con for

La estructura de control **for** en JavaScript es muy √∫til para ejecutar una serie de instrucciones un n√∫mero determinado de veces. A diferencia de **while** que usa una condici√≥n para determinar si se ejecuta o no el bloque de c√≥digo, **for** usa un contador que se incrementa en cada iteraci√≥n hasta que se cumple una condici√≥n.

La sintaxis de **for** es la siguiente:

``` javascript
for (inicializaci√≥n; condici√≥n; actualizaci√≥n) {
  // c√≥digo a ejecutar
}
```

Importante, f√≠jate que **for** tiene tres partes separadas por ;:

-   La *inicializaci√≥n* se realiza antes de que se inicie el bucle y se utiliza para declarar variables y asignar valores iniciales.

-   La *condici√≥n* es una expresi√≥n *booleana* que se eval√∫a antes de cada iteraci√≥n del bucle. Si la expresi√≥n se eval√∫a como **true**, se ejecuta el bloque de c√≥digo dentro del bucle. Si la expresi√≥n se eval√∫a como **false**, el bucle termina.

-   La actualizaci√≥n se utiliza para actualizar el valor de la variable de control del bucle despu√©s de cada iteraci√≥n. Normalmente, se incrementa o decrementa el valor de la variable de control del bucle.

# Ejemplo de uso de for

El siguiente ejemplo muestra c√≥mo se puede usar **for** para imprimir los n√∫meros del 1 al 10:

``` javascript
for (let number = 1; number <= 10; number++) {
  console.log(number)
}
```

-   La inicializaci√≥n es la declaraci√≥n de la variable **number** y la asignaci√≥n del valor **1**.
-   La condici√≥n es que mientras **number \<= 10**, se itera el bucle.
-   La actualizaci√≥n es **number++** que incrementa el valor de **number** en 1 despu√©s de cada iteraci√≥n.

Oh, espera, **¬øqu√© es eso de number++? Te lo explico**.

# Incrementando n√∫meros con ++

El operador **++** nos permite incrementar el valor de una variable n√∫mero en 1. Por ejemplo, si tenemos la variable **i** con el valor **5**, **i++** incrementar√≠a el valor de **i** en 1, es decir, **i** pasar√≠a a valer **6**.

``` javascript
let i = 5
i++
console.log(i) // -> 6
```

Es una forma abreviada de escribir **i = i + 1**. Y, como ves, es la forma m√°s t√≠pica de usar en bucles como **for** para no tener que escribir **i = i + 1** cada vez.

# Iterando al rev√©s

El m√©todo **for** en JavaScript tambi√©n se puede utilizar para iterar al rev√©s Para ello, se utiliza la sintaxis **i--** en la secci√≥n de actualizaci√≥n del bucle en lugar de **i++**.

La sintaxis del m√©todo for para iterar en reversa es la siguiente:

``` javascript
for (let i = 10; i >= 0; i--) {
  if (i === 0) {
    console.log('¬°Despegue üöÄ!')
  } else {
    console.log('Faltan ' + i + ' segundos')
  }
}
```

# Llevando m√°s all√° el bucle for

Aunque siempre los ejemplos con **for** son los mismos, ten en cuenta que puedes hacer cualquier cosa en la inicializaci√≥n, condici√≥n y actualizaci√≥n. Podr√≠as, por ejemplo, usar dos variables a la vez.

``` javascript
for (let i = 0, j = 5; i < 5; i++, j--) {
  console.log(i, j);
}
```

La coma **,** nos permite declarar dos variables en la inicializaci√≥n y actualizarlas en la actualizaci√≥n. En este caso la **,** es un **operador que evalua cada uno de sus operandos** (de izquierda a derecha) y retorna el valor del √∫ltimo operando.

No es muy com√∫n su uso, pero es bueno saber que existe.

# continue y break

Al igual que en **while**, **for** tambi√©n tiene las palabras reservadas **continue** y **break** para controlar el flujo de ejecuci√≥n del bucle.

Recuerda que **continue** se usa para saltar a la siguiente iteraci√≥n del bucle y **break** para salir del bucle.

Ejemplo:

``` javascript
for (let i = 0; i < 10; i++) {
  const esPar = i % 2 === 0
  if (esPar) {
    continue
  }

  // Solo mostramos este consola.log si es impar
  console.log(i)

  // Salimos del bucle al llegar al 7
  if (i === 7) {
    break
  }
}
```

# Bucles anidados con for

Imagina que quieres crear **la tabla de multiplicar del 1 al 10**. Para ello, necesitas un bucle que itere del 1 al 10 y, dentro de ese bucle, otro bucle que itere del 1 al 10. Esto se puede hacer con dos bucles **for** anidados (uno dentro del otro).

``` javascript
for (let i = 1; i <= 10; i++) {
  for (let j = 1; j <= 10; j++) {
    const resultado = i * j
    console.log(i + ' x ' + j + ' = ' + resultado)
  }
}
```

# Quiz

::: question
¬øCu√°l es la sintaxis correcta para crear un bucle for en JavaScript?

::: choices

::: choice
![](images/paste-42.png)
:::

::: {.choice .correct-choice}
![](images/paste-44.png)
:::

:::
:::

::: question
¬øCu√°ntas veces veremos el mensaje "Hola" en consola?

``` javascript
for (let i = 0; i < 10 && i !== 3; i++) {
  console.log('Hola')
}
```

::: choices

::: {.choice}
10 veces
:::

::: choice
4 veces
:::

::: {.choice .correct-choice}
3 veces
:::

:::
:::

# Switch

En JavaScript, la sentencia **switch** es una estructura de control que nos permite ejecutar diferentes bloques de c√≥digo dependiendo del valor de una **expresi√≥n**. Esta estructura es √∫til cuando queremos realizar diferentes acciones basadas en una √∫nica variable.

# Sintaxis

La sentencia switch eval√∫a una expresi√≥n, comparando el valor con los diferentes casos que le hemos definido. Si hay coincidencia ejecuta el bloque de c√≥digo asociado. Para ello, se utiliza la sentencia **break** para separar cada caso y evitar que se sigan evaluando el resto de casos.

``` javascript
switch (expresi√≥n) {
  case valor1:
    // c√≥digo a ejecutar si la expresi√≥n coincide con valor1
    break

  case valor2:
    // c√≥digo a ejecutar si la expresi√≥n coincide con valor2
    break
  default:
    // c√≥digo a ejecutar si la expresi√≥n no coincide con ning√∫n valor
    break
}
```

:::{.callout-tip}
La condici√≥n de **default** es opcional. No es obligatorio que la uses si no la necesitas. Es como el **else** de las condiciones **if**.
:::
Por ejemplo si queremos mostrar un mensaje diferente dependiendo del d√≠a de la semana:

``` javascript
const dia = "lunes"

switch (dia) {
  case "lunes":
    console.log("¬°Hoy es lunes! üò¢")
    break

  default:
    console.log("No es lunes, YAY! üöÄ")
    break
}
```

Vamos a hacer esto un poco m√°s interesante. En JavaScript podemos recuperar la informaci√≥n de la hora y la fecha usando el objeto **Date**. Este objeto tiene un m√©todo llamado **getDay()** que nos devuelve el d√≠a de la semana en formato num√©rico, siendo 0 el domingo y 6 el s√°bado.

:::{.callout-tip}
Igual que **console** es un objeto. Tambi√©n **Date** lo es. Un objeto en JavaScript no es muy diferente a un objeto en la vida real. Tiene propiedades y funciones que podemos usar. En este caso, **getDay()** es una funci√≥n que nos devuelve el d√≠a de la semana.
:::

``` javascript
const dia = new Date().getDay()

// segun el dia de la semana, mostramos un mensaje diferente
switch (dia) {
  case 0:
    console.log("¬°Hoy es domingo! üò¥")
    break
  case 1:
    console.log("¬°Nooo, es lunes! üò¢")
    break
  case 2:
    console.log("¬°Hoy es martes! ü•µ")
    break
  case 3:
    console.log("¬°Hoy es mi√©rcoles! ü§ì")
    break
  default:
    console.log("Se acerca el fin de! üöÄ")
    break
}
```
# switch vs if

Muchas veces ver√°s que puedes escribir el mismo c√≥digo usando **switch** o **if**. El ejemplo anterior con un **if**:

``` javascript
const dia = new Date().getDay()

if (dia === 0) {
  console.log("¬°Hoy es domingo! üò¥")
} else if (dia === 1) {
  console.log("¬°Nooo, es lunes! üò¢")
} else if (dia === 2) {
  console.log("¬°Hoy es martes! ü•µ")
} else if (dia === 3) {
  console.log("¬°Hoy es mi√©rcoles! ü§ì")
} else {
  console.log("Se acerca el fin de! üöÄ")
}
```

A veces es m√°s f√°cil de leer con **switch** y otras con **if**. ¬°Depende de ti! Aunque m√°s adelante, en el curso, veremos alternativas a **switch** usando algunas estructuras de datos.

# Agrupando cases

En ocasiones, queremos que varios casos ejecuten el mismo c√≥digo. En lugar de repetir el mismo c√≥digo en cada caso, podemos agruparlos usando el mismo **case** para cada uno de ellos.

``` javascript
const dia = new Date().getDay()

switch (dia) {
  case 0:
  case 6:
    console.log("¬°Hoy es fin de semana! ü•≥")
    break
  case 1:
  case 2:
  case 3:
  case 4:
    console.log("¬°Nooo, a trabajar! üò¢")
    break
  case 5:
    console.log("¬°Hoy es viernes! ü§ì")
    break
}
```

Como ves, en este caso, tampoco estamos usando el **default**. Como te comentaba antes, es totalmente opcional, no tienes por qu√© usarlo siempre.

# ¬°No olvides el break!

Es muy importante que no te olvides de poner el **break** al final de cada caso. Si no lo pones, se ejecutar√°n todos los casos que vengan despu√©s del que coincide. Por ejemplo:

``` javascript
// ‚ùå Este c√≥digo no es correcto
// Lo muestro para que veas qu√© pasa
// si no pones break en tus casos
const dia = new Date().getDay()

switch (dia) {
  case 0:
    console.log("¬°Hoy es domingo! üò¥")
  case 1:
    console.log("¬°Nooo, es lunes! üò¢")
  case 2:
    console.log("¬°Hoy es martes! ü•µ")
  case 3:
    console.log("¬°Hoy es mi√©rcoles! ü§ì")
  default:
    console.log("Se acerca el fin de! üöÄ")
}
```

Si hoy es martes (**2**), se ejecutar√°n todos los casos despu√©s de ese, ya que no hay ning√∫n **break** que lo impida. Por lo tanto, el resultado en consola ser√≠a:


``` bash
¬°Hoy es martes! ü•µ
¬°Hoy es mi√©rcoles! ü§ì
Se acerca el fin de! üöÄ
```

# El patr√≥n switch(true)

Existe un patr√≥n que se usa a veces con **switch** que es **switch(true)**. Esto es, en lugar de evaluar una expresi√≥n, eval√∫a una condici√≥n ignorando por completo el valor de la expresi√≥n.

Por ejemplo:

``` javascript
let edad = 25;

switch(true) {
  case (edad >= 18 && edad < 25):
    console.log("Eres mayor de edad y eres joven");
    break;
  case (edad >= 25 && edad < 40):
    console.log("Eres mayor de edad y est√°s en plena madurez");
    break;
  case (edad >= 40):
    console.log("Eres mayor de edad y est√°s en la mejor edad");
    break;
  default:
    console.log("Eres menor de edad");
}
```

Es un patr√≥n algo m√°s avanzado y es una alternativa a usar **if** y **else if**. En mi opini√≥n, es m√°s dif√≠cil de leer, ya que puede crear un poco de confusi√≥n. Pero es bueno que lo conozcas por si te lo encuentras en alg√∫n sitio.

# Quiz

::: question
¬øCu√°l es la funci√≥n de la palabra reservada default en una declaraci√≥n switch en JavaScript?

::: choices

::: {.choice .correct-choice}
Es el caso que se ejecuta cuando se produce un error en el switch
:::

::: choice
Es el caso que se ejecuta cuando ninguno de los casos coincide con la expresi√≥n
:::

::: {.choice}
Es un caso opcional que se puede utilizar para realizar acciones adicionales
:::

:::
:::

::: question
¬øQu√© problema tiene este c√≥digo?

``` javascript
switch (day) {
  case 0:
    console.log('Hoy es Domingo')
  case 1:
    console.log('Hoy es Lunes')
  case 2:
    console.log('Hoy es Martes')
  default:
    console.log('Es otro d√≠a')
}
```

::: choices

::: choice
No tiene ning√∫n problema
:::

::: choice
Se repite mucho c√≥digo
:::

::: {.choice .correct-choice}
Falta usar break en cada caso
:::

:::
:::

::: question
¬øSe puede hacer esto con switch?

``` javascript

let x = 5

switch (true) {
  case (x < 0):
    console.log('x es negativo')
    break
  case (x > 0):
    console.log('x es positivo')
    break
  default:
    console.log('x es cero')
}
```

::: choices

::: choice
No, porque no se puede usar una expresi√≥n booleana en el switch
:::

::: choice
No, porque no se puede saber el valor de x dentro
:::

::: {.choice .correct-choice}
S√≠, no hay ning√∫n problema
:::

:::
:::

# Tu primera funci√≥n

Las *funciones* son uno de los conceptos m√°s importantes en *JavaScript* y casi cualquier lenguaje de programaci√≥n.

**Una funci√≥n es un bloque de c√≥digo que realiza una tarea espec√≠fica cuando se llama**. Puedes pensar en una funci√≥n como en un microondas: le das algo para cocinar, le pasas algunos par√°metros (como el tiempo y la potencia) y luego hace su trabajo y te devuelve el resultado.

En JavaScript, las funciones se pueden definir de varias maneras, pero la forma m√°s com√∫n y b√°sica es mediante la palabra clave **function**. Esta es tu primera funci√≥n:

``` javascript
function saludar() {
  console.log('Hola Diego')
}
```

Como ves, declarar una funci√≥n consiste de:

*   La palabra reservada **function** que indica que estamos definiendo una funci√≥n.

*   El nombre de la funci√≥n, en este caso **saludar**. Normalmente usamos verbos para nombrar funciones, ya que son acciones que realizan.

*   Un par de par√©ntesis **( )** despu√©s del nombre. Pueden contener par√°metros. En este caso, no tenemos ninguno.

*   Un bloque de c√≥digo entre llaves **{ }**. En este caso, solo tenemos una l√≠nea de c√≥digo, pero podr√≠amos tener muchas m√°s.

Nuestra funci√≥n ahora mismo no devuelve nada pero cada vez que la llamemos, imprimir√° **Hola** en la consola.

:::{.callout-tip}
Las funciones pueden devolver un resultado (un n√∫mero, una cadena de texto, un booleano...) o puede no devolver nada. En ese caso, la funci√≥n devuelve **undefined**.
:::

saludar() // -> Hola Diego
saludar() // -> Hola Diego
saludar() // -> Hola Diego

# Devolviendo un resultado

Las funciones pueden devolver un resultado. Para ello, utilizamos la palabra reservada **return** y despu√©s el valor que queremos devolver:

``` javascript
function sumar() {
  return 1 + 1
}
```

Ahora, cada vez que llamemos a la funci√≥n **sumar**, nos devolver√° el resultado de la suma:

``` javascript
// podemos guardar el resultado en una variable
const resultado = sumar()

// o ver en consola directamente el resultado
console.log(sumar()) // -> 2
```

:::{.callout-tip}
En la siguiente clase ver√°s c√≥mo puedes pasar par√°metros a una funci√≥n para hacerlas todav√≠a m√°s interesantes y reutilizables.
:::

:::{.callout-info}
Recuerda, si no utilizamos **return**, la funci√≥n devolver√° **undefined**.
:::

# Una funci√≥n realmente √∫til

La funci√≥n **saludar** y **sumar** no parecen muy √∫tiles, pero con lo poco que sabemos ya podemos hacer cosas m√°s productivas. Por ejemplo, podemos crear una funci√≥n que nos devuelva un n√∫mero aleatorio del 1 al 10.

Para ello vamos a descubrir **Math**, un objeto incorporado en JavaScript que tiene propiedades y m√©todos para constantes y funciones matem√°ticas. Vamos a ver dos m√©todos que nos van a ser muy √∫tiles:

*   **Math.random():** devuelve un n√∫mero aleatorio entre 0 y 1, con decimales.
*   **Math.floor():** redondea un n√∫mero hacia abajo.

:::{.callout-tip}
**Math.random** es parecido a **console.log**, en el sentido que son m√©todos que JavaScript incorpora de serie y que podemos utilizar en cualquier punto de nuestro programa.
:::

Sabiendo esto, podr√≠amos crear una **funci√≥n que nos devuelva un n√∫mero aleatorio del 1 al 10**:

``` javascript
function getRandomNumber() {
  // recuperamos un n√∫mero aleatorio entre 0 y 1
  const random = Math.random() // por ejemplo: 0.6803487380457318

  // lo multiplicamos por 10 para que est√© entre 0 y 10
  const multiplied = random * 10 // -> 6.803487380457318

  // redondeamos hacia abajo para que est√© entre 0 y 9
  const rounded = Math.floor(multiplied) // -> 6

  // le sumamos uno para que est√© entre 1 y 10
  const result = rounded + 1 // -> 7

  // devolvemos el resultado
  return result
}
```

¬°Bueno! Hay que ver cuantas cosas has puesto en pr√°ctica en muy pocas l√≠neas de c√≥digo: *constantes*, *variables*, *operadores*, comentarios... ¬°y todo en una funci√≥n!

¬øSabes lo mejor? Que **esa funci√≥n va a acompa√±arte durante toda tu carrera**. Es muy com√∫n necesitar crear un n√∫mero aleatorio en un programa, as√≠ que es muy √∫til tener una funci√≥n que lo haga por nosotros.

:::{.callout-info}
En la funci√≥n hemos utilizado varias variables para ir guardando los resultados intermedios. Podr√≠amos haberlo hecho todo en una sola l√≠nea, pero as√≠ es m√°s f√°cil de entender.
:::

# Quiz

::: question
¬øQu√© es una funci√≥n en JavaScript?

::: choices

::: choice
Algo que se puede hacer con JavaScript de base
:::

::: {.choice .correct-choice}
Un bloque de c√≥digo que realiza una tarea espec√≠fica cuando se llama
:::

::: choice
Una variable que almacena informaci√≥n
:::

:::
:::

::: question
¬øCu√°l es la sintaxis b√°sica de una funci√≥n en JavaScript?

::: choices

::: {.choice .correct-choice}
function nombreFuncion() { ... }
:::

::: choice
const function() { ... }
:::

::: choice
fn nombreFuncion() { ... }
:::

:::
:::

::: question
¬øQu√© devuelve una funci√≥n declarada con function si no tiene una declaraci√≥n de retorno expl√≠cita?

::: choices

::: choice
null
:::

::: {.correct-choice}
undefined
:::

::: choice
0
:::

:::
:::

# Par√°metros

Hasta ahora hemos visto como crear funciones y c√≥mo llamarlas. Pero para poder desbloquear todo el potencial de las funciones, **necesitamos que puedan recibir par√°metros**. Esto es, que su comportamiento pueda cambiar seg√∫n los datos que le pasemos.

Imagina que queremos que nuestra funci√≥n de **saludar**, pueda saludar a cualquier persona, no solo a Miguel. Para ello, podemos hacer que la funci√≥n acepte un par√°metro, que ser√° el nombre de la persona a la que queremos saludar.

``` javascript
function saludar(nombre) {
  console.log("Hola " + nombre)
}
```

Ahora, cada vez que llamemos a la funci√≥n, podemos pasarle una cadena de texto:

``` javascript
saludar('Diego') // -> Hola Diego
saludar('Itziar') // -> Hola Itziar
saludar('Carmen') // -> Hola Carmen
```
Ya ves como algo que parece tan sencillo, tiene un poder enorme. **Las funciones son la base de la programaci√≥n y nos permiten crear programas complejos a partir de peque√±as piezas**.

Por ejemplo, para crear una calculadora, deber√≠amos empezar a crear funciones que realicen las operaciones b√°sicas. En este caso necesitaremos parametrizar la funci√≥n para que acepte los dos n√∫meros para hacer la operaci√≥n.

``` javascript
function sumar(a, b) {
  return a + b
}

function restar(a, b) {
  return a - b
}
```
Y ya podr√≠amos usarlas:
``` javascript
const resultadoSuma = sumar(2, 3)
console.log(resultadoSuma) // -> 5

const resultadoResta = restar(5, 2)
console.log(resultadoResta) // -> 3
```

# Par√°metros y argumentos

En el ejemplo anterior, hemos visto que podemos pasarle valores a la funci√≥n cuando la llamamos. A estos valores se les llama **argumentos**. Y a los valores que recibe la funci√≥n, se les llama **par√°metros**.

``` javascript
// la funci√≥n suma tiene dos par√°metros: a y b
function sumar(a, b) {
  return a + b
}

// cuando llamamos a la funci√≥n, le pasamos dos argumentos: 2 y 3
const resultadoSuma = sumar(2, 3)
```
Normalmente mucha gente confunde los t√©rminos y usa par√°metro para referirse a los argumentos. Pero es importante que sepas diferenciarlos, porque son cosas distintas.

# El orden de los par√°metros importa

Algo muy importante, y un error muy com√∫n al empezar a crear funciones, es olvidar que el orden de los par√°metros importa.

Vamos a crear una funci√≥n que simule un microondas. Le pasaremos el plato, tiempo y potencia. Y nos devolver√° el resultado del plato cocinado.

``` javascript
function cocinarMicroondas(plato, tiempo, potencia) {
  if (plato === 'üê•' && tiempo === 1 && potencia === 5) {
    return 'üçó'
  }

  if (plato === 'ü•ö' && tiempo === 2 && potencia === 3) {
    return 'üç≥'
  }

  return '‚ùå Plato no soportado'
}
```
:::{.callout-tip}
S√≠, puedes hacer un **return** dentro de un condicional. Esto hace que la funci√≥n se detenga y devuelva el valor indicado en el **return**.
:::
Si usamos bien los par√°metros, la funci√≥n funciona correctamente:

``` javascript
const resultado = cocinarMicroondas('üê•', 1, 5)
console.log(resultado) // -> üçó
```
Pero si cambiamos el orden de los par√°metros, la funci√≥n no funciona:

``` javascript
const resultado = cocinarMicroondas(1, 5, 'üê•')
console.log(resultado) // -> '‚ùå Plato no soportado'
```
Esto es porque la funci√≥n espera que el primer par√°metro sea el plato, el segundo el tiempo y el tercero la potencia. **Si cambiamos el orden, podemos tener comportamientos inesperados o errores**.

M√°s adelante veremos una forma en la que podemos evitar este tipo de errores.

# Quiz

::: question
¬øQu√© son los par√°metros de una funci√≥n en JavaScript?

::: choices

::: {.correct-choice}
Valores que espera recibir una funci√≥n al llamarla para usarlos dentro de ella
:::

::: choice
Valores que devuelve una funci√≥n
:::

::: choice
Valores que se declaran dentro de una funci√≥n
:::

:::
:::

::: question

¬øQu√© son los argumentos de una funci√≥n en JavaScript?

::: choices

::: choice
Valores que espera recibir una funci√≥n
:::

::: {.correct-choice}
Valores que se pasan a una funci√≥n al llamarla
:::

::: choice
Lo mismo que los par√°metros
:::

:::
:::

::: question
¬øQu√© pasa si cambiamos el orden de los par√°metros al llamar una funci√≥n?
:::

::: choices

::: choice
La funci√≥n se detiene y no devuelve nada
:::

::: choice
La funci√≥n devuelve undefined
:::

::: {.correct-choice}
Podemos tener comportamientos inesperados o errores
:::

:::
:::

# Function Expression

Hasta ahora hemos visto c√≥mo podemos declarar funciones usando la palabra clave **function**.

Sin embargo, existen dos formas m√°s de declarar funciones en JavaScript: function expression y arrow function. En este caso, hablemos de la primera.

# ¬øQu√© es una function expression?

Una **function expression** es una funci√≥n que se asigna a una variable. Por ejemplo:

``` javascript// esto es una function expression
const sum = function (a, b) {
  return a + b
}

// esto es una declaraci√≥n de funci√≥n
function sum(a, b) {
  return a + b
}
```

:::{.callout-tip}
¬°F√≠jate que la **function** no tiene nombre en la **function expression**! Cuando una funci√≥n no tiene nombre se le llama funci√≥n an√≥nima. Aunque en este caso, la funci√≥n est√° asignada a una variable que s√≠ tiene nombre y por eso podremos utilizarla m√°s adelante.
:::

Con la function expression, a la funci√≥n se asigna a la variable **sum**. Esto significa que podemos llamar a la funci√≥n usando el nombre de la variable:

``` javascript
sum(1, 2) // 3
```

El comportamiento es muy similar al de una funci√≥n declarada con la palabra clave **function**. Sin embargo, hay una diferencia muy importante entre ambas que debes conocer: el hoisting.

# Hoisting

El hoisting es un t√©rmino que se usa para describir c√≥mo JavaScript parece que mueve las declaraciones funciones al principio del c√≥digo, de forma que las puedes usar incluso antes de declararlas. Por ejemplo:

``` javascript
sum(1, 2) // 3

function sum(a, b) {
  return a + b
}
```
Aqu√≠ primero usamos la funci√≥n y la declaramos luego. ¬°Y funciona! ¬øC√≥mo puede ser? **¬øNo deber√≠a darnos un error ya que la funci√≥n todav√≠a no existe?**

Lo que est√° pasando es que JavaScript asigna en memoria durante la fase de compilaci√≥n las declaraciones de funciones y por eso al ejecutarse el c√≥digo tiene acceso a esa posici√≥n de memoria a la que se refiere la funci√≥n.

Eso ser√≠a la explicaci√≥n t√©cnica del hoisting, pero si te sirve de ayuda, puedes pensar que es como si JavaScript moviese las declaraciones de funciones al principio del c√≥digo.

# ¬øY qu√© pasa con las function expression?

Pues que no se aplica el hoisting. Por ejemplo:

``` javascript
sum(1, 2) // ‚ùå ReferenceError: sum is not defined

const sum = function (a, b) {
  return a + b
}
```

# Quiz

::: question
¬øQu√© es una function expression en JavaScript?

::: choices

::: choice
Una funci√≥n que se define dentro de otra funci√≥n
:::

::: choice
Una funci√≥n que se declara con la palabra clave "function"
:::

::: {.correct-choice}
Una funci√≥n que se asigna a una variable
:::

:::
:::

::: question
¬øQu√© diferencia hay entre una declaraci√≥n de funci√≥n y una funci√≥n de expresi√≥n en JavaScript?

::: choices

::: choice
S√≥lo la forma en que se declaran
:::

::: {.choice .correct-choice}
El hoisting y c√≥mo se crean
:::

::: choice
El comportamiento al llamarlas
:::

:::
:::

::: question
¬øSe aplica el hoisting a las funciones de expresi√≥n en JavaScript?

::: choices

::: choice
S√≠
:::

::: {.choice .correct-choice}
No
:::

:::
:::

# Funciones flecha

En esta clase vamos a hablar sobre las *funciones flecha*, tambi√©n conocidas como **arrow functions** en ingl√©s.

Las funciones flecha son una forma m√°s concisa de crear funciones en *JavaScript*, y se han vuelto muy populares en los √∫ltimos a√±os debido a su sintaxis simplificada.

La sintaxis b√°sica de una funci√≥n flecha es la siguiente:

``` javascript
const miFuncionFlecha = () => {
  // c√≥digo a ejecutar
}
```

:::{.callout-tip}
Las funciones flecha son siempre **funciones an√≥nimas** y **function expressions**. Esto significa que no tienen nombre y que se asignan a una variable.
:::

En lugar de la palabra clave **function**, utilizamos una flecha **=>** para definir la funci√≥n. Tambi√©n podemos omitir los par√©ntesis alrededor de los par√°metros si solo tenemos uno:

``` javascript
const saludar = nombre => {
  console.log("Hola " + nombre)
}
```

# Ventajas de las funciones flecha

Las funciones flecha tienen varias **ventajas sobre las funciones regulares en JavaScript**. Algunas son:

*   **Sintaxis m√°s concisa:** la sintaxis de las funciones flecha es m√°s corta y m√°s f√°cil de leer que la sintaxis de las funciones regulares, especialmente cuando se trabaja con funciones de una sola l√≠nea.

*   **Return impl√≠cito:** las funciones flecha puede devolver el valor de la expresi√≥n sin usar la palabra clave **return** cuando son de una sola l√≠nea. Esto hace que las funciones flecha sean a√∫n m√°s cortas y m√°s f√°ciles de leer.

*   **Funciones an√≥nimas m√°s legibles:** las funciones flecha son una forma m√°s legible y concisa de crear funciones an√≥nimas en JavaScript, lo cual puede hacer que nuestro c√≥digo sea m√°s f√°cil de entender.

:::{.callout-tip}
Recuerda, las funciones an√≥nimas son funciones que no tienen nombre. Son como las que vimos en la clase anterior.
:::

# Return impl√≠cito

Cuando una funci√≥n flecha tiene una sola expresi√≥n, podemos omitir las llaves **{ }** y la palabra clave return para hacerla a√∫n m√°s corta. Esto se conoce como **return impl√≠cito**. Vamos a pasar una funci√≥n regular a una funci√≥n flecha y vamos a ver c√≥mo se ve finalmente con return impl√≠cito:

``` javascript
// Declaraci√≥n de funci√≥n regular
function sumar(a, b) {
  return a + b
}

// Funci√≥n flecha
const sumarFlecha = (a, b) => {
  return a + b
}

// Funci√≥n flecha con return impl√≠cito
const sumarFlecha = (a, b) => a + b
```
Como podemos ver, la funci√≥n flecha con return impl√≠cito es mucho m√°s corta y f√°cil de leer que la funci√≥n regular. Esto es especialmente √∫til cuando estamos trabajando con funciones de una sola l√≠nea.

# Quiz

::: question
¬øQu√© son las funciones flecha en JavaScript?

::: choices

::: {.correct-choice}
Una forma m√°s concisa de crear funciones en JavaScript
:::

::: choice
Una forma m√°s compleja de crear funciones en JavaScript
:::

::: choice
Una t√©cnica para evitar el uso de funciones en JavaScript
:::

:::
:::

::: question
¬øCu√°l es una de las ventajas de las funciones flecha?

::: choices

::: {.choice .correct-choice}
Return impl√≠cito
:::

::: choice
Son m√°s r√°pidas
:::

::: choice
Funciones an√≥nimas
:::

:::
:::

::: question
¬øQu√© devuelve la siguiente funci√≥n flecha?

``` javascript
const sum = (a, b) => { a + b }
sum(2, 3)
```

::: choices

::: choice
5
:::

::: {.choice .correct-choice}
undefined
:::

::: choice
Error
:::

:::
:::

# Recursividad

La recursividad es una t√©cnica de programaci√≥n que consiste en que una funci√≥n se llame a s√≠ misma.

Pero claro, si una funci√≥n se llama a s√≠ misma, ¬øcu√°ndo termina? ¬øc√≥mo se evita que se llame infinitamente? Con una condici√≥n base.

# Ejemplo de recursividad

Vamos a crear una funci√≥n que cuente desde un n√∫mero hasta cero.

``` javascript
function cuentaAtras(numero) {
  // Condici√≥n base: Si el n√∫mero que recibe es
  // menor de 0 entonces salimos de la funci√≥n
  if (numero < 0) { return }

  // Si el n√∫mero era mayor o igual a 0, lo mostramos
  console.log(numero)

  // Y llamamos a la funci√≥n con el n√∫mero anterior
  cuentaAtras(numero - 1)
}
```

Si llamamos a la funci√≥n con el n√∫mero 3, el resultado ser√°:

``` javascript
cuentaAtras(3)
// -> 3
// -> 2
// -> 1
// -> 0
```

La ejecuci√≥n la ver√≠amos as√≠:

```javascript
cuentaAtras(3) -> (muestra 3)
               \ 
          cuentaAtras(2) -> (muestra 2)
                       \
                  cuentaAtras(1) -> (muestra 1)
                               \
                          cuentaAtras(0) -> (muestra 0)
                                        \
                                   cuentaAtras(-1) -> salida
```

:::{.callout-info}
¬°Cuidado! Si no ponemos la condici√≥n base, la funci√≥n se llamar√° infinitamente y el navegador se quedar√° bloqueado. Cuando hacemos recursividad SIEMPRE hay que tener una condici√≥n que haga que la funci√≥n salga de s√≠ misma.
:::

# Usando recursividad y devolviendo un valor

La recursividad se usa muchas veces para solucionar algoritmos. Por ejemplo, vamos a crear una funci√≥n que calcule el factorial de un n√∫mero.

:::{.callout-tip}
El factorial de un n√∫mero es el resultado de multiplicar ese n√∫mero por todos los anteriores hasta llegar a 1. Por ejemplo, el factorial de 5 es 5 * 4 * 3 * 2 * 1 = 120
:::

``` javascriptfunction factorial(n) {
  // Condici√≥n base: Si el n√∫mero es 0 o 1, devolvemos 1
  // y no llamamos a la funci√≥n de nuevo
  if (n === 0 || n === 1) {
    return 1
  } else {
    // Si el n√∫mero es mayor que 1, llamamos a la funci√≥n
    return n * factorial(n - 1)
  }
}

console.log(factorial(5)) // Resultado: 120
console.log(factorial(3)) // Resultado: 6
```

```javascript
factorial(3) --------------------------> 6
        \ 
  3 * factorial(2) ---------------> 6
          \
    2 * factorial(1) -----------> 2
            \
      1 * factorial(0) -------> 1
```

La recursividad es un concepto que cuesta entender al principio. ¬øUna funci√≥n que se llama a s√≠ misma? A mucha gente le vuela la cabeza.

¬øQu√© te recomiendo para aprenderlo? Primero, entiende los ejemplos que hemos hecho y dibuja en un papel c√≥mo se ejecutan las funciones.

Despu√©s, haz estos ejercicios de recursividad:

Escribe una funci√≥n que calcule la suma de los primeros n n√∫meros enteros de forma recursiva. Por ejemplo: **suma(3) -> 1 + 2 + 3 = 6**

Escribe una funci√≥n que calcule la sucesi√≥n de Fibonacci de forma recursiva. La sucesi√≥n de Fibonacci es una serie de n√∫meros que empieza por 0 y 1 y cada n√∫mero es la suma de los dos anteriores. Por ejemplo: **fibonacci(6) -> 8 (0, 1, 1, 2, 3, 5, 8)**


# Quiz

::: question
¬øQu√© es la recursividad en programaci√≥n?

::: choices

::: {.choice .correct-choice}
Una t√©cnica de programaci√≥n que consiste en que una funci√≥n se llame a s√≠ misma
:::

::: choice
Un tipo de condici√≥n que permite evitar que una funci√≥n se llame infinitamente
:::

::: choice
Un error que ocurre cuando una funci√≥n se llama a s√≠ misma
:::

:::
:::

::: question
¬øQu√© es la condici√≥n base en la recursividad?

::: choices

::: {.choice .correct-choice}
Una condici√≥n que permite evitar que una funci√≥n se llame infinitamente
:::

::: choice
Una condici√≥n que permite que una funci√≥n se llame infinitamente
:::

::: choice
Una condici√≥n que permite que una funci√≥n se llame infinitamente
:::

:::
:::

::: question
¬øQu√© sucede si no se define una condici√≥n base en una funci√≥n recursiva?

::: choices

::: {.choice .correct-choice}
La funci√≥n se puede llamar infinitamente y el programa se bloquea
:::

::: choice
La funci√≥n deja de llamarse despu√©s de un cierto n√∫mero de iteraciones
:::

::: choice
La funci√≥n devuelve un valor incorrecto
:::

:::
:::

::: question
¬øCu√°l es la salida de este c√≥digo al pasar como argumento el n√∫mero 3?

``` javascript
function recursive(n) {
  if (n === 0) {
    return 0
  } else {
    return n + recursive(n - 1)
  }
}
```

::: choices

::: choice
0
:::

::: {.choice .correct-choice}
6
:::

::: choice
4
:::

:::
:::

# Arrays: colecciones de elementos

Hasta ahora hemos visto algunos tipos de datos. Cadenas de texto, n√∫meros, booleanos... Pero... **¬øQu√© pasa si queremos tener una colecci√≥n de ellos?** En *JavaScript* tenemos los **arrays**.

# Declaraci√≥n y asignaci√≥n de arrays

Para declarar un array usamos los corchetes **[ ]** y dentro los elementos de la colecci√≥n separados por comas **,**.

Por ejemplo, para crear una colecci√≥n de n√∫meros del 1 al 5:

``` javascript
[1, 2, 3, 4, 5]
```

Los elementos de un array pueden ser de cualquier tipo, incluso otros arrays.

``` javascript
[1, 2, 3, 4, [5, 6, 7, 8, 9]]
```
Y, aunque no siempre sea recomendable, puedes mezclar tipos de datos dentro:

``` javascript
['uno', 2, true, null, undefined]
```
Para asignar un array a una variable, lo hacemos igual que con los otros tipos de datos:

``` javascript
const numbers = [1, 2, 3, 4, 5]
let names = ['Dani', 'Miguel', 'Maria']
```

# Acceso a los elementos de un array

Para acceder a los elementos de un array usamos los corchetes **[ ]** y dentro el √≠ndice del elemento que queremos acceder. **Los √≠ndices empiezan en 0**.

``` javascript
const numbers = [1, 2, 3, 4, 5]

console.log(numbers[0]) // 1
console.log(numbers[2]) // 3
```

:::{.callout-tip}
El √≠ndice es la posici√≥n del elemento dentro del array. El primer elemento tiene √≠ndice 0, el segundo √≠ndice 1, el tercero √≠ndice 2...
:::

Si intentamos acceder a un elemento que no existe, nos devolver√° **undefined**.

``` javascript
const numbers = [1, 2, 3, 4, 5]

console.log(numbers[10]) // undefined
```

Puedes usar variables para acceder a los elementos de un array.

``` javascript
const numbers = [1, 2, 3, 4, 5]
let index = 2

console.log(numbers[index]) // 3
```
# Modificar elementos de un array

Igual que podemos acceder a los elementos de un array, podemos modificarlos.

``` javascript
const numbers = [1, 2, 3, 4, 5]

numbers[0] = 10
numbers[2] = 30

console.log(numbers) // [10, 2, 30, 4, 5]
```

:::{.callout-tip}
¬øC√≥mo es que pese a que hemos indicado que es una constante **const** podemos modificar el Array? Aunque hay una explicaci√≥n mucho m√°s larga, que veremos m√°s adelante, la respuesta corta es que **const** s√≥lo impide que se reasigne el valor de la variable, no que se modifique el valor en s√≠.
:::

# Quiz

::: question
¬øQu√© se imprimir√° en la consola al ejecutar el siguiente c√≥digo:

``` javascript
const numbers = [1, 2, 3, 4, 5]
numbers[0] = 10
numbers[2] = 30
console.log(numbers)
```

::: choices

::: choice
[1, 2, 3, 4, 5]
:::

::: {.choice .correct-choice}
[10, 2, 30, 4, 5]
:::

::: choice
Error de asignaci√≥n a una constante
:::

:::
:::

# M√©todos y propiedades de Array

Los arrays de JavaScript tienen una serie de m√©todos y propiedades que nos permiten trabajar con ellos de forma sencilla.

:::{.callout-tip}
Un m√©todo es una funci√≥n que se ejecuta sobre un objeto. Una propiedad es una variable que pertenece a un objeto. En este caso, el objeto es un array.
:::

# La longitud de un array

Puedes conocer la longitud de una colecci√≥n de elementos usando la propiedad **.length**:

``` javascript
const frutas = ["manzana", "pera", "pl√°tano", "fresa"]
console.log(frutas.length) // 4
```

Tambi√©n puedes cortar su longitud asignando un nuevo valor a la propiedad **.length**:

``` javascript
const frutas = ["manzana", "pera", "pl√°tano", "fresa"]
frutas.length = 2

console.log(frutas) // ["manzana", "pera"]
console.log(frutas.length) // 2
```

# M√©todos de arrays

Cuando trabajamos con colecciones de elementos, vamos a querer hacer cosas con ellos. Por ejemplo: a√±adir un elemento, eliminarlo, buscarlo, etc. Para ello, los arrays tienen una serie de m√©todos que nos permiten hacer estas operaciones:

# .push()

El m√©todo **.push()** nos permite a√±adir un elemento al final de un array:

``` javascript
const frutas = ["pl√°tano", "fresa"]
frutas.push("naranja")
console.log(frutas) // ["pl√°tano", "fresa", "naranja"]
```

Adem√°s, el m√©todo **.push()** devuelve la nueva longitud del array:

``` javascript
const frutas = ["pl√°tano", "fresa"]
console.log(frutas.length) // 2

const newLength = frutas.push("naranja")
console.log(newLength) // 3
console.log(frutas) // ["pl√°tano", "fresa", "naranja"]
```

# .pop()

El m√©todo **.pop()** elimina y devuelve el √∫ltimo elemento de un array:

``` javascript
const frutas = ["pl√°tano", "fresa", "naranja"]
const ultimaFruta = frutas.pop()

console.log(frutas) // ["pl√°tano", "fresa"]
console.log(ultimaFruta) // "naranja"
```

# .shift()

El m√©todo **.shift()** elimina y devuelve el primer elemento de un array. Es lo mismo que .pop(), pero con el primer elemento en lugar del √∫ltimo:

``` javascript
const frutas = ["pl√°tano", "fresa", "naranja"]
const primeraFruta = frutas.shift()

console.log(frutas) // ["fresa", "naranja"]
console.log(primeraFruta) // "pl√°tano"
```

# .unshift()

El m√©todo **.unshift()** a√±ade un elemento al principio de un array. Es lo mismo que **.push()**, pero con el primer elemento en lugar del √∫ltimo:

``` javascript
const frutas = ["pl√°tano", "fresa", "naranja"]
frutas.unshift("manzana")

console.log(frutas) // ["manzana", "pl√°tano", "fresa", "naranja"]
```

# Concatenar arrays

Podemos concatenar dos arrays usando el m√©todo **concat()**.

``` javascript
const numbers = [1, 2, 3]
const numbers2 = [4, 5]

const allNumbers = numbers.concat(numbers2)

console.log(allNumbers) // [1, 2, 3, 4, 5]
```

Otra forma de concatenar arrays es usando el operador **...** (spread operator). Este operador propaga los elementos de un array. As√≠ que podr√≠amos hacer lo siguiente:

``` javascript
const numbers = [1, 2, 3]
const numbers2 = [4, 5]

//                    1, 2, 3        4, 5                     
const allNumbers = [...numbers, ...numbers2]

console.log(allNumbers) // [1, 2, 3, 4, 5]
```

M√°s adelante hablaremos m√°s de este operador y sus diferentes utilidades.

# Ejercicio pr√°ctico

En un restaurante se reciben pedidos de comida a domicilio. Vamos a escribir una funci√≥n **procesarPedido** que recibe un pedido, que es un array de platos. Lo que debemos hacer es:

*   El primer elemento lo sacamos del array, ya que es el nombre del cliente.
*   A√±adimos al principio del array la cadena de texto "bebida", ya que es una promoci√≥n que tenemos.
*  Despu√©s a√±adimos al final del array el nombre del usuario que sacamos antes.

Recuerda que debes devolver el array modificado:

``` javascript
function procesarPedido(pedidos) {
  // tu c√≥digo aqu√≠
}
```

<details>
<summary>Ver soluci√≥n</summary>

``` javascript
function procesarPedido(pedidos) {
  const nombreCliente = pedidos.shift()
  pedidos.unshift("bebida")
  pedidos.push(nombreCliente)

  return pedidos
}
```

</details>

# Iteraci√≥n de Arrays en JavaScript

Ya hemos visto en clases anteriores c√≥mo podemos crear bucles con **for** y **while**. Con estas estructuras de control, y una nueva que veremos en este clase, podemos tambi√©n recorrer cada uno de los elementos de un array.

Adem√°s, veremos como los propios arrays tienen un m√©todo **.forEach** que nos permite ejecutar una funci√≥n para cada uno de los elementos del array.

# Bucle while

El bucle **while** vimos que permit√≠a ejecutar un bloque de c√≥digo mientras una condici√≥n era verdadera. En el caso de la iteraci√≥n de arrays, la condici√≥n generalmente se basa en el √≠ndice del elemento.

Podemos, por ejemplo, crear una variable con **let** para guardar un puntero al √≠ndice del elemento que estamos iterando. En cada iteraci√≥n, podemos incrementar el valor de la variable en 1, para que en la siguiente iteraci√≥n se imprima el siguiente elemento.

``` javascript
let frutas = ['üçé', 'üçå', 'üçì']
let i = 0 // lo usaremos como √≠ndice

while (i < frutas.length) {
  console.log(frutas[i]) // imprime el elemento en la posici√≥n i
  i++ // incrementamos el √≠ndice en 1 para la siguiente iteraci√≥n
}
```

# Bucle for

El bucle **for** nos permit√≠a ejecutar un bloque de c√≥digo un n√∫mero determinado de veces. En el caso de la iteraci√≥n de arrays, podemos usarlo para recorrer cada uno de los elementos del array, usando la longitud del array como condici√≥n.

``` javascript
let frutas = ['üçé', 'üçå', 'üçì']

for (let i = 0; i < frutas.length; i++) {
  console.log(frutas[i]) // imprime el elemento en la posici√≥n i
}
```
Tambi√©n podr√≠as recorrer el array en orden inverso, empezando desde el √∫ltimo elemento hasta el primero, usando **i--** en lugar de **i++**.

``` javascript
let frutas = ['üçé', 'üçå', 'üçì']

for (let i = frutas.length - 1; i >= 0; i--) {
  console.log(frutas[i]) // imprime el elemento en la posici√≥n i
}
```

# Bucle for...of

Adem√°s de **while** y **for**, existe otra estructura de control que nos permite iterar sobre los elementos de un array: **for...of**. Esta estructura de control es m√°s simple que **for**, ya que no necesitamos crear una variable para guardar el √≠ndice del elemento que estamos iterando.

Es mucho m√°s sencilla y f√°cil de entender:

``` javascript
let frutas = ['üçé', 'üçå', 'üçì']

for (let fruta of frutas) {
  console.log(fruta) // imprime el elemento en la posici√≥n i
}
```

:::{.callout-tip}
Como ves, hay algunas limitaciones en el uso de **for...of**. Por ejemplo, no podemos usarlo para recorrer un array en orden inverso y tampoco tenemos acceso al √≠ndice del elemento que estamos iterando.
:::

# El m√©todo array.forEach()

Ya hemos visto en la clase anterior que los arrays tienen m√©todos que nos permiten realizar operaciones sobre ellos, como a√±adir elementos o eliminarlos. Pero tiene muchos m√°s m√©todos que iremos viendo que nos ayuda a trabajar con ellos.

Uno de esos m√©todos es **array.forEach()**, que nos permite ejecutar una **function** para cada uno de los elementos del array. Esta funci√≥n recibe como par√°metros el elemento que se est√° iterando en ese momento, el √≠ndice del elemento y el propio array.

``` javascript
let frutas = ['üçé', 'üçå', 'üçì']

frutas.forEach(function (fruta, index, originalArray) {
  console.log(fruta) // imprime el elemento en la posici√≥n i
})
```

Usando una **arrow function** e indicando s√≥lo los par√°metros que necesitamos de nuestra funci√≥n podemos simplificarlo a√∫n m√°s:

``` javascript
let frutas = ['üçé', 'üçå', 'üçì']

frutas.forEach((fruta) => {
  console.log(fruta) // imprime el elemento en la posici√≥n i
})
```

:::{.callout-tip}
Algo importante es que **array.forEach()** no devuelve nada, por lo que no podemos asignar el resultado a una variable.
:::

**¬øCu√°l usar? Depende...**

::: table
| **M√©todo** | **Acceso al √çndice** | **Acceso al Valor** | **Puede Usar Break** | **Control Manual del √çndice** |
|------------|----------------------|---------------------|----------------------|--------------------------------|
| **for**    | ‚úÖ                   | ‚úÖ                  | ‚úÖ                   | ‚úÖ                             |
| **while**  | ‚úÖ                   | ‚úÖ                  | ‚úÖ                   | ‚úÖ                             |
| **for...of**| ‚ùå                  | ‚úÖ                  | ‚úÖ                    | ‚ùå                             |
| **forEach**| ‚úÖ                   | ‚úÖ                  | ‚ùå                   | ‚ùå                             |
:::

:::{.callout-tip}
Aunque t√©cnicamente no puedes utilizar la sentencia **break** para salir de forEach, puedes simular esto lanzando una excepci√≥n y captur√°ndola en un bloque **try/catch** externo. Obviamente es una mala pr√°ctica que no te recomiendo.
:::

Cada uno de estos m√©todos tiene sus propios casos de uso. **for** y **while** son m√°s generales y te permiten controlar el √≠ndice manualmente, lo que es √∫til si necesitas saltar a √≠ndices espec√≠ficos, cambiar el orden de iteraci√≥n o salir del bucle antes de que se complete.

**for...of** es m√°s f√°cil de usar cuando solo necesitas los valores de un array y no te importa el √≠ndice. Es especialmente √∫til tambi√©n cuando est√°s trabajando con iterables que no son arrays, como las cadenas de caracteres o los conjuntos (sets).

Finalmente, **forEach** es una forma muy eficiente y legible de iterar sobre un array si no necesitas **break** y si no necesitas controlar manualmente el √≠ndice.

# Ejercicio pr√°ctico

Dada una lista de n√∫meros, escribe una funci√≥n en JavaScript que devuelva la suma de todos los n√∫meros pares en la lista. La funci√≥n deber√° iterar sobre cada n√∫mero en la lista, comprobar si el n√∫mero es par y, si es as√≠, a√±adirlo a la suma total. Usa el bucle que quieras para solucionarlo.

``` javascript
function sumarPares(numeros) {
  let suma = 0
  // tu c√≥digo aqu√≠
  return suma
}
```

<details>
<summary>Ver soluci√≥n</summary>

``` javascript
function sumarPares(numeros) {
  let suma = 0

  for (let numero of numeros) {
    if (numero % 2 === 0) {
      suma += numero
    }
  }

  return suma
}
```
</details>

# B√∫squeda en Arrays con sus m√©todos

Existen varios m√©todos en **JavaScript** que te permiten, espec√≠ficamente, buscar dentro de un Array. Estos m√©todos incluyen **indexOf**, **some**, **every**, **find**, **findIndex** e **includes**.

Cada uno de estos m√©todos tiene un prop√≥sito espec√≠fico y una funcionalidad √∫nica. Vamos a explorar cada uno de ellos utilizando un Array de emojis como ejemplo.

``` javascript
const emojis = ['‚ú®', 'ü•ë', 'üòç']
```

# indexOf: ¬øEn qu√© posici√≥n est√° el elemento?

El m√©todo **indexOf** te permite encontrar la posici√≥n de un elemento dentro de un **Array**. Si el elemento no existe, entonces retorna **-1**.

``` javascript
const emojis = ['‚ú®', 'ü•ë', 'üòç']

const posicionCorazon = emojis.indexOf('üòç')

console.log(posicionCorazon) // -> 2
```

# includes: ¬øEl elemento existe en el Array?

El m√©todo includes determina si un Array incluye un determinado elemento, devolviendo **true** o **false** seg√∫n corresponda.

``` javascript
const emojis = ['‚ú®', 'ü•ë', 'üòç']

const tieneCorazon = emojis.includes('üòç')

console.log(tieneCorazon) // -> true
```
Es la forma m√°s sencilla y corta de buscar un elemento espec√≠fico dentro de un **Array**. Sin embargo, si queremos revisar si un **Array** contiene un elemento que cumpla con una condici√≥n, entonces tenemos que utilizar otros m√©todos...

:::{.callout-tip}
El m√©todo **.includes()** tambi√©n funciona con las cadenas de texto. Puedes utilizarlo para buscar una subcadena dentro de una cadena de texto: **'Hola mundo'.includes('Hola') // -> true**
:::
# some: ¬øAlguno de los elementos cumple con la condici√≥n?

El m√©todo **some** te permite verificar si al menos uno de los elementos de un **Array** cumple con una condici√≥n.

Para utilizarlo, le pasas una funci√≥n como argumento. Esta funci√≥n recibe como argumento cada uno de los elementos del **Array** y debe retornar un valor **booleano**.

Si al menos uno de los elementos retorna **true**, entonces el m√©todo **some** retorna **true**. Si ninguno de los elementos retorna **true**, entonces el m√©todo **some** retorna **false**.

``` javascript
const emojis = ['‚ú®', 'ü•ë', 'üòç']

const tieneCorazon = emojis.some(emoji => emoji === 'üòç')
console.log(tieneCorazon) // -> true
```

¬°Pero si esto ya lo pod√≠amos hacer con **includes**! S√≠, pero **some** es mucho m√°s potente...

Podemos crear funciones m√°s complejas para pasarle al m√©todo **some**. Por ejemplo, podemos crear una funci√≥n que verifique si un **Array** contiene un elemento que sea un **string** de m√°s de 3 caracteres.

``` javascript
const names = ['Leo', 'Isa', '√çan', 'Lea']

const tieneNombreLargo = names.some(name => name.length > 3)
console.log(tieneNombreLargo) // -> false
```

Algo importante a tener en cuenta es que el m√©todo **some** deja de iterar sobre el **Array** en cuanto encuentra un elemento que cumple con la condici√≥n. Por ejemplo, si tenemos un **Array** de 10 elementos y el elemento n√∫mero 3 cumple con la condici√≥n, el m√©todo **some** no va a iterar sobre los 7 elementos restantes:

``` javascript
const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

const tieneNumeroMayorA5 = numbers.some(number => {
  console.log(`Estoy iterando sobre el n√∫mero ${number}`) // -> Imprime hasta el n√∫mero 6
  return number > 5
})

console.log(tieneNumeroMayorA5) // -> true
```

# every: ¬øTodos los elementos cumplen con la condici√≥n?

El m√©todo **every** te permite verificar si todos los elementos de un **Array** cumplen con una condici√≥n. Es similar a **some**, pero en lugar de verificar si al menos uno de los elementos cumple con la condici√≥n, los verifica todos.

Para utilizarlo, le pasas una funci√≥n como argumento. Esta funci√≥n recibe como argumento el elemento del array que est√° iterando en ese momento y debe retornar un valor **booleano** para saber si el elemento cumple con la condici√≥n.

Si todos los elementos retornan **true**, entonces el m√©todo **every** retorna true. Si al menos uno de los elementos retorna **false**, entonces el m√©todo **every** retorna **false**.

``` javascript
// ¬øTodos los emojis son felices?
const emojis = ['üòÄ', 'üòÇ', 'üòç', 'üò≠', 'ü•∫', 'üòé']
const todosSonFelices = emojis.every(emoji => emoji === 'üòÄ')
console.log(todosSonFelices) // -> false

// ¬øTodos los n√∫meros son pares?
const numbers = [2, 4, 7, 10, 12]
const todosSonPares = numbers.every(number => number % 2 === 0)
console.log(todosSonPares) // -> false

// ¬øTodos los strings son mayores a 3 caracteres?
const names = ['Miguel', 'Juan', 'Itziar', 'Isabel']
const todosLosNombresSonLargos = names.every(name => name.length > 3)
console.log(todosLosNombresSonLargos) // -> true
```
Al igual que **some**, el m√©todo **every** deja de iterar sobre el **Array** en cuanto encuentra un elemento que no cumple con la condici√≥n.

# find: Devuelve el primer elemento que cumple con la condici√≥n

El m√©todo **find** te permite encontrar el primer elemento que cumple con una condici√≥n. Lo interesante es que este m√©todo te devuelve el elemento en s√≠, no un valor **booleano** como **some** y **every**. Aunque el funcionamiento es igual: hay que pasarle una funci√≥n como argumento que retorne un valor **booleano**.

``` javascriptconst numbers = [13, 27, 44, -10, 81]
// encuentra el primer n√∫mero negativo
const firstNegativeNumber = numbers.find(number => number < 0)

console.log(firstNegativeNumber) // -> -10
```

Si no encuentra ning√∫n elemento que cumpla con la condici√≥n, el m√©todo **find** retorna **undefined**.

``` javascript
const numbers = [13, 27, 44, 81]
// encuentra el primer n√∫mero negativo
const firstNegativeNumber = numbers.find(number => number < 0)

console.log(firstNegativeNumber) // -> undefined
```
De nuevo, igual que **some** y **every**, el m√©todo **find** deja de iterar sobre el **Array** en cuanto encuentra un elemento que cumple con la condici√≥n.

# findIndex: Devuelve el √≠ndice del primer elemento que cumple con la condici√≥n

El m√©todo **findIndex** es similar a **find**, pero en lugar de devolver el elemento que cumple con la condici√≥n, devuelve el √≠ndice de ese elemento.

``` javascript
const numbers = [13, 27, 44, -10, 81]

// encuentra el √≠ndice del primer n√∫mero negativo
const firstNegativeNumberIndex = numbers.findIndex(number => number < 0)

console.log(firstNegativeNumberIndex) // -> 3

// ahora puedes usar el √≠ndice para acceder al elemento
console.log(numbers[firstNegativeNumberIndex]) // -> -10
```
Si no encuentra ning√∫n elemento que cumpla con la condici√≥n, el m√©todo **findIndex** retorna **-1**.

``` javascript
const numbers = [13, 27, 44, 81]

// encuentra el √≠ndice del primer n√∫mero negativo
const firstNegativeNumberIndex = numbers.findIndex(number => number < 0)

console.log(firstNegativeNumberIndex) // -> -1
```
# Actividad Pr√°ctica

Crear una funci√≥n que reciba un array de palabras y devuelva **true** si todas las palabras terminan con la letra "a" y **false** si al menos una palabra no termina con la letra "a".

Usa el [m√©todo endsWith() de string](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith) para resolverlo.

``` javascript
function acabanEnA(words) {
  // tu c√≥digo aqu√≠
}
```

<details>
<summary>Ver soluci√≥n</summary>

``` javascript
function acabanEnA(words) {
  return words.every(word => word.endsWith('a'))
}
```

</details>

# Ordenamiento de Arrays en JavaScript

*JavaScript* proporciona un m√©todo incorporado en arrays llamado **.sort()** para ordenar sus elementos. Por defecto no es muy √∫til pero puedes personalizar su comportamiento para que ordene los elementos de la manera que necesites.

# Ordenamiento b√°sico con sort()

Por defecto, **.sort()** hace una ordenaci√≥n un poco extra√±a:

``` javascript
let numeros = [5, 10, 2, 25, 7]
numeros.sort()
console.log(numeros) // [10, 2, 25, 5, 7]
```

¬øQu√© ha pasado? **Este comportamiento puede resultar confuso cuando se trabaja con n√∫meros**, ya que **.sort()** ordenar√° los n√∫meros en funci√≥n de su valor como cadena de texto, no de su valor num√©rico.

Por suerte, podemos arreglarlo...

# Ordenamiento personalizado con sort()

Para personalizar c√≥mo **sort()** ordena los elementos, puedes pasar una funci√≥n de comparaci√≥n como argumento. La funci√≥n de comparaci√≥n debe devolver:

*    Un **valor negativo** si el primer argumento debe aparecer antes que el segundo.
*    Un **valor positivo** si el segundo argumento debe aparecer antes que el primero.
*    **Cero** si ambos argumentos son iguales.

Por ejemplo, **para ordenar los n√∫meros de menor a mayor**, puedes usar la siguiente funci√≥n de comparaci√≥n:

``` javascript
let numeros = [5, 10, 2, 25, 7]

numeros.sort(function(a, b) {
  return a - b
})

console.log(numeros) // [2, 5, 7, 10, 25]
```

**Para ordenarlos de manera descendente**, de mayor a menor, deber√≠as cambiar el orden del **return**:

``` javascript
let numeros = [5, 10, 2, 25, 7]

numeros.sort(function(a, b) {
  return b - a
})

console.log(numeros) // [25, 10, 7, 5, 2]
```
Puedes usar una **arrow function** para simplificar el c√≥digo:

``` javascript
let numeros = [5, 10, 2, 25, 7]

numeros.sort((a, b) => a - b)
```

# sort() y toSorted()

Como ves, **.sort()** modifica el array original. Si quieres obtener un array ordenado sin modificar el original, puedes usar el m√©todo **.toSorted()**. S√≥lo ten en cuenta que, ahora mismo, su soporte en navegadores es limitado.

``` javascript
let numeros = [5, 10, 2, 25, 7]

let numerosOrdenados = numeros.toSorted((a, b) => {
  return a - b
})

console.log(numerosOrdenados) // [2, 5, 7, 10, 25]
console.log(numeros) // [5, 10, 2, 25, 7]
```
Tambi√©n podr√≠as usar el operador de propagaci√≥n **(...)** para crear una copia del array original y ordenarla:

``` javascript
let numeros = [5, 10, 2, 25, 7]

const copiaNumeros = [...numeros]
// ordenamos la copia y no el original
copiaNumeros.sort((a, b) => a - b)

console.log(copiaNumeros) // [2, 5, 7, 10, 25]
console.log(numeros) // [5, 10, 2, 25, 7]
```

# Actividad Pr√°ctica

Recibes una lista de n√∫meros. Debes ordenar los n√∫meros de menor a mayor seg√∫n su valor absoluto. Eso quiere decir que los n√∫meros negativos pierden el signo y se ordenan como si fueran positivos.

Por ejemplo, si recibes **[5, -10, -2, -25, -7]** deber√≠as devolver **[-2, 5, -7, -10, -25]**.

Puedes usar el m√©todo **Math.abs(num)** para obtener el valor absoluto de un n√∫mero.

``` javascript
function sortAbsoluteNumbers(numbers) {
  // tu c√≥digo aqu√≠
  }
```

<details>
<summary>Ver soluci√≥n</summary>

``` javascript
function sortAbsoluteNumbers(numbers) {
  return numbers.sort((a, b) => Math.abs(a) - Math.abs(b))
}
```

</details>