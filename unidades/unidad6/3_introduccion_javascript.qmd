::: {.justify}
# JavaScript

:::{.center}
![](/images/javascript.png){width="200"}
:::

Est√© cap√≠tulo est√° basado en el Curso de **"Aprende JavaScript"** en la url [AprendeJavaScript.dev](https://aprendejavascript.dev/) creado por Miguel √Ångel [Midudev](https://porfolio.dev/#sobre-mi), el cual es un desarrollador FullStack y Creador de Contenido, sin m√°s que agregar comencemos.

:::{.center}
![](images/paste-45.png)
:::

## ¬øQu√© es JavaScript?

JavaScript es uno de los lenguajes de programaci√≥n m√°s usados y populares del mundo. Naci√≥ en 1995 para darle interactividad a las p√°ginas web y desde entonces ha evolucionado hasta convertirse en un lenguaje de programaci√≥n de prop√≥sito general. Dicho de otra forma: se puede usar casi para cualquier cosa.

## ¬øQu√© es programar?

Es el acto de construir un programa o conjunto de instrucciones para decirle a una computadora qu√© y c√≥mo queremos que haga algo. No es diferente a cuando "programamos" la lavadora, s√≥lo que en vez de pulsar un bot√≥n, vamos a usar texto. A este texto se le conoce como "c√≥digo".

## ¬øPor qu√© aprender JavaScript?

JavaScript es, a d√≠a de hoy, el √∫nico lenguaje de programaci√≥n que todos los navegadores web entienden sin necesidad de realizar ning√∫n paso previo. Esto hace que casi cualquier p√°gina web que visitas tiene alguna l√≠nea de JavaScript en su interior.

Su curva de aprendizaje para iniciarte es muy corta ya que en muy poco tiempo puedes empezar a hacer cosas interesantes. Para alcanzar a ser un buen programador en JavaScript necesitar√°s a√±os de pr√°ctica, pero para empezar a hacer cosas interesantes bastar√° con poco tiempo.

Por si fuera poco, JavaScript es uno de los lenguajes de programaci√≥n m√°s demandados en el mercado laboral. Es normal, ya que es un lenguaje muy vers√°til y que se puede usar para casi cualquier cosa.

Adem√°s, con JavaScript vas a poder desarrollar casi cualquier cosa que te propongas. Desde aplicaciones web, m√≥viles y de escritorio a backend, videojuegos, inteligencia artificial, Internet de las cosas. Todo un mundo de posibilidades con un s√≥lo lenguaje.

## Quiz

:::{.question}
**¬øJavaScript s√≥lo se puede usar para crear p√°ginas web?**

:::{.choices}
:::{.choice}
Verdadero
:::

::: {.choice .correct-choice}
Falso
:::
:::
:::

:::{.question}
**¬øQu√© es programar en el mundo del software?**

:::{.choices}
:::{.choice}
Crear p√°ginas web y que el usuario pueda usarlas
:::

::: {.choice .correct-choice}
Es el acto de construir un programa o conjunto de instrucciones para decirle a una comptuadora qu√© y c√≥mo queremos que haga algo
:::

:::{.choice}
Cualquier cosa que hagamos en un ordenador
:::
:::
:::

# La consola del navegador

Ahora es necesario utilizar un navegador web, ya que vamos a empezar a escribir c√≥digo JavaScript.

Todos los navegadores tienen una herramienta llamada **consola**. La consola nos permite ejecutar c√≥digo JavaScript en tiempo real y ver el resultado. Tambi√©n ah√≠ podemos ver los errores, advertencias y trazas que se producen en nuestro c√≥digo.

Aunque podemos ejecutar c√≥digo JavaScript de otras formas, para empezar, vamos a usar esta herramienta que nos ofrece el navegador.

::: {.callout-tip}
Recuerda que llamamos c√≥digo a las instrucciones que le damos a la computadora para que haga algo.
:::

## C√≥mo abrir la consola

Para abrir la consola del navegador debes hacer lo siguiente:

1.  Abre tu navegador web favorito, por ejemplo, Google Chrome, Firefox, Safari o Edge.

2.  Ve a la p√°gina **about:blank** en la barra de direcciones. As√≠ evitaremos que la p√°gina web que hemos cargado nos moleste.

3.  Haz **click derecho** en cualquier parte de la p√°gina y selecciona la opci√≥n **Inspeccionar Elemento** o **Inspect**.

Aqu√≠ podr√°s ejecutar tu c√≥digo JavaScript y ver el resultado. Es lo que usaremos en un inicio. M√°s adelante pasaremos a usar un editor como **VSCode**.

En **Google Chrome** o **Brave**, este es el aspecto de la consola

![](images/paste-28.png)

En **Firefox**, este es el aspecto de la consola

![](images/paste-29.png)

## Quiz

:::{.question}
**¬øPara qu√© sirve la consola del navegador?**

:::{.choices}
:::{.choice}
La consola sirve para poder jugar con JavaScript. Es la √∫nica forma de poder ejecutar nuestro c√≥digo y por eso todos los navegadores lo incorporan.
:::

::: {.choice .correct-choice}
La consola nos permite ejecutar c√≥digo JavaScript en tiempo real y ver el resultado. Tambi√©n ah√≠ podemos ver los errores, advertencias y trazas que se producen en nuestro c√≥digo.
:::
:::
:::

# Editores y entornos de desarrollo

En la actualidad existen muchos editores de c√≥digo y entornos de desarrollo que nos permiten escribir c√≥digo de forma m√°s c√≥moda y eficiente. Algunos de los m√°s populares son:

-   **Visual Studio Code**: Es uno de los editores de c√≥digo m√°s populares y es el que usaremos en este curso.

    :::{.center}
    ![](images/paste-41.png)
    :::

-   **Runjs**: Un entorno de desarrollo online que nos permite escribir c√≥digo JavaScript y ver el resultado en tiempo real.

    :::{.center}
    ![](images/paste-38.png)
    :::

-   **Zed Code Editor**: Un editor de c√≥digo muy sencillo y minimalista.

    :::{.center}
    ![](images/paste-39.png)
    :::

# Tipos de Datos

En JavaScript, como cualquier otro lenguaje de programaci√≥n, vamos a querer trasladar la informaci√≥n del mundo real a nuestro c√≥digo. Para ello, necesitamos entender qu√© tipos de datos existen en el lenguaje para poder representar la informaci√≥n que necesitamos.

En JavaScript tenemos 9 tipos de datos que se dividen en dos grandes grupos: **primitivos** o **no primitivos**.

## Tipos Primitivos.

Dentro de los tipos primitivos tenemos 7 tipos de datos:

-   number
-   string
-   boolean
-   null
-   undefined
-   symbol
-   bigint

No te preocupes, no tienes ni recordarlos ni entenderlos todos ahora. En esta lecci√≥n vamos a ver los tres primeros que son, sin ninguna duda, los que m√°s vamos a usar al inicio del curso.

## N√∫meros

Los n√∫meros (tipo number) son los datos m√°s b√°sicos que podemos representar en JavaScript. En JavaScript, no hay una diferencia entre n√∫meros enteros y n√∫meros decimales, todos los n√∫meros son de tipo number:

``` javascript
7
3.14
19.95
2.998e8
-1
```

## Operadores aritm√©ticos

Con los n√∫meros, puedes usar los operadores aritm√©ticos para realizar operaciones matem√°ticas. En JavaScript tenemos los siguientes operadores aritm√©ticos:

-   +: suma
-   -: resta
-   \*: multiplicaci√≥n
-   /: divisi√≥n
-   %: m√≥dulo (resto de la divisi√≥n)
-   \*\*: exponente

Al usar los operadores aritm√©ticos, el resultado siempre ser√° un n√∫mero. Por ejemplo:

``` javascript
2 + 2 // 4
4 - 2 // 2
3 * 2 // 6
2 / 2 // 1
2 % 2 // 0
3 ** 3 // 27
```

## ¬øQu√© significa el // que ves en los ejemplos?

Es un comentario. En JavaScript, los comentarios se escriben con **//** y todo lo que escribas despu√©s de\`*//* ser√° ignorado por el navegador. Los comentarios son muy √∫tiles para explicar qu√© hace nuestro c√≥digo.

Al igual que las matem√°ticas, las operaciones siguen un orden de precedencia. Por ejemplo, si queremos calcular el resultado de **2 + 2 \* 3**, primero se multiplicar√° **2 \* 3** y luego se sumar√° **2 + 6**. El resultado ser√° **8**.

Tambi√©n puedes usar par√©ntesis para cambiar el orden de las operaciones.

``` javascript
2 + 2 * 3 // 8
(2 + 2) * 3 // 12
```

## Cadenas de texto

La cadena de texto (tipo string) es otro tipo de dato muy com√∫n. En JavaScript, las cadenas de texto se representan entre **comillas simples**, **dobles** o **acentos graves**:

``` javascript
'Est√°s aprendiendo JavaScript'

"JavaScript te va a gustar"

`Esto es una cadena de texto`
```

Las comillas simples y dobles funcionan igual, pero al usar **acentos graves** podemos escribir cadenas de texto que ocupen varias l√≠neas:

``` javascript
`Esto es una cadena de texto
que ocupa varias l√≠neas. Puedes escribir
tantas l√≠neas como quieras`
```

## Concatenaci√≥n

Para unir dos cadenas de texto, podemos usar el operador +:

``` javascript
'Est√°s aprendiendo ' + 'JavaScript' // 'Est√°s aprendiendo JavaScript'
```

Como ves, el operador **+** de concatenaci√≥n de cadenas de texto es visualmente el mismo que el operador **+** de **suma de n√∫meros**. El operador **+** funciona de forma diferente dependiendo del tipo de dato que estemos usando.

## Booleanos

Los booleanos representa s√≥lo dos valores: true (verdadero) o false (falso). Por ejemplo:

-   ¬øLa luz est√° encendida (true) o apagada (false)?
-   ¬øEst√° lloviendo (true) o no est√° lloviendo (false)?
-   ¬øEst√° el usuario logueado (true) o no est√° logueado (false)?

Estos son ejemplos de preguntas que podemos responder con un valor booleano.

-   true
-   false

## Quiz

:::{.question}
**¬øCu√°ntos tipos de datos existen en JavaScript?**

:::{.choices}
:::{.choice}
S√≥lo existen 2 tipos de datos
:::

::: {.choice .correct-choice}
9 tipos de datos que se dividen en dos grandes grupos
:::
:::
:::

:::{.question}
**¬øCu√°ntos valores se pueden representar en el tipo de dato Boolean?**

:::{.choices}
:::{.choice}
true y false
:::

::: {.choice .correct-choice}
Cualquier valor que se te ocurra
:::

:::{.choice}
N√∫meros, cadenas de texto y verdadero/falso.
:::
:::
:::

:::{.question}
**El operador + se utiliza para...**

:::{.choices}
:::{.choice}
S√≥lo sirve para sumar dos n√∫meros
:::

:::{.choice}
Concatenar dos textos
:::

::: {.choice .correct-choice}
Depende del tipo de dato que se est√© utilizando
:::
:::
:::

# Los operadores de comparaci√≥n

Los operadores de comparaci√≥n en JavaScript nos permiten comparar dos valores. Siempre devuelven un valor booleano (true o false).

Por ejemplo, podemos comparar si un n√∫mero es mayor que otro con el operador **\>**, o si un n√∫mero es menor que otro con el operador **\<**.

``` javascript
5 > 3 // true
5 < 3 // false
```

Tambi√©n tenemos los operadores **\>=** y **\<=** que nos permiten comparar si un n√∫mero es mayor o igual que otro, o si un n√∫mero es menor o igual que otro.

``` javascript
5 >= 3 // true
5 >= 5 // true
5 <= 3 // false
5 <= 5 // true
```

Para saber si dos valores son iguales podemos usar el operador **===** o, para saber si son diferentes, el operador **!==**.

``` javascript
5 === 5 // true
5 !== 5 // false
```

## Actividad

1.  Escribe un c√≥digo que compruebe si 10 es mayor o igual que 9

2.  Comprueba que 0 es igual a 0

<details>

<summary>Respuesta</summary>

R1.

``` javascript
10 >= 9 // true
```

R2.

``` javascript
0 === 0 // true
```

</detais>

## Comparando cadenas de texto

No s√≥lo podemos usar los comparadores para comparar n√∫meros, tambi√©n podemos usarlos para comparar cadenas de texto y otros tipos de datos.

``` javascript
'JavaScript' === 'JavaScript' // true
'JavaScript' === 'Java' // false
"JavaScript" !== 'PHP' // true
`Estoy Aprendiendo JavaScript` === 'Estoy Aprendiendo JavaScript' // true
```

::: {.callout-tip}
F√≠jate que puedes comparar cadenas de texto que usan comillas simples, dobles o acentos graves. Al final, siguen siendo cadenas de texto y lo importante es que sean iguales.
:::

## ¬øY si usamos el operador \> con cadenas de texto?

Aunque no es muy com√∫n, podemos usar los operadores **\>** , **\>=**, **\<** y **\<=** para comparar cadenas de texto.

JavaScript comparar√° las cadenas de texto seg√∫n el valor de su c√≥digo Unicode.

Por ejemplo, la letra **A** tiene un valor de **65** y la letra **B** tiene un valor de **66**. Por lo tanto, la letra **A** es menor que la letra **B**. Pero ten cuidado, ya que las letras may√∫sculas tienen un valor menor que las letras min√∫sculas.

``` javascript
'Alfa' > 'Beta' // false
'Omega' > 'Beta' // true
'alfa' > 'Alfa' // true
```

## Comparando booleanos

Tambi√©n podemos comparar booleanos con los operadores de comparaci√≥n.

``` javascript
true === true // true
true === false // false
false !== false // false
```

Por si te preguntas c√≥mo se comportan los operadores de mayor o menor que (**\>** y **\<**) con booleanos te dir√© que, aunque no tiene sentido, debes saber que true es mayor que false.

``` javascript
true > false // true
false < true // true
true > true // false
false < false // false
```

## Comparando valores de diferentes tipos

Por ahora hemos visto c√≥mo comparar valores de un mismo tipo, pero ¬øQu√© pasa si queremos comparar valores de diferentes tipos? En JavaScript es algo que es posible pero no suele ser recomendable.

En clases posteriores veremos c√≥mo funciona este tipo de mecanismo y explicaremos el operador de igualdad d√©bil **==** y el operador de desigualdad d√©bil **!=** pero, por ahora, nos limitaremos a utilizar siempre el operador de igualdad estricta **===** y el operador de desigualdad estricta **!==**.

## Quiz

::::::::::::::::::::::::::::::::::::::::::::{.question}
**¬øCu√°l es el resultado de 24 \> 12?**

:::{.choices}
::: {.choice .correct-choice}
true
:::

:::{.choice}
false
:::
:::

:::{.question}
**Los operadores de compraci√≥n solo se pueden usar con n√∫meros**

:::{.choices}
:::{.choice}
S√≠, s√≥lo ah√≠ tiene sentido
:::

::: {.choice .correct-choice}
No, se pueden usar con otros tipos de datos como cadenas de textos o boleanos
:::
:::
:::

# Operadores l√≥gicos en JavaScript

Los operadores l√≥gicos en JavaScript (y en muchos otros lenguajes de programaci√≥n) se utilizan para evaluar expresiones l√≥gicas.

En JavaScript, hay tres operadores l√≥gicos: AND (&&), OR (\|\|) y NOT (!).

## Operador l√≥gico AND &&

El operador l√≥gico AND se indica con &&. Devuelve true cuando ambos valores que conecta son true.

``` javascript
true && true // ‚Üí true
true && false // ‚Üí false
false && false // ‚Üí false
```

Un ejemplo en la vida real ser√≠a preguntar. **¬øEst√°n todas las luces encendidas?** Se comprueba cada luz y si todas est√°n encendidas (true), entonces la respuesta es **true**. Si alguna luz est√° apagada (false), entonces la respuesta es **false**.

## Operador l√≥gico OR \|\|

El operador l√≥gico OR se indica con \|\| y devuelve true cuando cualquiera de los valores que conecta es true.

``` javascript
true || true // ‚Üí true
true || false // ‚Üí true
false || false // ‚Üí false
```

Un ejemplo en la vida real ser√≠a preguntar. **¬øHay alguna luz encendida?** Se comprueba cada luz y si alguna est√° encendida (true), entonces la respuesta es **true**. S√≥lo si todas las luces est√°n apagadas (false), entonces la respuesta es **false**.

## Operador l√≥gico NOT !

El operador l√≥gico NOT se indica con ! e invierte el valor de un valor booleano. Se pone delante del valor que queremos invertir.

``` javascript
!true // ‚Üí false
!false // ‚Üí true
```

Un ejemplo en la vida real ser√≠a pulsar el interruptor de la luz. Si la luz est√° encendida (true), entonces pulsando el interruptor la apagamos (false). Si la luz est√° apagada (false), entonces pulsando el interruptor la encendemos (true).

## Combinando operadores l√≥gicos, aritm√©ticos y de comparaci√≥n

Los operadores l√≥gicos y los operadores de comparaci√≥n se pueden combinar para crear expresiones m√°s complejas. Por ejemplo, podemos preguntar si un n√∫mero est√° entre dos valores.

``` javascript
2 < 3 && 3 < 4 // ‚Üí true
```

En este caso, la expresi√≥n se eval√∫a como **true** porque **2 \< 3** es **true** y **3 \< 4** es **true**. Si cualquiera de las dos expresiones fuera **false**, entonces la expresi√≥n ser√≠a **false**.

Tambi√©n puedes usar par√©ntesis para agrupar operaciones y usar operadores l√≥gicos y aritm√©ticos.

``` javascript
(2 + 2) < 3 && (10 < (8 * 2)) // ‚Üí false
```

Igualmente, es importante que sepas que las operaciones aritm√©ticas tienen precedencia sobre las operaciones de comparaci√≥n.

``` javascript
2 + 2 < 3 && 10 < 8 * 2
// Primero se hacen las operaciones aritm√©ticas:
// ‚Üí 4 < 3 && 10 < 16
// Ahora las comparaciones:
// ‚Üí false && true
// Finalmente:
// ‚Üí false
```

## Actividad

1.  Comprueba si 7 es mayor que 8 y menor que 10

2.  Tenemos un producto en una tienda. Cuesta 1500 y tenemos un descuento del 25%. Tengo \$1150 en mi billetera. Escribe un c√≥digo que me diga si puedo comprarlo. No utilizar parentesis.

<details>

<summary>Respuesta</summary>

R1.

``` javascript
7 > 8 && 7 < 10 // false
```

R2.

``` javascript
1150 >= 1500 * 0.75 // false
```

</details>

# Dos o m√°s operandos

Aunque todos los ejemplos que has visto hasta ahora usan dos operandos, los operadores l√≥gicos tambi√©n pueden usarse con m√°s de dos operandos.

``` javascript
true && true && true // ‚Üí true
```

Tambi√©n puedes mezclar operadores l√≥gicos:

``` javascript
true && true || false // ‚Üí true
!true && !true // ‚Üí false
false && true || !true // ‚Üí false
```

Ahora te puede costar un poco entender qu√© est√° pasando, pero con la pr√°ctica te ir√° resultando m√°s f√°cil. Prueba a hacer los ejercicios y a jugar con los operadores l√≥gicos para que te vayan quedando m√°s claros.

## Quiz

:::{.question}
**¬øQu√© operador l√≥gico se utiliza para comprobar si dos o m√°s condiciones son verdaderas?**

:::{.choices}
:::{.choice}
OR (\|\|)
:::

::: {.choice .correct-choice}
AND (&&)
:::
:::
:::

:::{.question}
**¬øQu√© operador l√≥gico se utiliza para invertir el valor de un booleano?**

:::{.choices}
:::{.choice}
OR (\|\|)
:::

::: {.choice .correct-choice}
NOT (!)
:::
:::
:::

:::{.question}
**¬øQu√© valor devuelve la expresi√≥n false \|\| true?**

:::{.choices}
:::{.choice}
false
:::

::: {.choice .correct-choice}
true
:::
:::
:::

# Variables

A la hora de crear programas, es vital poder almacenar la informaci√≥n para poder utilizarla en un futuro. En JavaScript, usamos variables para conseguirlo.

Para crear una variable podemos usar la palabra reservada **let** y le damos un nombre a la variable. Por ejemplo:

``` javascript
let numero
```

Tenemos una variable llamada numero pero no le hemos asignado ning√∫n valor. Para asignarle un valor, usamos el operador de asignaci√≥n =:

``` javascript
let numero = 1
```

Ahora, podemos referirnos a la variable numero y obtener el valor que le hemos asignado.

``` javascript
numero + 1 // -> 1 + 1
```

Tambi√©n podemos reasignarle un valor a la variable:

``` javascript
numero = 5
numero + 1 // -> 5 + 1
```

::: {.callout-tip}
¬°Ojo! Si no guardas el valor de esta nueva operaci√≥n, el valor de la variable **numero** seguir√° siendo **5**.

``` javascript
numero = 5
numero + 1 // -> 5 + 1
numero + 1 // -> 5 + 1
```
:::

Ten en cuenta que el valor de la variable no tiene porque ser un n√∫mero. Puede ser cualquier tipo de dato, como un texto o un booleano.

``` javascript
let welcomeText = 'Hola'
let isCool = true
```

## Actividad

1.  Crea una variable llamada mensaje y as√≠gnale el valor "Hola JavaScript"

2.  Crea una variable llamada resultado y as√≠gnale la suma de 2 y 3

<details>

<summary>Respuesta</summary>

R1.

``` javascript
let mensaje = 'Hola JavaScript'
```

R2.

``` javascript
let resultado = 2 + 3
```

</details>

## Constantes const

Las constantes son variables que no pueden ser reasignadas. Para crear una constante, usamos la palabra reservada const:

``` javascript
const PI = 3.1415
```

Si intentas reasignar el valor de una constante, obtendr√°s un error:

``` javascript
PI = 3 // -> TypeError: Assignment to constant variable.
```

Como no se pueden reasignar, las constantes siempre deben ser inicializadas con alg√∫n valor. Esto es otra diferencia respecto a let, que no es necesario inicializarla con un valor.

``` javascript
let numero // ‚úÖ
const RADIUS // ‚ùå SyntaxError: Missing initializer in const declaration
```

Son muy √∫tiles para almacenar valores que no van a cambiar. Siempre que puedas, procura usar constantes para que tu c√≥digo sea m√°s predecible.

## Actividad

1.  Crea una constante llamada IS_DISABLED y as√≠gnale el booleano true

<details>

<summary>Respuesta</summary>

``` javascript
const IS_DISABLED = true
```

</details>

## Variables var

En JavaScript, tambi√©n podemos crear variables usando la palabra reservada **var**. Es la forma m√°s antigua y es normal que encuentres muchos tutoriales que lo usen. Sin embargo, a d√≠a de hoy, no es recomendable usar **var** ya que tiene comportamientos extra√±os que pueden causar errores en tu c√≥digo.

En una clase posterior te explicar√© cu√°l es la diferencia entre **let**, **const** y **var** adem√°s de por qu√©, siempre que puedas, deber√≠as evitar var.

## El nombre de las variables

En JavaScript, los nombres de las variables pueden contener letras, n√∫meros y el gui√≥n bajo (\_). Adem√°s, el primer car√°cter del nombre de la variable no puede ser un n√∫mero.

Es importante tener en cuenta que los nombres de las variables son sensibles a las may√∫sculas y min√∫sculas, lo que significa que **miVariable** y **mivariable** son dos variables diferentes en JavaScript.

``` javascript
let miVariable = 1
let mivariable = 2
miVariable + mivariable // -> 1 + 2
```

Tambi√©n es importante que los nombres de las variables sean descriptivos. Por ejemplo, si queremos almacenar el nombre de un usuario, podemos llamar a la variable userName. De esta forma, cuando leamos el c√≥digo, sabremos que la variable contiene el nombre de un usuario.

``` javascript
let n = 'Pepe' // ‚ùå Mal, no es descriptivo
let userName = 'Juan' // ‚úÖ Bien, se entiende
```

## Convenciones y nomenclaturas

En JavaScript, existen diferentes nomenclaturas para nombrar las variables: **camelCase**, **snake_case** y **SCREAMING_CASE**.

**camelCase** es la forma m√°s com√∫n de nombrar las variables en JavaScript. Consiste en escribir la primera palabra en min√∫sculas y las siguientes palabras con su primera letra en may√∫sculas. Por ejemplo:

``` javascript
let camelCase = 1
let camelCaseIsCool = 2
let userName = 'statick'
```

**snake_case** es una forma de nombrar que consiste en escribir todas las palabras en min√∫sculas y separarlas con guiones bajos. Por ejemplo:

``` javascript
let snake_case = 1
let snake_case_is_cool = 2
let user_name = 'statick'
```

En algunos lenguajes de programaci√≥n es muy com√∫n usar snake_case para nombrar las variables. En JavaScript no lo es tanto, pero todav√≠a puedes encontrar c√≥digo que lo use.

Lo m√°s habitual, y es buena idea, es usarlo en los nombres de archivos. Por ejemplo, **mi_archivo.js**. Esto es porque algunos sistemas operativos distinguen entre may√∫sculas y min√∫sculas y, por tanto, **mi_archivo.js** y **Mi_archivo.js** son dos archivos diferentes.

::: {.callout-tip}
Tambi√©n existe kebab-case, que es una forma de nombrar que consiste en escribir todas las palabras en min√∫sculas y separarlas con guiones. Por ejemplo: mi-archivo.js. Es muy similar a snake_case pero con guiones en vez de guiones bajos. No se puede usar para nombrar variables pero s√≠ es com√∫n usarlo en los nombres de archivos.
:::

**SCREAMING_CASE** es una forma de nombrar que consiste en escribir todas las palabras en may√∫sculas y separarlas con guiones bajos. Por ejemplo:

``` javascript
const SCREAMING_CASE = 1
const SCREAMING_CASE_IS_COOL = 2
const USER_NAME = 'statick'
```

Para las constantes, con valores que no van a cambiar, es muy com√∫n usar **SCREAMING_CASE**. As√≠ se puede distinguir f√°cilmente de las variables que s√≠ cambian de valor. Por eso, no debes usarla para nombrar variables con **let**.

## Quiz

:::{.question}
**¬øQu√© es una variable?**

:::{.choices}
::: {.choice .correct-choice}
En JavaScript, una variable es un contenedor de informaci√≥n que se utiliza para almacenar datos en un programa.
:::

:::{.choice}
Una variable es un tipo de dato que se utiliza para almacenar informaci√≥n en un programa.
:::
:::
:::

:::{.question}
**¬øQu√© peculiaridad tienen las variables const en JavaScript?**

:::{.choices}
::: {.choice .correct-choice}
No se pueden reasignar
:::

:::{.choice}
S√≥lo pueden guardar n√∫meros
:::
:::
:::

:::{.question}
**Siempre hay que asignar un valor a una variable**

:::{.choices}
:::{.choice}
S√≠, siempre
:::

:::{.choice}
No, nunca
:::

::: {.choice .correct-choice}
S√≥lo si es una variable const
:::
:::
:::

## null y undefined

¬øRecuerdas que te he comentado que existen diferentes tipos de datos en JavaScript? Hemos visto n√∫meros, cadenas de texto y booleanos.

En esta clase vas a aprender otros dos tipos de datos que, aunque son similares, tienen ligeras diferencias. Son **null** y **undefined**.

La particularidad de estos dos tipos de datos es que cada uno s√≥lo tiene un valor. El tipo **null** s√≥lo puede tener el valor **null** y el tipo **undefined** s√≥lo puede tener el valor undefined.

::: {.callout-tip}
Es como el tipo booleano que pod√≠a ser **true** y **false** pero, en este caso, s√≥lo tiene un valor.
:::

## La diferencia entre null y undefined

Mientras que null es un valor que significa que algo no tiene valor, undefined significa que algo no ha sido definido. Por ejemplo, si creamos una variable sin asignarle ning√∫n valor, su valor ser√° undefined:

``` javascript
let rolloDePapel // -> undefined
```

Tambi√©n podemos asignar directamente el valor undefined a una variable:

``` javascript
let rolloDePapel = undefined // -> undefined
```

En cambio, para que una variable tenga el valor null, s√≥lo podemos conseguirlo asign√°ndole expl√≠citamente ese valor:

``` javascript
let rolloDePapel = null
```

Un caso bastante ilustrativo para entender la diferencia entre null y undefined es el siguiente:

![](images/paste-30.png)

## Actividad

1.  Crea una variable con let llamada capacidad y as√≠gnale un valor null

2.  Crea una variable con let llamada dinero y aseg√∫rate que tenga un valor de undefined

<details>

<summary>Respuesta</summary>

R1.

``` javascript
let capacidad = null
```

R2.

``` javascript
let dinero
```

</details>

## Comparaciones con null y undefined

Al usar la igualdad estricta que hemos visto en la clase anterior, null y undefined son considerados diferentes entre s√≠:

``` javascript
null === undefined // -\> false
```

S√≥lo cuando comparamos null con null o undefined con undefined obtenemos true:

``` javascript
null === null // -\> true undefined === undefined // -\> true
```

## Quiz

:::{.question}
**null y undefined son dos valores que significan lo mismo.**

:::{.choices}
:::{.choice}
S√≠, ambos indican la ausencia de valor.
:::

::: {.choice .correct-choice}
No, null es un valor que indica algo vac√≠o, mientras que undefined indica algo que no est√° definido todav√≠a.
:::
:::
:::

:::{.question}
**¬øQu√© valor tiene una variable a la que no se le ha asignado nada al declararla?**

:::{.choices}
:::{.choice}
Un valor null
:::

::: {.choice .correct-choice}
Un valor undefined
:::

:::{.choice}
No se puede declarar a una variable sin asignar un valor
:::
:::
:::

# Operador typeof

El operador **typeof** devuelve una cadena de texto que indica el tipo de un operando. Puede ser usado con cualquier tipo de operando, incluyendo variables y literales.

``` javascript
const MAGIC_NUMBER = 7
typeof MAGIC_NUMBER // "number"
```

Tambi√©n puedes usarlo directamente con los valores que quieras comprobar:

``` javascript
typeof undefined // "undefined"
typeof true // "boolean"
typeof 42 // "number"
typeof "Hola mundo" // "string"
```

## Actividad

1.  Tengo una variable llamada userName. Excribe el c√≥digo necesario para ver su tipo.

<details>

<summary>Respuesta</summary>

``` javascript
let userName
typeof userName // "undefined"
```

</details>

Existe, sin embargo, un valor especial en JavaScript, **null**, que es considerado un bug en el lenguaje. El operador **typeof** devuelve **"object"** cuando se usa con **null**:

``` javascript
typeof null // "object"
```

Lo correcto ser√≠a que **typeof null** devolviera **"null"**, pero es un [error hist√≥rico que no se puede corregir sin romper el c√≥digo existente](https://2ality.com/2013/10/typeof-null.html).

Por eso, si quieres comprobar si una variable es **null**, debes usar la comparaci√≥n estricta **===**:

``` javascript
const foo = null
foo === null // true
```

Otra pregunta es... ¬øQu√© es ese **object**? Es un tipo de dato que est√° en el centro de JavaScript y que veremos en detalle m√°s adelante.

## Usando con operadores de comparaci√≥n

El operador **typeof** es muy √∫til cuando se usa con operadores de comparaci√≥n. Por ejemplo, para comprobar si una variable es del tipo que esperamos:

``` javascript
const age = 42
typeof age === "number" // true
```

Una vez que tenemos expresiones l√≥gicas, podemos empezar a encadenar operadores l√≥gicos para comprobar m√∫ltiples condiciones:

``` javascript
const age = 42
typeof age === "number" && age > 18 // true
```

## Actividad

1.  Tengo una variable llamada dogId pero no tengo claro si es una cadena de texto. Escribe el c√≥digo necesario para asegurarte.

<details>

<summary>Respuesta</summary>

``` javascript
typeof dogId === "string" // false
```

</details>

## Quiz

:::{.question}
**¬øPara qu√© sirve el operador typeof en JavaScript?**

:::{.choices}
:::{.choice}
Nos permite leer el valor de una variable
:::

::: {.choice .correct-choice}
Nos da el tipo de dato de una variable
:::
:::
:::

:::{.question}
**El operador typeof siempre devuelve una cadena de texto con el tipo del operando.**

:::{.choices}
::: {.choice .correct-choice}
Si, siempre devuelve una cadena de texto
:::

:::{.choice}
Depende del tipo de dato que le pasemos, Si le pasamos un n√∫mero, nos devolver√° un number
:::
:::
:::

## Comentarios

En JavaScript, los comentarios son **una forma de agregar explicaciones al c√≥digo que se ignora al ejecutar el programa**.

Los comentarios son √∫tiles para explicar el por qu√© del c√≥digo, documentar los cambios realizados en el c√≥digo y hacer que el c√≥digo sea m√°s f√°cil de entender para otros desarrolladores.

Hay **dos tipos de comentarios en JavaScript**: los comentarios de una sola l√≠nea y los comentarios de varias l√≠neas.

## Comentarios de una sola l√≠nea //

Los comentarios de una sola l√≠nea comienzan con **//** y se utilizan para agregar una explicaci√≥n en una sola l√≠nea de c√≥digo. Por ejemplo:

``` javascript
// S√≥lo usamos 6 decimales
const PI = 3.141592

// Iniciamos el radio por 10, pero puede cambiar
let radio = 10
```

Tambi√©n puedes a√±adir un comentario de una sola l√≠nea al final de una l√≠nea de c√≥digo. Por ejemplo:

``` javascript
const PI = 3.141592 // S√≥lo usamos 6 decimales
```

## Comentarios de varias l√≠neas /\* \*/

Los comentarios de varias l√≠neas comienzan con /\* y terminan con \*/. Se utilizan para agregar notas explicativas que ocupan varias l√≠neas de c√≥digo. Por ejemplo:

``` javascript
/*
  Este es un comentario de varias l√≠neas.
  Se utiliza para agregar notas explicativas que ocupan varias l√≠neas de c√≥digo.
*/
```

Ten en cuenta que tambi√©n puedes lograr varias l√≠neas usando el tipo de comentario //, s√≥lo que en este caso, cada l√≠nea de c√≥digo debe comenzar con //. Por ejemplo:

``` javascript
// Este es un comentario de varias l√≠neas.
// Se utiliza para agregar notas explicativas que ocupan varias l√≠neas de c√≥digo.
```

Es importante tener en cuenta que **los comentarios no afectan el funcionamiento del c√≥digo**. Es decir, si se eliminan los comentarios, el c√≥digo seguir√° funcionando de la misma manera.

Es recomendable utilizar comentarios con moderaci√≥n y de manera efectiva para hacer que el c√≥digo sea m√°s f√°cil de entender y mantener. **Los comentarios deben ser claros y concisos, y deben explicar lo que hace el c√≥digo sin repetir lo que ya es obvio**.

Es mejor que tu c√≥digo sea lo suficientemente claro como para no necesitar comentarios, pero si es necesario, **utiliza comentarios para explicar el por qu√© del c√≥digo, no el qu√©**.

## Quiz

:::{.question}
**¬øPara qu√© sirven los comentarios en JavaScript?**

:::{.choices}
::: {.choice .correct-choice}
Sirven para documentar nuestro c√≥digo y explicar qu√© hace cada parte de √©l
:::

:::{.choice}
Para cambiar el comportamiento de nuestro c√≥digo
:::
:::
:::

:::{.question}
**¬øC√≥mo se escriben los comentarios en JavaScript?**

:::{.choices}
:::{.choice}
Puedes usar \# para escribir comentarios de una l√≠nea o varias
:::

::: {.choice .correct-choice}
Puedes usar // para escribir comentarios de una l√≠nea o /\* \*/ para escribir comentarios de varias l√≠neas
:::
:::
:::

## console.log()

**console.log()** es una funci√≥n integrada en *JavaScript* que se utiliza para imprimir mensajes en la consola del navegador o del editor de c√≥digo. Se utiliza principalmente para depurar el c√≥digo y para **imprimir valores de variables y mensajes para ayudar en el proceso de desarrollo**.

::: {.callout-tip}
En programaci√≥n, una funci√≥n es un conjunto de instrucciones que se pueden usar una y otra vez para hacer una tarea espec√≠fica. Muchas veces, las funciones se utilizan para evitar repetir c√≥digo y son parametrizables. M√°s adelante tendremos una secci√≥n s√≥lo para ellas.
:::

## Sintaxis

Para poder mostrar estos mensajes en consola, debes escribir **console.log()** y dentro de los par√©ntesis, el mensaje que quieres mostrar.

``` javascript
console.log('Hola, JavaScript')
// -> 'Hola, JavaScript'
```

Tambi√©n puedes averiguar el valor de una variable, escribiendo el nombre de la variable dentro de los par√©ntesis.

``` javascript
const nombre = 'JavaScript'
console.log(nombre)
// -> 'JavaScript'
```

Como ya sabes concatenar cadenas de texto, puedes mostrar un mensaje y el valor de una variable en el mismo **console.log()**.

``` javascript
const nombre = 'JavaScript'
console.log('Hola, ' + nombre)
// -> 'Hola, JavaScript'
```

Adem√°s, puedes mostrar varios mensajes y valores de variables en el mismo **console.log()** separ√°ndolos por comas.

``` javascript
const nombre = 'JavaScript'
const version = 2023
console.log(nombre, version)
// -> 'JavaScript 2023'
```

## M√°s m√©todos de console

Adem√°s de **console.log()**, existen otros m√©todos que puedes utilizar para imprimir mensajes en la consola. Algunos de ellos son:

::: {.callout-tip}
-   **console.error():** Imprime un mensaje de error en la consola.

-   **console.warn():** Imprime un mensaje de advertencia en la consola.

-   **console.info():** Imprime un mensaje de informaci√≥n en la consola.
:::

Como ves, la sintaxis es la misma que **console.log()**, s√≥lo cambia el nombre del m√©todo.

::: {.callout-tip}
Aunque puedes usar **console.log()** para imprimir cualquier tipo de mensaje, es recomendable utilizar los m√©todos que acabamos de ver para imprimir mensajes de error, advertencia e informaci√≥n ya que tienen un formato especial que los hace m√°s f√°ciles de identificar.
:::

``` javascript
console.error('Error')
// ‚ùå Error
console.warn('Advertencia')
// ‚ö†Ô∏è Advertencia
console.info('Informaci√≥n')
// ‚ÑπÔ∏è Informaci√≥n
```

Prueba estos m√©todos en la consola del navegador y observa los resultados.

## Quiz

:::{.question}
**¬øCu√°l es la sintaxis adecuada para imprimir un mensaje en la consola del navegador?**

:::{.choices}
:::{.choice}
console("mensaje")
:::

::: {.choice .correct-choice}
console.log("mensaje")
:::

:::{.choice}
console.write("mensaje")
:::
:::
:::

:::{.question}
**¬øC√≥mo podr√≠as usar console.log() para imprimir m√∫ltiples valores o variables en una sola l√≠nea de c√≥digo?**

:::{.choices}
:::{.choice}
Utilizando una sintaxis especial que formatea los valores o variables en una sola l√≠nea de c√≥digo
:::

:::{.choice}
No es posible imprimir m√∫ltiples valores o variables en una sola l√≠nea de c√≥digo con console.log()
:::

::: {.choice .correct-choice}
Separando cada valor o variable con comas dentro de los par√©ntesis de console.log()
:::
:::
:::

:::{.question}
**¬øCu√°l es la diferencia entre console.log() y console.error() en JavaScript?**

:::{.choices}
::: {.choice .correct-choice}
console.log() se utiliza para imprimir mensajes en la consola del navegador, mientras que console.error() se utiliza para imprimir mensajes de error.
:::

:::{.choice}
console.log() se utiliza para imprimir mensajes de error en la consola del navegador, mientras que console.error() se utiliza para imprimir mensajes normales
:::

:::{.choice}
No hay diferencia entre console.log() y console.error() en JavaScript
:::
:::
:::

# C√≥digo Condicional con if

El c√≥digo condicional es un bloque de c√≥digo que se ejecuta s√≥lo si se cumple una condici√≥n. En JavaScript usamos la palabra reservada if para crear un bloque condicional, as√≠:

``` javascript
if (condici√≥n) {
  // c√≥digo que se ejecuta si la condici√≥n es verdadera
}
```

Como ves, ponemos la condici√≥n entre par√©ntesis y el c√≥digo se ejecuta si la condici√≥n entre llaves es **true**. Si la condici√≥n es **false**, el c√≥digo no se ejecuta.

Imagina que quieres mostrar un mensaje si la edad de un usuario es mayor o igual a 18 a√±os. Podr√≠as hacerlo as√≠:

``` javascript
const edad = 18

if (edad >= 18) {
  console.log('Eres mayor de edad')
}
```

## else

Es posible utilizar la palabra clave **else** para ejecutar un bloque de c√≥digo diferente si la condici√≥n es falsa:

``` javascript
const edad = 17

if (edad >= 18) {
  console.log('Eres mayor de edad')
} else {
  console.log('Eres menor de edad')
}
```

Esto es √∫til para ejecutar un bloque de c√≥digo u otro dependiendo de si se cumple o no una condici√≥n. else if

Tambi√©n podemos utilizar la palabra clave **else if** para comprobar m√°s de una condici√≥n:

``` javascript
const edad = 17

if (edad >= 18) {
  console.log('Eres mayor de edad')
} else if (edad >= 16) {
  console.log('Eres casi mayor de edad')
} else {
  console.log('Eres menor de edad')
}
```

El programa comprueba la primera condici√≥n. Si es **true**, ejecuta el c√≥digo dentro del bloque **if**. Si es **false**, comprueba la siguiente condici√≥n. Si es **true**, ejecuta el c√≥digo dentro del bloque **else if**. Si es false, ejecuta el c√≥digo dentro del bloque **else**.

Dicho de otra forma, entrar√° en el primer bloque que cumpla la condici√≥n y no entrar√° en los dem√°s. Si no cumple ninguna, entonces entrar√° en el bloque **else**.

## Anidaci√≥n de condicionales

Es posible anidar condicionales dentro de otros condicionales. Por ejemplo:

``` javascript
const edad = 17
const tieneCarnet = true

if (edad >= 18) {
  if (tieneCarnet) {
    console.log('Puedes conducir')
  } else {
    console.log('No puedes conducir')
  }
} else {
  console.log('No puedes conducir')
}
```

En muchas ocasiones vas a querer evitar la anidaci√≥n innecesaria de condicionales ya que se hacen dif√≠ciles de leer y mantener. En estos casos es mejor utilizar operadores l√≥gicos para crear la condici√≥n:

``` javascript
const edad = 17
const tieneCarnet = true

// si es mayor de edad y tiene carnet entonces...
if (edad >= 18 && tieneCarnet) {
  console.log('Puedes conducir')
} else {
  console.log('No puedes conducir')
}
```

Otra t√©cnica muy interesante es la de guardar el resultado de la condici√≥n en una variable, para que tus condiciones sean mucho m√°s legibles:

``` javascript
const edad = 17
const tieneCarnet = true
const puedeConducir = edad >= 18 && tieneCarnet

if (puedeConducir) {
  console.log('Puedes conducir')
} else {
  console.log('No puedes conducir')
}
```

::: {.callout-tip}
¬°Wow! ¬øHas visto c√≥mo hemos mejorado la legibilidad de nuestro c√≥digo? ¬°Es mucho m√°s f√°cil de leer y entender! A este tipo de t√©cnica se le llama *refactorizaci√≥n* y consiste en mejorar el c√≥digo sin cambiar su comportamiento.
:::

## La importancia de las llaves

Es importante que sepas que las llaves **{ }** no siempre son obligatorios. Si el bloque de c√≥digo s√≥lo tiene una l√≠nea, puedes omitir las llaves:

``` javascript
const edad = 17

if (edad >= 18)
  console.log('Eres mayor de edad')
else
  console.log('Eres menor de edad')
```

Tambi√©n lo puedes escribir en la misma l√≠nea:

``` javascript
const edad = 18

if (edad >= 18) console.log('Eres mayor de edad')
else console.log('Eres menor de edad')
```

Sin embargo, **te recomiendo que mientras est√©s aprendiendo siempre escribas las llaves**. Esto te ayudar√° a evitar errores y a que tu c√≥digo sea m√°s legible.

## Quiz

:::{.question}
**¬øQu√© es un bloque condicional en JavaScript?**

:::{.choices}
::: {.choice .correct-choice}
Un bloque de c√≥digo que se ejecuta s√≥lo si se cumple una condici√≥n
:::

:::{.choice}
Un bloque de c√≥digo que se ejecuta siempre
:::
:::
:::

:::{.question}
**¬øQu√© palabra clave se utiliza en JavaScript para crear un bloque condicional?**

:::{.choices}
:::{.choice}
if
:::

::: {.choice .correct-choice}
else
:::

:::{.choice}
then
:::
:::
:::

:::{.question}
**¬øQu√© palabra clave se utiliza en JavaScript para ejecutar un bloque de c√≥digo si la condici√≥n de un bloque condicional es falsa?**

:::{.choices}
:::{.choice}
if
:::

:::{.choice}
then
:::

::: {.choice .correct-choice}
else
:::
:::
:::

## Actividad

1.  Crea una variable llamada **temperatura** y as√≠gnale un valor num√©rico. Escribe un bloque condicional que imprima en la consola si la temperatura es mayor o igual a 25 grados.

2.  Crea una variable llamada **esVerano** y as√≠gnale un valor booleano. Escribe un bloque condicional que imprima en la consola si es verano o no.

<details>

<summary>Respuesta</summary>

R1.

``` javascript
const temperatura = 25

if (temperatura >= 25) {
  console.log('Hace calor')
}
```

R2.

``` javascript
const esVerano = true

if (esVerano) {
  console.log('Es verano')
}
```

</details>

# Bucles con while

Un bucle es una **estructura de control** que permite repetir un bloque de instrucciones. Vamos, **repetir una tarea tantas veces como queramos**.

En JavaScript, existen varias formas de lograrlo, y una de ellas es el bucle con **while**. El bucle **while** es una estructura de control de flujo que ejecuta una secci√≥n de c√≥digo mientras se cumple una determinada condici√≥n.

En esta clase, vamos a explicar c√≥mo funciona el bucle **while** en JavaScript y c√≥mo podemos utilizarlo en nuestros programas.

## Sintaxis

La sintaxis del bucle **while** es similar a la de un condicional **if**. La √∫nica diferencia es que, en lugar de ejecutar el c√≥digo una sola vez, se ejecuta mientras se cumpla la condici√≥n.

``` javascript
while (condici√≥n) {
  // c√≥digo a ejecutar mientras se cumpla la condici√≥n
}
```

El bucle comienza evaluando la condici√≥n dentro de los par√©ntesis. Si la condici√≥n es **true**, se ejecuta el c√≥digo dentro de las llaves.

Despu√©s de ejecutar el c√≥digo, la condici√≥n se eval√∫a de nuevo, y si sigue siendo verdadera, el c√≥digo dentro de las llaves se ejecuta de nuevo. **Este proceso se repite hasta que la condici√≥n se eval√∫a como falsa**.

Ten en cuenta que, si la condici√≥n es falsa desde el principio, el c√≥digo dentro de las llaves nunca se ejecutar√°.

::: {.callout-tip}
A cada vuelta del bucle se le llama **iteraci√≥n**. Una iteraci√≥n es la repetici√≥n de un proceso o acci√≥n un n√∫mero determinado de veces, de manera ordenada y sistem√°tica.
:::

## Ejemplo de uso de while

Vamos a crear la cuenta atr√°s de un cohete. Creamos una variable **cuentaAtras** que contenga el n√∫mero de segundos que faltan para el lanzamiento. En este caso, vamos a empezar con 10 segundos.

``` javascript
let cuentaAtras = 10
```

Para quitarle un segundo a la cuenta atr√°s, vamos a utilizar el operador de resta (**-**) y el operador de asignaci√≥n (**=**).

``` javascript
let cuentaAtras = 10
cuentaAtras = cuentaAtras - 1
console.log(cuentaAtras) // -> 9
```

Sabiendo esto y c√≥mo funciona el bucle while, podemos crear la cuenta atr√°s del cohete.

``` javascript
// iniciamos la variable fuera del bucle
let cuentaAtras = 10

// mientras la cuenta atr√°s sea mayor que 0
while (cuentaAtras > 0) {
  // mostramos el valor de la cuenta atr√°s en cada iteraci√≥n
  console.log(cuentaAtras)
  // restamos 1 a la cuenta atr√°s
  cuentaAtras = cuentaAtras - 1
}

console.log('¬°Despegue! üöÄ')
```

Si ejecutas este c√≥digo en consola, deber√≠as ver los n√∫meros del 10 al 1, y despu√©s el mensaje de despegue.

## Cuidado con los bucles infinitos

Los bucles **while** son muy potentes, pero tambi√©n pueden ser peligrosos. Si la condici√≥n nunca se eval√∫a como falsa, el bucle se ejecutar√° infinitamente.

``` javascript
while (true) {
  console.log('¬°Hola hasta el infinito!')
}
```

Esto evaluar√° la condici√≥n **true** como verdadera, y ejecutar√° el c√≥digo dentro de las llaves una y otra vez.

## Saliendo de un bucle con break

Podemos controlar cu√°ndo queremos salir de un bucle utilizando la palabra reservada **break**. Cuando el int√©rprete de JavaScript encuentra la palabra **break**, sale del bucle y contin√∫a ejecutando el c√≥digo que haya despu√©s.

``` javascript
let cuentaAtras = 10

while (cuentaAtras > 0) {
  console.log(cuentaAtras)
  cuentaAtras = cuentaAtras - 1

  // si la cuenta atr√°s es 5, salimos del bucle
  if (cuentaAtras === 5) {
    break // <---- salimos del bucle
  }
}
```

¬øCu√°l es el valor de **cuentaAtras** en este c√≥digo? Veamos, el bucle estaba haciendo una cuenta atr√°s... pero le hemos dicho que cuando tuviese el valor **5** saliese del bucle. Por lo tanto, el valor de **cuentaAtras** es **5**.

Usar **break** puede ser √∫til en bucles si queremos salir de ellos por alguna condici√≥n en concreto o para evitar justamente los bucles infinitos.

## Saltando una iteraci√≥n con continue

Igual que tenemos la posibilidad de "romper" el bucle con **break**, tambi√©n podemos saltarnos una iteraci√≥n con **continue**. Cuando el int√©rprete de JavaScript encuentra la palabra **continue**, salta a la siguiente iteraci√≥n del bucle.

``` javascript
let cuentaAtras = 10

while (cuentaAtras > 0) {
  cuentaAtras = cuentaAtras - 1

  // si la cuenta atr√°s es un n√∫mero par...
  if (cuentaAtras % 2 === 0) {
    continue // <---- saltamos a la siguiente iteraci√≥n
  }

  console.log(cuentaAtras)
}
```

¬øQu√© aparece en la salida de la consola? El bucle est√° haciendo una cuenta atr√°s... pero le hemos dicho que si el n√∫mero es par, se salte esa iteraci√≥n y deje de ejecutar el c√≥digo que le sigue.

Por ello, los n√∫meros pares no aparecen en la consola.

## Anidaci√≥n de bucles

Podemos anidar bucles dentro de otros bucles. Imagina que en nuestra cuenta atr√°s para el cohete, tenemos que revisar que 3 cosas est√°n en sus par√°metros: el ox√≠geno, el combustible y la temperatura.

``` javascript
const NUMERO_REVISIONES = 3
let cuentaAtras = 10

// mientras la cuenta atr√°s sea mayor que 0
while (cuentaAtras > 0) {
  // mostramos el valor de la cuenta atr√°s
  console.log(cuentaAtras)

  // creamos una variable para contar las revisiones realizadas
  // y la inicializamos a cero
  let revisionesRealizadas = 0

  // hasta que no hayamos realizado las 3 revisiones...
  while (revisionesRealizadas < NUMERO_REVISIONES) {
    // y sumamos 1 a las revisiones realizadas
    revisionesRealizadas = revisionesRealizadas + 1
    console.log(revisionesRealizadas + ' revisiones realizadas...')
  }

  // ahora podemos restar 1 a la cuenta atr√°s
  cuentaAtras = cuentaAtras - 1
}
```

::: {.callout-tip}
¬øPor qu√© la constante la hemos puesto toda en may√∫sculas? Como ya explicamos en la clase de introducci√≥n a JavaScript, es una convenci√≥n para indicar que es una constante y que no va a cambiar.
:::

Adem√°s del bucle anidado, hay algo tambi√©n muy interesante en el c√≥digo anterior y es la creaci√≥n de la variable **let revisionesRealizadas**.

Ten en cuenta que esa variable se crear√° y se inicializar√° a **0** en cada iteraci√≥n del bucle.

Las variables creadas con **let** y **const** que se crean dentro de un bucle, solo existen dentro de ese bucle. Cuando el bucle termina, la variable desaparece. De hecho si intentas acceder a ella fuera del bucle, te dar√° un error.

``` javascript
let cuentaAtras = 10

while (cuentaAtras > 0) {
  let revisionesRealizadas = 3
  console.log(revisionesRealizadas)
  cuentaAtras = cuentaAtras - 1
}

console.log(revisionesRealizadas) // -> ERROR: ReferenceError
```

Esto tambi√©n pasa con otras estructuras de control. Eso es porque el alcance de las variables creadas con **let** y **const** es el bloque entre **{ }** en el que se crean. Lo iremos viendo m√°s adelante para que vayas practicando, no te preocupes.

## Quiz

:::{.question}
**¬øCu√°l es la sintaxis correcta para utilizar un bucle while en JavaScript?**

:::{.choices}
::: {.choice .correct-choice}
![](images/paste-31.png)
:::

:::{.choice}
![](images/paste-34.png)
:::
:::
:::

:::{.question}
**¬øCu√°l es la palabra reservada que se utiliza para salir de un bucle en JavaScript?**

:::{.choices}
::: {.choice .correct-choice}
break
:::

:::{.choice}
continue
:::

:::{.choice}
exit
:::
:::
:::

:::{.question}
**¬øCu√°ntas veces saldr√° en consola la palabra 'Caf√©'?**

:::{.center}
![](images/paste-36.png)
:::

:::{.choices}
::: {.choice .correct-choice}
6
:::

:::{.choice}
4
:::

:::{.choice}
5
:::
:::
:::

# Bucles con do while

Aunque no es muy famoso ni muy utilizado, es interesante que sepas que existe en JavaScript un bucle que se ejecuta al menos una vez, y luego se repite mientras se cumpla una condici√≥n. Este bucle se llama **do while** y tiene la siguiente sintaxis:

``` javascript
do {
  // c√≥digo que se ejecuta al menos una vez
} while (condici√≥n);
```

Vamos a aprovechar para hacer m√°s interesante la clase. Por eso te voy a presentar una funci√≥n integradas en JavaScript que nos van a dar mucho juego: **confirm**.

# confirm

La funci√≥n **confirm** muestra un cuadro de di√°logo con dos botones: "Aceptar" y "Cancelar". Si el usuario pulsa "Aceptar", la funci√≥n devuelve **true**. Si pulsa "Cancelar", devuelve **false**.

``` javascript
confirm("¬øTe gusta JavaScript?");
```

Llamar a la funci√≥n **confirm** es una expresi√≥n y, por lo tanto, produce un valor que podemos guardar en una variable.

``` javascript
let respuesta = confirm("¬øTe gusta JavaScript?")
console.log(respuesta) // -> true o false
```

# Usando do while

Vamos a hacer un programa que saldr√° de un bucle **do while** cuando el usuario pulse "Cancelar" en el cuadro de di√°logo que muestra la funci√≥n **confirm**.

``` javascript
let respuesta

do {
  respuesta = confirm("¬øTe gusta JavaScript?");
} while (respuesta)
```

::: {.callout-tip}
¬øPor qu√© hay que poner la variable **respuesta** fuera? Porque si no, no podr√≠a ser usada en la condici√≥n del bucle. Ya vas viendo lo que coment√°mos antes del √°mbito de las variables.
:::

Si el usuario pulsa "Aceptar", la variable **respuesta** valdr√° **true** y el bucle se repetir√°. Si el usuario pulsa "Cancelar", la variable **respuesta** valdr√° **false** y el bucle se detendr√°.

## Quiz

:::{.question}
¬øCu√°ntas veces como m√≠nimo se ejecutar√° el c√≥digo dentro de un bucle do{ ... } while?

:::{.choices}
:::{.choice}
Ninguna vez
:::

:::{.choice}
Depende de la condici√≥n
:::

::: {.choice .correct-choice}
Una vez
:::
:::
:::

# Expresiones y declaraciones

En JavaScript, existen dos tipos de elementos fundamentales para escribir c√≥digo: **expresiones** y **declaraciones**. Aunque estos t√©rminos pueden parecer confusos al principio, son conceptos clave para comprender c√≥mo funciona JavaScript.

# Declaraciones

Las declaraciones en JavaScript son sentencias que definen la creaci√≥n de una variable, funci√≥n o clase. **Podr√≠amos decir que las declaraciones son como las instrucciones que le damos a JavaScript para que haga algo**.

::: {.callout-tip}
Las funciones y las clases las veremos m√°s adelante en el curso, no te preocupes.
:::

Por ejemplo, una declaraci√≥n de variable es una sentencia que le da un nombre y un valor a una variable. El siguiente c√≥digo es un ejemplo de una declaraci√≥n de variable:

``` javascript
let nombre = "Juan"
```

Este c√≥digo no lo puedes usar con el m√©todo **console.log**, ya que no produce ning√∫n valor. Si lo intentas, obtendr√°s un error:

``` javascript
console.log(let nombre = "Juan") // SyntaxError
```

# Expresiones

**Las expresiones en JavaScript son sentencias que producen un valor**. Las expresiones pueden ser tan simples como un solo n√∫mero o una cadena de texto, o tan complejas como el c√°lculo de una operaci√≥n matem√°tica, la evaluaci√≥n de diferentes valores o la llamada a una funci√≥n.

Por ejemplo, una expresi√≥n num√©rica es una sentencia que produce un n√∫mero:

``` javascript
2 + 3 // -> 5
```

De hecho, lo que guardamos en las variables son expresiones. Por ejemplo, en el siguiente c√≥digo, la expresi√≥n **2 + 3** se eval√∫a y el resultado se guarda en la variable **resultado**:

``` javascript
let resultado = 2 + 3
```

En ese c√≥digo tenemos la declaraci√≥n que queremos guardar en la variable resultado el **resultado** de la expresi√≥n **2 + 3**.

# ¬øPor qu√© es importante la diferencia?

La diferencia entre declaraciones y expresiones es importante ya que no podemos usar una declaraci√≥n donde se espera una expresi√≥n y viceversa.

Por ejemplo, ya hemos conocido las estructuras de control **if** y **while**. Ambas esperan una expresi√≥n que se eval√∫a a un valor booleano. Por lo tanto, no podemos usar una declaraci√≥n en su lugar:

``` javascript
// ‚ùå Ambos c√≥digos est√°n mal y sirven para
// ilustrar que no debes usar declaraciones
// cuando espera expresiones

if (let nombre = "Juan") { // ‚ùå SyntaxError
  console.log("Hola, Juan")
}

while (let i = 0) { // ‚ùå SyntaxError
  console.log("Iteraci√≥n")
  i = i + 1
}
```

# Quiz

:::{.question}
¬øQu√© son las declaraciones en JavaScript y para qu√© se utilizan?

:::{.choices}
::: {.choice .correct-choice}
Las declaraciones en JavaScript son sentencias que definen la creaci√≥n de una variable, funci√≥n o clase para que puedan ser usadas posteriormente en el c√≥digo.
:::

:::{.choice}
Las declaraciones en JavaScript son sentencias que producen un valor. Se utilizan para calcular un valor y devolverlo en una expresi√≥n.
:::

:::{.choice}
Las declaraciones en JavaScript son sentencias que se utilizan para realizar operaciones matem√°ticas complejas.
:::
:::
:::

:::{.question}
¬øQu√© son las expresiones en JavaScript y para qu√© se utilizan?

:::{.choices}
:::{.choice}
Las expresiones en JavaScript son sentencias que definen la creaci√≥n de una variable
:::

::: {.choice .correct-choice}
Las expresiones en JavaScript son sentencias que producen un valor.
:::

:::{.choice}
Las expresiones s√≥lo se usan como condiciones de los condicionales if y los bucles.
:::
:::
:::

# Bucles con for

La estructura de control **for** en JavaScript es muy √∫til para ejecutar una serie de instrucciones un n√∫mero determinado de veces. A diferencia de **while** que usa una condici√≥n para determinar si se ejecuta o no el bloque de c√≥digo, **for** usa un contador que se incrementa en cada iteraci√≥n hasta que se cumple una condici√≥n.

La sintaxis de **for** es la siguiente:

``` javascript
for (inicializaci√≥n; condici√≥n; actualizaci√≥n) {
  // c√≥digo a ejecutar
}
```

Importante, f√≠jate que **for** tiene tres partes separadas por ;:

-   La *inicializaci√≥n* se realiza antes de que se inicie el bucle y se utiliza para declarar variables y asignar valores iniciales.

-   La *condici√≥n* es una expresi√≥n *booleana* que se eval√∫a antes de cada iteraci√≥n del bucle. Si la expresi√≥n se eval√∫a como **true**, se ejecuta el bloque de c√≥digo dentro del bucle. Si la expresi√≥n se eval√∫a como **false**, el bucle termina.

-   La actualizaci√≥n se utiliza para actualizar el valor de la variable de control del bucle despu√©s de cada iteraci√≥n. Normalmente, se incrementa o decrementa el valor de la variable de control del bucle.

# Ejemplo de uso de for

El siguiente ejemplo muestra c√≥mo se puede usar **for** para imprimir los n√∫meros del 1 al 10:

``` javascript
for (let number = 1; number <= 10; number++) {
  console.log(number)
}
```

-   La inicializaci√≥n es la declaraci√≥n de la variable **number** y la asignaci√≥n del valor **1**.
-   La condici√≥n es que mientras **number \<= 10**, se itera el bucle.
-   La actualizaci√≥n es **number++** que incrementa el valor de **number** en 1 despu√©s de cada iteraci√≥n.

Oh, espera, **¬øqu√© es eso de number++? Te lo explico**.

# Incrementando n√∫meros con ++

El operador **++** nos permite incrementar el valor de una variable n√∫mero en 1. Por ejemplo, si tenemos la variable **i** con el valor **5**, **i++** incrementar√≠a el valor de **i** en 1, es decir, **i** pasar√≠a a valer **6**.

``` javascript
let i = 5
i++
console.log(i) // -> 6
```

Es una forma abreviada de escribir **i = i + 1**. Y, como ves, es la forma m√°s t√≠pica de usar en bucles como **for** para no tener que escribir **i = i + 1** cada vez.

# Iterando al rev√©s

El m√©todo **for** en JavaScript tambi√©n se puede utilizar para iterar al rev√©s Para ello, se utiliza la sintaxis **i--** en la secci√≥n de actualizaci√≥n del bucle en lugar de **i++**.

La sintaxis del m√©todo for para iterar en reversa es la siguiente:

``` javascript
for (let i = 10; i >= 0; i--) {
  if (i === 0) {
    console.log('¬°Despegue üöÄ!')
  } else {
    console.log('Faltan ' + i + ' segundos')
  }
}
```

# Llevando m√°s all√° el bucle for

Aunque siempre los ejemplos con **for** son los mismos, ten en cuenta que puedes hacer cualquier cosa en la inicializaci√≥n, condici√≥n y actualizaci√≥n. Podr√≠as, por ejemplo, usar dos variables a la vez.

``` javascript
for (let i = 0, j = 5; i < 5; i++, j--) {
  console.log(i, j);
}
```

La coma **,** nos permite declarar dos variables en la inicializaci√≥n y actualizarlas en la actualizaci√≥n. En este caso la **,** es un **operador que evalua cada uno de sus operandos** (de izquierda a derecha) y retorna el valor del √∫ltimo operando.

No es muy com√∫n su uso, pero es bueno saber que existe.

# continue y break

Al igual que en **while**, **for** tambi√©n tiene las palabras reservadas **continue** y **break** para controlar el flujo de ejecuci√≥n del bucle.

Recuerda que **continue** se usa para saltar a la siguiente iteraci√≥n del bucle y **break** para salir del bucle.

Ejemplo:

``` javascript
for (let i = 0; i < 10; i++) {
  const esPar = i % 2 === 0
  if (esPar) {
    continue
  }

  // Solo mostramos este consola.log si es impar
  console.log(i)

  // Salimos del bucle al llegar al 7
  if (i === 7) {
    break
  }
}
```

# Bucles anidados con for

Imagina que quieres crear **la tabla de multiplicar del 1 al 10**. Para ello, necesitas un bucle que itere del 1 al 10 y, dentro de ese bucle, otro bucle que itere del 1 al 10. Esto se puede hacer con dos bucles **for** anidados (uno dentro del otro).

``` javascript
for (let i = 1; i <= 10; i++) {
  for (let j = 1; j <= 10; j++) {
    const resultado = i * j
    console.log(i + ' x ' + j + ' = ' + resultado)
  }
}
```

# Quiz

:::{.question}
¬øCu√°l es la sintaxis correcta para crear un bucle for en JavaScript?

:::{.choices}
:::{.choice}
![](images/paste-42.png)
:::

::: {.choice .correct-choice}
![](images/paste-44.png)
:::
:::
:::

:::{.question}
¬øCu√°ntas veces veremos el mensaje "Hola" en consola?

``` javascript
for (let i = 0; i < 10 && i !== 3; i++) {
  console.log('Hola')
}
```

:::{.choices}
:::{.choice}
10 veces
:::

:::{.choice}
4 veces
:::

::: {.choice .correct-choice}
3 veces
:::
:::
:::

# Switch

En JavaScript, la sentencia **switch** es una estructura de control que nos permite ejecutar diferentes bloques de c√≥digo dependiendo del valor de una **expresi√≥n**. Esta estructura es √∫til cuando queremos realizar diferentes acciones basadas en una √∫nica variable.

# Sintaxis

La sentencia switch eval√∫a una expresi√≥n, comparando el valor con los diferentes casos que le hemos definido. Si hay coincidencia ejecuta el bloque de c√≥digo asociado. Para ello, se utiliza la sentencia **break** para separar cada caso y evitar que se sigan evaluando el resto de casos.

``` javascript
switch (expresi√≥n) {
  case valor1:
    // c√≥digo a ejecutar si la expresi√≥n coincide con valor1
    break

  case valor2:
    // c√≥digo a ejecutar si la expresi√≥n coincide con valor2
    break
  default:
    // c√≥digo a ejecutar si la expresi√≥n no coincide con ning√∫n valor
    break
}
```

::: {.callout-tip}
La condici√≥n de **default** es opcional. No es obligatorio que la uses si no la necesitas. Es como el **else** de las condiciones **if**.
:::

Por ejemplo si queremos mostrar un mensaje diferente dependiendo del d√≠a de la semana:

``` javascript
const dia = "lunes"

switch (dia) {
  case "lunes":
    console.log("¬°Hoy es lunes! üò¢")
    break

  default:
    console.log("No es lunes, YAY! üöÄ")
    break
}
```

Vamos a hacer esto un poco m√°s interesante. En JavaScript podemos recuperar la informaci√≥n de la hora y la fecha usando el objeto **Date**. Este objeto tiene un m√©todo llamado **getDay()** que nos devuelve el d√≠a de la semana en formato num√©rico, siendo 0 el domingo y 6 el s√°bado.

::: {.callout-tip}
Igual que **console** es un objeto. Tambi√©n **Date** lo es. Un objeto en JavaScript no es muy diferente a un objeto en la vida real. Tiene propiedades y funciones que podemos usar. En este caso, **getDay()** es una funci√≥n que nos devuelve el d√≠a de la semana.
:::

``` javascript
const dia = new Date().getDay()

// segun el dia de la semana, mostramos un mensaje diferente
switch (dia) {
  case 0:
    console.log("¬°Hoy es domingo! üò¥")
    break
  case 1:
    console.log("¬°Nooo, es lunes! üò¢")
    break
  case 2:
    console.log("¬°Hoy es martes! ü•µ")
    break
  case 3:
    console.log("¬°Hoy es mi√©rcoles! ü§ì")
    break
  default:
    console.log("Se acerca el fin de! üöÄ")
    break
}
```

# switch vs if

Muchas veces ver√°s que puedes escribir el mismo c√≥digo usando **switch** o **if**. El ejemplo anterior con un **if**:

``` javascript
const dia = new Date().getDay()

if (dia === 0) {
  console.log("¬°Hoy es domingo! üò¥")
} else if (dia === 1) {
  console.log("¬°Nooo, es lunes! üò¢")
} else if (dia === 2) {
  console.log("¬°Hoy es martes! ü•µ")
} else if (dia === 3) {
  console.log("¬°Hoy es mi√©rcoles! ü§ì")
} else {
  console.log("Se acerca el fin de! üöÄ")
}
```

A veces es m√°s f√°cil de leer con **switch** y otras con **if**. ¬°Depende de ti! Aunque m√°s adelante, en el curso, veremos alternativas a **switch** usando algunas estructuras de datos.

# Agrupando cases

En ocasiones, queremos que varios casos ejecuten el mismo c√≥digo. En lugar de repetir el mismo c√≥digo en cada caso, podemos agruparlos usando el mismo **case** para cada uno de ellos.

``` javascript
const dia = new Date().getDay()

switch (dia) {
  case 0:
  case 6:
    console.log("¬°Hoy es fin de semana! ü•≥")
    break
  case 1:
  case 2:
  case 3:
  case 4:
    console.log("¬°Nooo, a trabajar! üò¢")
    break
  case 5:
    console.log("¬°Hoy es viernes! ü§ì")
    break
}
```

Como ves, en este caso, tampoco estamos usando el **default**. Como te comentaba antes, es totalmente opcional, no tienes por qu√© usarlo siempre.

# ¬°No olvides el break!

Es muy importante que no te olvides de poner el **break** al final de cada caso. Si no lo pones, se ejecutar√°n todos los casos que vengan despu√©s del que coincide. Por ejemplo:

``` javascript
// ‚ùå Este c√≥digo no es correcto
// Lo muestro para que veas qu√© pasa
// si no pones break en tus casos
const dia = new Date().getDay()

switch (dia) {
  case 0:
    console.log("¬°Hoy es domingo! üò¥")
  case 1:
    console.log("¬°Nooo, es lunes! üò¢")
  case 2:
    console.log("¬°Hoy es martes! ü•µ")
  case 3:
    console.log("¬°Hoy es mi√©rcoles! ü§ì")
  default:
    console.log("Se acerca el fin de! üöÄ")
}
```

Si hoy es martes (**2**), se ejecutar√°n todos los casos despu√©s de ese, ya que no hay ning√∫n **break** que lo impida. Por lo tanto, el resultado en consola ser√≠a:

``` bash
¬°Hoy es martes! ü•µ
¬°Hoy es mi√©rcoles! ü§ì
Se acerca el fin de! üöÄ
```

# El patr√≥n switch(true)

Existe un patr√≥n que se usa a veces con **switch** que es **switch(true)**. Esto es, en lugar de evaluar una expresi√≥n, eval√∫a una condici√≥n ignorando por completo el valor de la expresi√≥n.

Por ejemplo:

``` javascript
let edad = 25;

switch(true) {
  case (edad >= 18 && edad < 25):
    console.log("Eres mayor de edad y eres joven");
    break;
  case (edad >= 25 && edad < 40):
    console.log("Eres mayor de edad y est√°s en plena madurez");
    break;
  case (edad >= 40):
    console.log("Eres mayor de edad y est√°s en la mejor edad");
    break;
  default:
    console.log("Eres menor de edad");
}
```

Es un patr√≥n algo m√°s avanzado y es una alternativa a usar **if** y **else if**. En mi opini√≥n, es m√°s dif√≠cil de leer, ya que puede crear un poco de confusi√≥n. Pero es bueno que lo conozcas por si te lo encuentras en alg√∫n sitio.

# Quiz

:::{.question}
¬øCu√°l es la funci√≥n de la palabra reservada default en una declaraci√≥n switch en JavaScript?

:::{.choices}
::: {.choice .correct-choice}
Es el caso que se ejecuta cuando se produce un error en el switch
:::

:::{.choice}
Es el caso que se ejecuta cuando ninguno de los casos coincide con la expresi√≥n
:::

:::{.choice}
Es un caso opcional que se puede utilizar para realizar acciones adicionales
:::
:::
:::

:::{.question}
¬øQu√© problema tiene este c√≥digo?

``` javascript
switch (day) {
  case 0:
    console.log('Hoy es Domingo')
  case 1:
    console.log('Hoy es Lunes')
  case 2:
    console.log('Hoy es Martes')
  default:
    console.log('Es otro d√≠a')
}
```

:::{.choices}
:::{.choice}
No tiene ning√∫n problema
:::

:::{.choice}
Se repite mucho c√≥digo
:::

::: {.choice .correct-choice}
Falta usar break en cada caso
:::
:::
:::

:::{.question}
¬øSe puede hacer esto con switch?

``` javascript

let x = 5

switch (true) {
  case (x < 0):
    console.log('x es negativo')
    break
  case (x > 0):
    console.log('x es positivo')
    break
  default:
    console.log('x es cero')
}
```

:::{.choices}
:::{.choice}
No, porque no se puede usar una expresi√≥n booleana en el switch
:::

:::{.choice}
No, porque no se puede saber el valor de x dentro
:::

::: {.choice .correct-choice}
S√≠, no hay ning√∫n problema
:::
:::
:::

# Tu primera funci√≥n

Las *funciones* son uno de los conceptos m√°s importantes en *JavaScript* y casi cualquier lenguaje de programaci√≥n.

**Una funci√≥n es un bloque de c√≥digo que realiza una tarea espec√≠fica cuando se llama**. Puedes pensar en una funci√≥n como en un microondas: le das algo para cocinar, le pasas algunos par√°metros (como el tiempo y la potencia) y luego hace su trabajo y te devuelve el resultado.

En JavaScript, las funciones se pueden definir de varias maneras, pero la forma m√°s com√∫n y b√°sica es mediante la palabra clave **function**. Esta es tu primera funci√≥n:

``` javascript
function saludar() {
  console.log('Hola Diego')
}
```

Como ves, declarar una funci√≥n consiste de:

-   La palabra reservada **function** que indica que estamos definiendo una funci√≥n.

-   El nombre de la funci√≥n, en este caso **saludar**. Normalmente usamos verbos para nombrar funciones, ya que son acciones que realizan.

-   Un par de par√©ntesis **( )** despu√©s del nombre. Pueden contener par√°metros. En este caso, no tenemos ninguno.

-   Un bloque de c√≥digo entre llaves **{ }**. En este caso, solo tenemos una l√≠nea de c√≥digo, pero podr√≠amos tener muchas m√°s.

Nuestra funci√≥n ahora mismo no devuelve nada pero cada vez que la llamemos, imprimir√° **Hola** en la consola.

::: {.callout-tip}
Las funciones pueden devolver un resultado (un n√∫mero, una cadena de texto, un booleano...) o puede no devolver nada. En ese caso, la funci√≥n devuelve **undefined**.
:::

saludar() // -\> Hola Diego saludar() // -\> Hola Diego saludar() // -\> Hola Diego

# Devolviendo un resultado

Las funciones pueden devolver un resultado. Para ello, utilizamos la palabra reservada **return** y despu√©s el valor que queremos devolver:

``` javascript
function sumar() {
  return 1 + 1
}
```

Ahora, cada vez que llamemos a la funci√≥n **sumar**, nos devolver√° el resultado de la suma:

``` javascript
// podemos guardar el resultado en una variable
const resultado = sumar()

// o ver en consola directamente el resultado
console.log(sumar()) // -> 2
```

::: {.callout-tip}
En la siguiente clase ver√°s c√≥mo puedes pasar par√°metros a una funci√≥n para hacerlas todav√≠a m√°s interesantes y reutilizables.
:::

::: {.callout-tip}
Recuerda, si no utilizamos **return**, la funci√≥n devolver√° **undefined**.
:::

# Una funci√≥n realmente √∫til

La funci√≥n **saludar** y **sumar** no parecen muy √∫tiles, pero con lo poco que sabemos ya podemos hacer cosas m√°s productivas. Por ejemplo, podemos crear una funci√≥n que nos devuelva un n√∫mero aleatorio del 1 al 10.

Para ello vamos a descubrir **Math**, un objeto incorporado en JavaScript que tiene propiedades y m√©todos para constantes y funciones matem√°ticas. Vamos a ver dos m√©todos que nos van a ser muy √∫tiles:

-   **Math.random():** devuelve un n√∫mero aleatorio entre 0 y 1, con decimales.
-   **Math.floor():** redondea un n√∫mero hacia abajo.

::: {.callout-tip}
**Math.random** es parecido a **console.log**, en el sentido que son m√©todos que JavaScript incorpora de serie y que podemos utilizar en cualquier punto de nuestro programa.
:::

Sabiendo esto, podr√≠amos crear una **funci√≥n que nos devuelva un n√∫mero aleatorio del 1 al 10**:

``` javascript
function getRandomNumber() {
  // recuperamos un n√∫mero aleatorio entre 0 y 1
  const random = Math.random() // por ejemplo: 0.6803487380457318

  // lo multiplicamos por 10 para que est√© entre 0 y 10
  const multiplied = random * 10 // -> 6.803487380457318

  // redondeamos hacia abajo para que est√© entre 0 y 9
  const rounded = Math.floor(multiplied) // -> 6

  // le sumamos uno para que est√© entre 1 y 10
  const result = rounded + 1 // -> 7

  // devolvemos el resultado
  return result
}
```

¬°Bueno! Hay que ver cuantas cosas has puesto en pr√°ctica en muy pocas l√≠neas de c√≥digo: *constantes*, *variables*, *operadores*, comentarios... ¬°y todo en una funci√≥n!

¬øSabes lo mejor? Que **esa funci√≥n va a acompa√±arte durante toda tu carrera**. Es muy com√∫n necesitar crear un n√∫mero aleatorio en un programa, as√≠ que es muy √∫til tener una funci√≥n que lo haga por nosotros.

::: {.callout-tip}
En la funci√≥n hemos utilizado varias variables para ir guardando los resultados intermedios. Podr√≠amos haberlo hecho todo en una sola l√≠nea, pero as√≠ es m√°s f√°cil de entender.
:::

# Quiz

:::{.question}
¬øQu√© es una funci√≥n en JavaScript?

:::{.choices}
:::{.choice}
Algo que se puede hacer con JavaScript de base
:::

::: {.choice .correct-choice}
Un bloque de c√≥digo que realiza una tarea espec√≠fica cuando se llama
:::

:::{.choice}
Una variable que almacena informaci√≥n
:::
:::
:::

:::{.question}
¬øCu√°l es la sintaxis b√°sica de una funci√≥n en JavaScript?

:::{.choices}
::: {.choice .correct-choice}
function nombreFuncion() { ... }
:::

:::{.choice}
const function() { ... }
:::

:::{.choice}
fn nombreFuncion() { ... }
:::
:::
:::

:::{.question}
¬øQu√© devuelve una funci√≥n declarada con function si no tiene una declaraci√≥n de retorno expl√≠cita?

:::{.choices}
:::{.choice}
null
:::

::: correct-choice
undefined
:::

:::{.choice}
0
:::
:::
:::

# Par√°metros

Hasta ahora hemos visto como crear funciones y c√≥mo llamarlas. Pero para poder desbloquear todo el potencial de las funciones, **necesitamos que puedan recibir par√°metros**. Esto es, que su comportamiento pueda cambiar seg√∫n los datos que le pasemos.

Imagina que queremos que nuestra funci√≥n de **saludar**, pueda saludar a cualquier persona, no solo a Miguel. Para ello, podemos hacer que la funci√≥n acepte un par√°metro, que ser√° el nombre de la persona a la que queremos saludar.

``` javascript
function saludar(nombre) {
  console.log("Hola " + nombre)
}
```

Ahora, cada vez que llamemos a la funci√≥n, podemos pasarle una cadena de texto:

``` javascript
saludar('Diego') // -> Hola Diego
saludar('Itziar') // -> Hola Itziar
saludar('Carmen') // -> Hola Carmen
```

Ya ves como algo que parece tan sencillo, tiene un poder enorme. **Las funciones son la base de la programaci√≥n y nos permiten crear programas complejos a partir de peque√±as piezas**.

Por ejemplo, para crear una calculadora, deber√≠amos empezar a crear funciones que realicen las operaciones b√°sicas. En este caso necesitaremos parametrizar la funci√≥n para que acepte los dos n√∫meros para hacer la operaci√≥n.

``` javascript
function sumar(a, b) {
  return a + b
}

function restar(a, b) {
  return a - b
}
```

Y ya podr√≠amos usarlas:

``` javascript
const resultadoSuma = sumar(2, 3)
console.log(resultadoSuma) // -> 5

const resultadoResta = restar(5, 2)
console.log(resultadoResta) // -> 3
```

# Par√°metros y argumentos

En el ejemplo anterior, hemos visto que podemos pasarle valores a la funci√≥n cuando la llamamos. A estos valores se les llama **argumentos**. Y a los valores que recibe la funci√≥n, se les llama **par√°metros**.

``` javascript
// la funci√≥n suma tiene dos par√°metros: a y b
function sumar(a, b) {
  return a + b
}

// cuando llamamos a la funci√≥n, le pasamos dos argumentos: 2 y 3
const resultadoSuma = sumar(2, 3)
```

Normalmente mucha gente confunde los t√©rminos y usa par√°metro para referirse a los argumentos. Pero es importante que sepas diferenciarlos, porque son cosas distintas.

# El orden de los par√°metros importa

Algo muy importante, y un error muy com√∫n al empezar a crear funciones, es olvidar que el orden de los par√°metros importa.

Vamos a crear una funci√≥n que simule un microondas. Le pasaremos el plato, tiempo y potencia. Y nos devolver√° el resultado del plato cocinado.

``` javascript
function cocinarMicroondas(plato, tiempo, potencia) {
  if (plato === 'üê•' && tiempo === 1 && potencia === 5) {
    return 'üçó'
  }

  if (plato === 'ü•ö' && tiempo === 2 && potencia === 3) {
    return 'üç≥'
  }

  return '‚ùå Plato no soportado'
}
```

::: {.callout-tip}
S√≠, puedes hacer un **return** dentro de un condicional. Esto hace que la funci√≥n se detenga y devuelva el valor indicado en el **return**.
:::

Si usamos bien los par√°metros, la funci√≥n funciona correctamente:

``` javascript
const resultado = cocinarMicroondas('üê•', 1, 5)
console.log(resultado) // -> üçó
```

Pero si cambiamos el orden de los par√°metros, la funci√≥n no funciona:

``` javascript
const resultado = cocinarMicroondas(1, 5, 'üê•')
console.log(resultado) // -> '‚ùå Plato no soportado'
```

Esto es porque la funci√≥n espera que el primer par√°metro sea el plato, el segundo el tiempo y el tercero la potencia. **Si cambiamos el orden, podemos tener comportamientos inesperados o errores**.

M√°s adelante veremos una forma en la que podemos evitar este tipo de errores.

# Quiz

:::{.question}
¬øQu√© son los par√°metros de una funci√≥n en JavaScript?

:::{.choices}
::: correct-choice
Valores que espera recibir una funci√≥n al llamarla para usarlos dentro de ella
:::

:::{.choice}
Valores que devuelve una funci√≥n
:::

:::{.choice}
Valores que se declaran dentro de una funci√≥n
:::
:::
:::

:::{.question}
¬øQu√© son los argumentos de una funci√≥n en JavaScript?

:::{.choices}
:::{.choice}
Valores que espera recibir una funci√≥n
:::

::: correct-choice
Valores que se pasan a una funci√≥n al llamarla
:::

:::{.choice}
Lo mismo que los par√°metros
:::
:::
:::

::: question
¬øQu√© pasa si cambiamos el orden de los par√°metros al llamar una funci√≥n?
:::

:::{.choices}
:::{.choice}
La funci√≥n se detiene y no devuelve nada
:::

:::{.choice}
La funci√≥n devuelve undefined
:::

::: correct-choice
Podemos tener comportamientos inesperados o errores
:::
:::
::::::::::::::::::::::::::::::::::::::::::::

# Function Expression

Hasta ahora hemos visto c√≥mo podemos declarar funciones usando la palabra clave **function**.

Sin embargo, existen dos formas m√°s de declarar funciones en JavaScript: function expression y arrow function. En este caso, hablemos de la primera.

# ¬øQu√© es una function expression?

Una **function expression** es una funci√≥n que se asigna a una variable. Por ejemplo:

\`\`\` javascript// esto es una function expression const sum = function (a, b) { return a + b }

// esto es una declaraci√≥n de funci√≥n function sum(a, b) { return a + b }

```         

:::{.callout-tip}
¬°F√≠jate que la **function** no tiene nombre en la **function expression**! Cuando una funci√≥n no tiene nombre se le llama funci√≥n an√≥nima. Aunque en este caso, la funci√≥n est√° asignada a una variable que s√≠ tiene nombre y por eso podremos utilizarla m√°s adelante.
:::

Con la function expression, a la funci√≥n se asigna a la variable **sum**. Esto significa que podemos llamar a la funci√≥n usando el nombre de la variable:

``` javascript
sum(1, 2) // 3
```

El comportamiento es muy similar al de una funci√≥n declarada con la palabra clave **function**. Sin embargo, hay una diferencia muy importante entre ambas que debes conocer: el hoisting.

# Hoisting

El hoisting es un t√©rmino que se usa para describir c√≥mo JavaScript parece que mueve las declaraciones funciones al principio del c√≥digo, de forma que las puedes usar incluso antes de declararlas. Por ejemplo:

``` javascript
sum(1, 2) // 3

function sum(a, b) {
  return a + b
}
```

Aqu√≠ primero usamos la funci√≥n y la declaramos luego. ¬°Y funciona! ¬øC√≥mo puede ser? **¬øNo deber√≠a darnos un error ya que la funci√≥n todav√≠a no existe?**

Lo que est√° pasando es que JavaScript asigna en memoria durante la fase de compilaci√≥n las declaraciones de funciones y por eso al ejecutarse el c√≥digo tiene acceso a esa posici√≥n de memoria a la que se refiere la funci√≥n.

Eso ser√≠a la explicaci√≥n t√©cnica del hoisting, pero si te sirve de ayuda, puedes pensar que es como si JavaScript moviese las declaraciones de funciones al principio del c√≥digo.

# ¬øY qu√© pasa con las function expression?

Pues que no se aplica el hoisting. Por ejemplo:

``` javascript
sum(1, 2) // ‚ùå ReferenceError: sum is not defined

const sum = function (a, b) {
  return a + b
}
```

# Quiz

:::{.question}
¬øQu√© es una function expression en JavaScript?

:::{.choices}
:::{.choice}
Una funci√≥n que se define dentro de otra funci√≥n
:::

:::{.choice}
Una funci√≥n que se declara con la palabra clave "function"
:::

::: correct-choice
Una funci√≥n que se asigna a una variable
:::
:::
:::

:::{.question}
¬øQu√© diferencia hay entre una declaraci√≥n de funci√≥n y una funci√≥n de expresi√≥n en JavaScript?

:::{.choices}
:::{.choice}
S√≥lo la forma en que se declaran
:::

::: {.choice .correct-choice}
El hoisting y c√≥mo se crean
:::

:::{.choice}
El comportamiento al llamarlas
:::
:::
:::

:::{.question}
¬øSe aplica el hoisting a las funciones de expresi√≥n en JavaScript?

:::{.choices}
:::{.choice}
S√≠
:::

::: {.choice .correct-choice}
No
:::
:::
:::

# Funciones flecha

En esta clase vamos a hablar sobre las *funciones flecha*, tambi√©n conocidas como **arrow functions** en ingl√©s.

Las funciones flecha son una forma m√°s concisa de crear funciones en *JavaScript*, y se han vuelto muy populares en los √∫ltimos a√±os debido a su sintaxis simplificada.

La sintaxis b√°sica de una funci√≥n flecha es la siguiente:

``` javascript
const miFuncionFlecha = () => {
  // c√≥digo a ejecutar
}
```

::: {.callout-tip}
Las funciones flecha son siempre **funciones an√≥nimas** y **function expressions**. Esto significa que no tienen nombre y que se asignan a una variable.
:::

En lugar de la palabra clave **function**, utilizamos una flecha **=\>** para definir la funci√≥n. Tambi√©n podemos omitir los par√©ntesis alrededor de los par√°metros si solo tenemos uno:

``` javascript
const saludar = nombre => {
  console.log("Hola " + nombre)
}
```

# Ventajas de las funciones flecha

Las funciones flecha tienen varias **ventajas sobre las funciones regulares en JavaScript**. Algunas son:

-   **Sintaxis m√°s concisa:** la sintaxis de las funciones flecha es m√°s corta y m√°s f√°cil de leer que la sintaxis de las funciones regulares, especialmente cuando se trabaja con funciones de una sola l√≠nea.

-   **Return impl√≠cito:** las funciones flecha puede devolver el valor de la expresi√≥n sin usar la palabra clave **return** cuando son de una sola l√≠nea. Esto hace que las funciones flecha sean a√∫n m√°s cortas y m√°s f√°ciles de leer.

-   **Funciones an√≥nimas m√°s legibles:** las funciones flecha son una forma m√°s legible y concisa de crear funciones an√≥nimas en JavaScript, lo cual puede hacer que nuestro c√≥digo sea m√°s f√°cil de entender.

::: {.callout-tip}
Recuerda, las funciones an√≥nimas son funciones que no tienen nombre. Son como las que vimos en la clase anterior.
:::

# Return impl√≠cito

Cuando una funci√≥n flecha tiene una sola expresi√≥n, podemos omitir las llaves **{ }** y la palabra clave return para hacerla a√∫n m√°s corta. Esto se conoce como **return impl√≠cito**. Vamos a pasar una funci√≥n regular a una funci√≥n flecha y vamos a ver c√≥mo se ve finalmente con return impl√≠cito:

``` javascript
// Declaraci√≥n de funci√≥n regular
function sumar(a, b) {
  return a + b
}

// Funci√≥n flecha
const sumarFlecha = (a, b) => {
  return a + b
}

// Funci√≥n flecha con return impl√≠cito
const sumarFlecha = (a, b) => a + b
```

Como podemos ver, la funci√≥n flecha con return impl√≠cito es mucho m√°s corta y f√°cil de leer que la funci√≥n regular. Esto es especialmente √∫til cuando estamos trabajando con funciones de una sola l√≠nea.

# Quiz

:::{.question}
¬øQu√© son las funciones flecha en JavaScript?

:::{.choices}
::: correct-choice
Una forma m√°s concisa de crear funciones en JavaScript
:::

:::{.choice}
Una forma m√°s compleja de crear funciones en JavaScript
:::

:::{.choice}
Una t√©cnica para evitar el uso de funciones en JavaScript
:::
:::
:::

:::{.question}
¬øCu√°l es una de las ventajas de las funciones flecha?

:::{.choices}
::: {.choice .correct-choice}
Return impl√≠cito
:::

:::{.choice}
Son m√°s r√°pidas
:::

:::{.choice}
Funciones an√≥nimas
:::
:::
:::

:::{.question}
¬øQu√© devuelve la siguiente funci√≥n flecha?

``` javascript
const sum = (a, b) => { a + b }
sum(2, 3)
```

:::{.choices}
:::{.choice}
5
:::

::: {.choice .correct-choice}
undefined
:::

:::{.choice}
Error
:::
:::
:::

# Recursividad

La recursividad es una t√©cnica de programaci√≥n que consiste en que una funci√≥n se llame a s√≠ misma.

Pero claro, si una funci√≥n se llama a s√≠ misma, ¬øcu√°ndo termina? ¬øc√≥mo se evita que se llame infinitamente? Con una condici√≥n base.

# Ejemplo de recursividad

Vamos a crear una funci√≥n que cuente desde un n√∫mero hasta cero.

``` javascript
function cuentaAtras(numero) {
  // Condici√≥n base: Si el n√∫mero que recibe es
  // menor de 0 entonces salimos de la funci√≥n
  if (numero < 0) { return }

  // Si el n√∫mero era mayor o igual a 0, lo mostramos
  console.log(numero)

  // Y llamamos a la funci√≥n con el n√∫mero anterior
  cuentaAtras(numero - 1)
}
```

Si llamamos a la funci√≥n con el n√∫mero 3, el resultado ser√°:

``` javascript
cuentaAtras(3)
// -> 3
// -> 2
// -> 1
// -> 0
```

La ejecuci√≥n la ver√≠amos as√≠:

``` javascript
cuentaAtras(3) -> (muestra 3)
               \ 
          cuentaAtras(2) -> (muestra 2)
                       \
                  cuentaAtras(1) -> (muestra 1)
                               \
                          cuentaAtras(0) -> (muestra 0)
                                        \
                                   cuentaAtras(-1) -> salida
```

::: {.callout-tip}
¬°Cuidado! Si no ponemos la condici√≥n base, la funci√≥n se llamar√° infinitamente y el navegador se quedar√° bloqueado. Cuando hacemos recursividad SIEMPRE hay que tener una condici√≥n que haga que la funci√≥n salga de s√≠ misma.
:::

# Usando recursividad y devolviendo un valor

La recursividad se usa muchas veces para solucionar algoritmos. Por ejemplo, vamos a crear una funci√≥n que calcule el factorial de un n√∫mero.

::: {.callout-tip}
El factorial de un n√∫mero es el resultado de multiplicar ese n√∫mero por todos los anteriores hasta llegar a 1. Por ejemplo, el factorial de 5 es 5 \* 4 \* 3 \* 2 \* 1 = 120
:::

\`\`\` javascriptfunction factorial(n) { // Condici√≥n base: Si el n√∫mero es 0 o 1, devolvemos 1 // y no llamamos a la funci√≥n de nuevo if (n === 0 \|\| n === 1) { return 1 } else { // Si el n√∫mero es mayor que 1, llamamos a la funci√≥n return n \* factorial(n - 1) } }

console.log(factorial(5)) // Resultado: 120 console.log(factorial(3)) // Resultado: 6

```         

```javascript
factorial(3) --------------------------> 6
        \ 
  3 * factorial(2) ---------------> 6
          \
    2 * factorial(1) -----------> 2
            \
      1 * factorial(0) -------> 1
```

La recursividad es un concepto que cuesta entender al principio. ¬øUna funci√≥n que se llama a s√≠ misma? A mucha gente le vuela la cabeza.

¬øQu√© te recomiendo para aprenderlo? Primero, entiende los ejemplos que hemos hecho y dibuja en un papel c√≥mo se ejecutan las funciones.

Despu√©s, haz estos ejercicios de recursividad:

Escribe una funci√≥n que calcule la suma de los primeros n n√∫meros enteros de forma recursiva. Por ejemplo: **suma(3) -\> 1 + 2 + 3 = 6**

Escribe una funci√≥n que calcule la sucesi√≥n de Fibonacci de forma recursiva. La sucesi√≥n de Fibonacci es una serie de n√∫meros que empieza por 0 y 1 y cada n√∫mero es la suma de los dos anteriores. Por ejemplo: **fibonacci(6) -\> 8 (0, 1, 1, 2, 3, 5, 8)**

# Quiz

:::{.question}
¬øQu√© es la recursividad en programaci√≥n?

:::{.choices}
::: {.choice .correct-choice}
Una t√©cnica de programaci√≥n que consiste en que una funci√≥n se llame a s√≠ misma
:::

:::{.choice}
Un tipo de condici√≥n que permite evitar que una funci√≥n se llame infinitamente
:::

:::{.choice}
Un error que ocurre cuando una funci√≥n se llama a s√≠ misma
:::
:::
:::

:::{.question}
¬øQu√© es la condici√≥n base en la recursividad?

:::{.choices}
::: {.choice .correct-choice}
Una condici√≥n que permite evitar que una funci√≥n se llame infinitamente
:::

:::{.choice}
Una condici√≥n que permite que una funci√≥n se llame infinitamente
:::

:::{.choice}
Una condici√≥n que permite que una funci√≥n se llame infinitamente
:::
:::
:::

:::{.question}
¬øQu√© sucede si no se define una condici√≥n base en una funci√≥n recursiva?

:::{.choices}
::: {.choice .correct-choice}
La funci√≥n se puede llamar infinitamente y el programa se bloquea
:::

:::{.choice}
La funci√≥n deja de llamarse despu√©s de un cierto n√∫mero de iteraciones
:::

:::{.choice}
La funci√≥n devuelve un valor incorrecto
:::
:::
:::

:::{.question}
¬øCu√°l es la salida de este c√≥digo al pasar como argumento el n√∫mero 3?

``` javascript
function recursive(n) {
  if (n === 0) {
    return 0
  } else {
    return n + recursive(n - 1)
  }
}
```

:::{.choices}
:::{.choice}
0
:::

::: {.choice .correct-choice}
6
:::

:::{.choice}
4
:::
:::
:::

# Arrays: colecciones de elementos

Hasta ahora hemos visto algunos tipos de datos. Cadenas de texto, n√∫meros, booleanos... Pero... **¬øQu√© pasa si queremos tener una colecci√≥n de ellos?** En *JavaScript* tenemos los **arrays**.

# Declaraci√≥n y asignaci√≥n de arrays

Para declarar un array usamos los corchetes **\[ \]** y dentro los elementos de la colecci√≥n separados por comas **,**.

Por ejemplo, para crear una colecci√≥n de n√∫meros del 1 al 5:

``` javascript
[1, 2, 3, 4, 5]
```

Los elementos de un array pueden ser de cualquier tipo, incluso otros arrays.

``` javascript
[1, 2, 3, 4, [5, 6, 7, 8, 9]]
```

Y, aunque no siempre sea recomendable, puedes mezclar tipos de datos dentro:

``` javascript
['uno', 2, true, null, undefined]
```

Para asignar un array a una variable, lo hacemos igual que con los otros tipos de datos:

``` javascript
const numbers = [1, 2, 3, 4, 5]
let names = ['Dani', 'Miguel', 'Maria']
```

# Acceso a los elementos de un array

Para acceder a los elementos de un array usamos los corchetes **\[ \]** y dentro el √≠ndice del elemento que queremos acceder. **Los √≠ndices empiezan en 0**.

``` javascript
const numbers = [1, 2, 3, 4, 5]

console.log(numbers[0]) // 1
console.log(numbers[2]) // 3
```

::: {.callout-tip}
El √≠ndice es la posici√≥n del elemento dentro del array. El primer elemento tiene √≠ndice 0, el segundo √≠ndice 1, el tercero √≠ndice 2...
:::

Si intentamos acceder a un elemento que no existe, nos devolver√° **undefined**.

``` javascript
const numbers = [1, 2, 3, 4, 5]

console.log(numbers[10]) // undefined
```

Puedes usar variables para acceder a los elementos de un array.

``` javascript
const numbers = [1, 2, 3, 4, 5]
let index = 2

console.log(numbers[index]) // 3
```

# Modificar elementos de un array

Igual que podemos acceder a los elementos de un array, podemos modificarlos.

``` javascript
const numbers = [1, 2, 3, 4, 5]

numbers[0] = 10
numbers[2] = 30

console.log(numbers) // [10, 2, 30, 4, 5]
```

::: {.callout-tip}
¬øC√≥mo es que pese a que hemos indicado que es una constante **const** podemos modificar el Array? Aunque hay una explicaci√≥n mucho m√°s larga, que veremos m√°s adelante, la respuesta corta es que **const** s√≥lo impide que se reasigne el valor de la variable, no que se modifique el valor en s√≠.
:::

# Quiz

:::{.question}
¬øQu√© se imprimir√° en la consola al ejecutar el siguiente c√≥digo:

``` javascript
const numbers = [1, 2, 3, 4, 5]
numbers[0] = 10
numbers[2] = 30
console.log(numbers)
```

:::{.choices}
:::{.choice}
\[1, 2, 3, 4, 5\]
:::

::: {.choice .correct-choice}
\[10, 2, 30, 4, 5\]
:::

:::{.choice}
Error de asignaci√≥n a una constante
:::
:::
:::

# M√©todos y propiedades de Array

Los arrays de JavaScript tienen una serie de m√©todos y propiedades que nos permiten trabajar con ellos de forma sencilla.

::: {.callout-tip}
Un m√©todo es una funci√≥n que se ejecuta sobre un objeto. Una propiedad es una variable que pertenece a un objeto. En este caso, el objeto es un array.
:::

# La longitud de un array

Puedes conocer la longitud de una colecci√≥n de elementos usando la propiedad **.length**:

``` javascript
const frutas = ["manzana", "pera", "pl√°tano", "fresa"]
console.log(frutas.length) // 4
```

Tambi√©n puedes cortar su longitud asignando un nuevo valor a la propiedad **.length**:

``` javascript
const frutas = ["manzana", "pera", "pl√°tano", "fresa"]
frutas.length = 2

console.log(frutas) // ["manzana", "pera"]
console.log(frutas.length) // 2
```

# M√©todos de arrays

Cuando trabajamos con colecciones de elementos, vamos a querer hacer cosas con ellos. Por ejemplo: a√±adir un elemento, eliminarlo, buscarlo, etc. Para ello, los arrays tienen una serie de m√©todos que nos permiten hacer estas operaciones:

# .push()

El m√©todo **.push()** nos permite a√±adir un elemento al final de un array:

``` javascript
const frutas = ["pl√°tano", "fresa"]
frutas.push("naranja")
console.log(frutas) // ["pl√°tano", "fresa", "naranja"]
```

Adem√°s, el m√©todo **.push()** devuelve la nueva longitud del array:

``` javascript
const frutas = ["pl√°tano", "fresa"]
console.log(frutas.length) // 2

const newLength = frutas.push("naranja")
console.log(newLength) // 3
console.log(frutas) // ["pl√°tano", "fresa", "naranja"]
```

# .pop()

El m√©todo **.pop()** elimina y devuelve el √∫ltimo elemento de un array:

``` javascript
const frutas = ["pl√°tano", "fresa", "naranja"]
const ultimaFruta = frutas.pop()

console.log(frutas) // ["pl√°tano", "fresa"]
console.log(ultimaFruta) // "naranja"
```

# .shift()

El m√©todo **.shift()** elimina y devuelve el primer elemento de un array. Es lo mismo que .pop(), pero con el primer elemento en lugar del √∫ltimo:

``` javascript
const frutas = ["pl√°tano", "fresa", "naranja"]
const primeraFruta = frutas.shift()

console.log(frutas) // ["fresa", "naranja"]
console.log(primeraFruta) // "pl√°tano"
```

# .unshift()

El m√©todo **.unshift()** a√±ade un elemento al principio de un array. Es lo mismo que **.push()**, pero con el primer elemento en lugar del √∫ltimo:

``` javascript
const frutas = ["pl√°tano", "fresa", "naranja"]
frutas.unshift("manzana")

console.log(frutas) // ["manzana", "pl√°tano", "fresa", "naranja"]
```

# Concatenar arrays

Podemos concatenar dos arrays usando el m√©todo **concat()**.

``` javascript
const numbers = [1, 2, 3]
const numbers2 = [4, 5]

const allNumbers = numbers.concat(numbers2)

console.log(allNumbers) // [1, 2, 3, 4, 5]
```

Otra forma de concatenar arrays es usando el operador **...** (spread operator). Este operador propaga los elementos de un array. As√≠ que podr√≠amos hacer lo siguiente:

``` javascript
const numbers = [1, 2, 3]
const numbers2 = [4, 5]

//                    1, 2, 3        4, 5                     
const allNumbers = [...numbers, ...numbers2]

console.log(allNumbers) // [1, 2, 3, 4, 5]
```

M√°s adelante hablaremos m√°s de este operador y sus diferentes utilidades.

# Actividad Pr√°ctica

En un restaurante se reciben pedidos de comida a domicilio. Vamos a escribir una funci√≥n **procesarPedido** que recibe un pedido, que es un array de platos. Lo que debemos hacer es:

-   El primer elemento lo sacamos del array, ya que es el nombre del cliente.
-   A√±adimos al principio del array la cadena de texto "bebida", ya que es una promoci√≥n que tenemos.
-   Despu√©s a√±adimos al final del array el nombre del usuario que sacamos antes.

Recuerda que debes devolver el array modificado:

``` javascript
function procesarPedido(pedidos) {
  // tu c√≥digo aqu√≠
}
```

<details>

<summary>Ver soluci√≥n</summary>

``` javascript
function procesarPedido(pedidos) {
  const nombreCliente = pedidos.shift()
  pedidos.unshift("bebida")
  pedidos.push(nombreCliente)

  return pedidos
}
```

</details>

# Iteraci√≥n de Arrays en JavaScript

Ya hemos visto en clases anteriores c√≥mo podemos crear bucles con **for** y **while**. Con estas estructuras de control, y una nueva que veremos en este clase, podemos tambi√©n recorrer cada uno de los elementos de un array.

Adem√°s, veremos como los propios arrays tienen un m√©todo **.forEach** que nos permite ejecutar una funci√≥n para cada uno de los elementos del array.

# Bucle while

El bucle **while** vimos que permit√≠a ejecutar un bloque de c√≥digo mientras una condici√≥n era verdadera. En el caso de la iteraci√≥n de arrays, la condici√≥n generalmente se basa en el √≠ndice del elemento.

Podemos, por ejemplo, crear una variable con **let** para guardar un puntero al √≠ndice del elemento que estamos iterando. En cada iteraci√≥n, podemos incrementar el valor de la variable en 1, para que en la siguiente iteraci√≥n se imprima el siguiente elemento.

``` javascript
let frutas = ['üçé', 'üçå', 'üçì']
let i = 0 // lo usaremos como √≠ndice

while (i < frutas.length) {
  console.log(frutas[i]) // imprime el elemento en la posici√≥n i
  i++ // incrementamos el √≠ndice en 1 para la siguiente iteraci√≥n
}
```

# Bucle for

El bucle **for** nos permit√≠a ejecutar un bloque de c√≥digo un n√∫mero determinado de veces. En el caso de la iteraci√≥n de arrays, podemos usarlo para recorrer cada uno de los elementos del array, usando la longitud del array como condici√≥n.

``` javascript
let frutas = ['üçé', 'üçå', 'üçì']

for (let i = 0; i < frutas.length; i++) {
  console.log(frutas[i]) // imprime el elemento en la posici√≥n i
}
```

Tambi√©n podr√≠as recorrer el array en orden inverso, empezando desde el √∫ltimo elemento hasta el primero, usando **i--** en lugar de **i++**.

``` javascript
let frutas = ['üçé', 'üçå', 'üçì']

for (let i = frutas.length - 1; i >= 0; i--) {
  console.log(frutas[i]) // imprime el elemento en la posici√≥n i
}
```

# Bucle for...of

Adem√°s de **while** y **for**, existe otra estructura de control que nos permite iterar sobre los elementos de un array: **for...of**. Esta estructura de control es m√°s simple que **for**, ya que no necesitamos crear una variable para guardar el √≠ndice del elemento que estamos iterando.

Es mucho m√°s sencilla y f√°cil de entender:

``` javascript
let frutas = ['üçé', 'üçå', 'üçì']

for (let fruta of frutas) {
  console.log(fruta) // imprime el elemento en la posici√≥n i
}
```

::: {.callout-tip}
Como ves, hay algunas limitaciones en el uso de **for...of**. Por ejemplo, no podemos usarlo para recorrer un array en orden inverso y tampoco tenemos acceso al √≠ndice del elemento que estamos iterando.
:::

# El m√©todo array.forEach()

Ya hemos visto en la clase anterior que los arrays tienen m√©todos que nos permiten realizar operaciones sobre ellos, como a√±adir elementos o eliminarlos. Pero tiene muchos m√°s m√©todos que iremos viendo que nos ayuda a trabajar con ellos.

Uno de esos m√©todos es **array.forEach()**, que nos permite ejecutar una **function** para cada uno de los elementos del array. Esta funci√≥n recibe como par√°metros el elemento que se est√° iterando en ese momento, el √≠ndice del elemento y el propio array.

``` javascript
let frutas = ['üçé', 'üçå', 'üçì']

frutas.forEach(function (fruta, index, originalArray) {
  console.log(fruta) // imprime el elemento en la posici√≥n i
})
```

Usando una **arrow function** e indicando s√≥lo los par√°metros que necesitamos de nuestra funci√≥n podemos simplificarlo a√∫n m√°s:

``` javascript
let frutas = ['üçé', 'üçå', 'üçì']

frutas.forEach((fruta) => {
  console.log(fruta) // imprime el elemento en la posici√≥n i
})
```

::: {.callout-tip}
Algo importante es que **array.forEach()** no devuelve nada, por lo que no podemos asignar el resultado a una variable.
:::

**¬øCu√°l usar? Depende...**

::: table
| **M√©todo** | **Acceso al √çndice** | **Acceso al Valor** | **Puede Usar Break** | **Control Manual del √çndice** |
|---------------|---------------|---------------|---------------|---------------|
| **for** | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| **while** | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| **for...of** | ‚ùå | ‚úÖ | ‚úÖ | ‚ùå |
| **forEach** | ‚úÖ | ‚úÖ | ‚ùå | ‚ùå |
:::

::: {.callout-tip}
Aunque t√©cnicamente no puedes utilizar la sentencia **break** para salir de forEach, puedes simular esto lanzando una excepci√≥n y captur√°ndola en un bloque **try/catch** externo. Obviamente es una mala pr√°ctica que no te recomiendo.
:::

Cada uno de estos m√©todos tiene sus propios casos de uso. **for** y **while** son m√°s generales y te permiten controlar el √≠ndice manualmente, lo que es √∫til si necesitas saltar a √≠ndices espec√≠ficos, cambiar el orden de iteraci√≥n o salir del bucle antes de que se complete.

**for...of** es m√°s f√°cil de usar cuando solo necesitas los valores de un array y no te importa el √≠ndice. Es especialmente √∫til tambi√©n cuando est√°s trabajando con iterables que no son arrays, como las cadenas de caracteres o los conjuntos (sets).

Finalmente, **forEach** es una forma muy eficiente y legible de iterar sobre un array si no necesitas **break** y si no necesitas controlar manualmente el √≠ndice.

# Actividad Pr√°ctica

Dada una lista de n√∫meros, escribe una funci√≥n en JavaScript que devuelva la suma de todos los n√∫meros pares en la lista. La funci√≥n deber√° iterar sobre cada n√∫mero en la lista, comprobar si el n√∫mero es par y, si es as√≠, a√±adirlo a la suma total. Usa el bucle que quieras para solucionarlo.

``` javascript
function sumarPares(numeros) {
  let suma = 0
  // tu c√≥digo aqu√≠
  return suma
}
```

<details>

<summary>Ver soluci√≥n</summary>

``` javascript
function sumarPares(numeros) {
  let suma = 0

  for (let numero of numeros) {
    if (numero % 2 === 0) {
      suma += numero
    }
  }

  return suma
}
```

</details>

# B√∫squeda en Arrays con sus m√©todos

Existen varios m√©todos en **JavaScript** que te permiten, espec√≠ficamente, buscar dentro de un Array. Estos m√©todos incluyen **indexOf**, **some**, **every**, **find**, **findIndex** e **includes**.

Cada uno de estos m√©todos tiene un prop√≥sito espec√≠fico y una funcionalidad √∫nica. Vamos a explorar cada uno de ellos utilizando un Array de emojis como ejemplo.

``` javascript
const emojis = ['‚ú®', 'ü•ë', 'üòç']
```

# indexOf: ¬øEn qu√© posici√≥n est√° el elemento?

El m√©todo **indexOf** te permite encontrar la posici√≥n de un elemento dentro de un **Array**. Si el elemento no existe, entonces retorna **-1**.

``` javascript
const emojis = ['‚ú®', 'ü•ë', 'üòç']

const posicionCorazon = emojis.indexOf('üòç')

console.log(posicionCorazon) // -> 2
```

# includes: ¬øEl elemento existe en el Array?

El m√©todo includes determina si un Array incluye un determinado elemento, devolviendo **true** o **false** seg√∫n corresponda.

``` javascript
const emojis = ['‚ú®', 'ü•ë', 'üòç']

const tieneCorazon = emojis.includes('üòç')

console.log(tieneCorazon) // -> true
```

Es la forma m√°s sencilla y corta de buscar un elemento espec√≠fico dentro de un **Array**. Sin embargo, si queremos revisar si un **Array** contiene un elemento que cumpla con una condici√≥n, entonces tenemos que utilizar otros m√©todos...

::: {.callout-tip}
El m√©todo **.includes()** tambi√©n funciona con las cadenas de texto. Puedes utilizarlo para buscar una subcadena dentro de una cadena de texto: **'Hola mundo'.includes('Hola') // -\> true**
:::

# some: ¬øAlguno de los elementos cumple con la condici√≥n?

El m√©todo **some** te permite verificar si al menos uno de los elementos de un **Array** cumple con una condici√≥n.

Para utilizarlo, le pasas una funci√≥n como argumento. Esta funci√≥n recibe como argumento cada uno de los elementos del **Array** y debe retornar un valor **booleano**.

Si al menos uno de los elementos retorna **true**, entonces el m√©todo **some** retorna **true**. Si ninguno de los elementos retorna **true**, entonces el m√©todo **some** retorna **false**.

``` javascript
const emojis = ['‚ú®', 'ü•ë', 'üòç']

const tieneCorazon = emojis.some(emoji => emoji === 'üòç')
console.log(tieneCorazon) // -> true
```

¬°Pero si esto ya lo pod√≠amos hacer con **includes**! S√≠, pero **some** es mucho m√°s potente...

Podemos crear funciones m√°s complejas para pasarle al m√©todo **some**. Por ejemplo, podemos crear una funci√≥n que verifique si un **Array** contiene un elemento que sea un **string** de m√°s de 3 caracteres.

``` javascript
const names = ['Leo', 'Isa', '√çan', 'Lea']

const tieneNombreLargo = names.some(name => name.length > 3)
console.log(tieneNombreLargo) // -> false
```

Algo importante a tener en cuenta es que el m√©todo **some** deja de iterar sobre el **Array** en cuanto encuentra un elemento que cumple con la condici√≥n. Por ejemplo, si tenemos un **Array** de 10 elementos y el elemento n√∫mero 3 cumple con la condici√≥n, el m√©todo **some** no va a iterar sobre los 7 elementos restantes:

``` javascript
const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

const tieneNumeroMayorA5 = numbers.some(number => {
  console.log(`Estoy iterando sobre el n√∫mero ${number}`) // -> Imprime hasta el n√∫mero 6
  return number > 5
})

console.log(tieneNumeroMayorA5) // -> true
```

# every: ¬øTodos los elementos cumplen con la condici√≥n?

El m√©todo **every** te permite verificar si todos los elementos de un **Array** cumplen con una condici√≥n. Es similar a **some**, pero en lugar de verificar si al menos uno de los elementos cumple con la condici√≥n, los verifica todos.

Para utilizarlo, le pasas una funci√≥n como argumento. Esta funci√≥n recibe como argumento el elemento del array que est√° iterando en ese momento y debe retornar un valor **booleano** para saber si el elemento cumple con la condici√≥n.

Si todos los elementos retornan **true**, entonces el m√©todo **every** retorna true. Si al menos uno de los elementos retorna **false**, entonces el m√©todo **every** retorna **false**.

``` javascript
// ¬øTodos los emojis son felices?
const emojis = ['üòÄ', 'üòÇ', 'üòç', 'üò≠', 'ü•∫', 'üòé']
const todosSonFelices = emojis.every(emoji => emoji === 'üòÄ')
console.log(todosSonFelices) // -> false

// ¬øTodos los n√∫meros son pares?
const numbers = [2, 4, 7, 10, 12]
const todosSonPares = numbers.every(number => number % 2 === 0)
console.log(todosSonPares) // -> false

// ¬øTodos los strings son mayores a 3 caracteres?
const names = ['Miguel', 'Juan', 'Itziar', 'Isabel']
const todosLosNombresSonLargos = names.every(name => name.length > 3)
console.log(todosLosNombresSonLargos) // -> true
```

Al igual que **some**, el m√©todo **every** deja de iterar sobre el **Array** en cuanto encuentra un elemento que no cumple con la condici√≥n.

# find: Devuelve el primer elemento que cumple con la condici√≥n

El m√©todo **find** te permite encontrar el primer elemento que cumple con una condici√≥n. Lo interesante es que este m√©todo te devuelve el elemento en s√≠, no un valor **booleano** como **some** y **every**. Aunque el funcionamiento es igual: hay que pasarle una funci√≥n como argumento que retorne un valor **booleano**.

\`\`\` javascriptconst numbers = \[13, 27, 44, -10, 81\] // encuentra el primer n√∫mero negativo const firstNegativeNumber = numbers.find(number =\> number \< 0)

console.log(firstNegativeNumber) // -\> -10

```         

Si no encuentra ning√∫n elemento que cumpla con la condici√≥n, el m√©todo **find** retorna **undefined**.

``` javascript
const numbers = [13, 27, 44, 81]
// encuentra el primer n√∫mero negativo
const firstNegativeNumber = numbers.find(number => number < 0)

console.log(firstNegativeNumber) // -> undefined
```

De nuevo, igual que **some** y **every**, el m√©todo **find** deja de iterar sobre el **Array** en cuanto encuentra un elemento que cumple con la condici√≥n.

# findIndex: Devuelve el √≠ndice del primer elemento que cumple con la condici√≥n

El m√©todo **findIndex** es similar a **find**, pero en lugar de devolver el elemento que cumple con la condici√≥n, devuelve el √≠ndice de ese elemento.

``` javascript
const numbers = [13, 27, 44, -10, 81]

// encuentra el √≠ndice del primer n√∫mero negativo
const firstNegativeNumberIndex = numbers.findIndex(number => number < 0)

console.log(firstNegativeNumberIndex) // -> 3

// ahora puedes usar el √≠ndice para acceder al elemento
console.log(numbers[firstNegativeNumberIndex]) // -> -10
```

Si no encuentra ning√∫n elemento que cumpla con la condici√≥n, el m√©todo **findIndex** retorna **-1**.

``` javascript
const numbers = [13, 27, 44, 81]

// encuentra el √≠ndice del primer n√∫mero negativo
const firstNegativeNumberIndex = numbers.findIndex(number => number < 0)

console.log(firstNegativeNumberIndex) // -> -1
```

# Actividad Pr√°ctica

Crear una funci√≥n que reciba un array de palabras y devuelva **true** si todas las palabras terminan con la letra "a" y **false** si al menos una palabra no termina con la letra "a".

Usa el [m√©todo endsWith() de string](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith) para resolverlo.

``` javascript
function acabanEnA(words) {
  // tu c√≥digo aqu√≠
}
```

<details>

<summary>Ver soluci√≥n</summary>

``` javascript
function acabanEnA(words) {
  return words.every(word => word.endsWith('a'))
}
```

</details>

# Ordenamiento de Arrays en JavaScript

*JavaScript* proporciona un m√©todo incorporado en arrays llamado **.sort()** para ordenar sus elementos. Por defecto no es muy √∫til pero puedes personalizar su comportamiento para que ordene los elementos de la manera que necesites.

# Ordenamiento b√°sico con sort()

Por defecto, **.sort()** hace una ordenaci√≥n un poco extra√±a:

``` javascript
let numeros = [5, 10, 2, 25, 7]
numeros.sort()
console.log(numeros) // [10, 2, 25, 5, 7]
```

¬øQu√© ha pasado? **Este comportamiento puede resultar confuso cuando se trabaja con n√∫meros**, ya que **.sort()** ordenar√° los n√∫meros en funci√≥n de su valor como cadena de texto, no de su valor num√©rico.

Por suerte, podemos arreglarlo...

# Ordenamiento personalizado con sort()

Para personalizar c√≥mo **sort()** ordena los elementos, puedes pasar una funci√≥n de comparaci√≥n como argumento. La funci√≥n de comparaci√≥n debe devolver:

-   Un **valor negativo** si el primer argumento debe aparecer antes que el segundo.
-   Un **valor positivo** si el segundo argumento debe aparecer antes que el primero.
-   **Cero** si ambos argumentos son iguales.

Por ejemplo, **para ordenar los n√∫meros de menor a mayor**, puedes usar la siguiente funci√≥n de comparaci√≥n:

``` javascript
let numeros = [5, 10, 2, 25, 7]

numeros.sort(function(a, b) {
  return a - b
})

console.log(numeros) // [2, 5, 7, 10, 25]
```

**Para ordenarlos de manera descendente**, de mayor a menor, deber√≠as cambiar el orden del **return**:

``` javascript
let numeros = [5, 10, 2, 25, 7]

numeros.sort(function(a, b) {
  return b - a
})

console.log(numeros) // [25, 10, 7, 5, 2]
```

Puedes usar una **arrow function** para simplificar el c√≥digo:

``` javascript
let numeros = [5, 10, 2, 25, 7]

numeros.sort((a, b) => a - b)
```

# sort() y toSorted()

Como ves, **.sort()** modifica el array original. Si quieres obtener un array ordenado sin modificar el original, puedes usar el m√©todo **.toSorted()**. S√≥lo ten en cuenta que, ahora mismo, su soporte en navegadores es limitado.

``` javascript
let numeros = [5, 10, 2, 25, 7]

let numerosOrdenados = numeros.toSorted((a, b) => {
  return a - b
})

console.log(numerosOrdenados) // [2, 5, 7, 10, 25]
console.log(numeros) // [5, 10, 2, 25, 7]
```

Tambi√©n podr√≠as usar el operador de propagaci√≥n **(...)** para crear una copia del array original y ordenarla:

``` javascript
let numeros = [5, 10, 2, 25, 7]

const copiaNumeros = [...numeros]
// ordenamos la copia y no el original
copiaNumeros.sort((a, b) => a - b)

console.log(copiaNumeros) // [2, 5, 7, 10, 25]
console.log(numeros) // [5, 10, 2, 25, 7]
```

# Actividad Pr√°ctica

Recibes una lista de n√∫meros. Debes ordenar los n√∫meros de menor a mayor seg√∫n su valor absoluto. Eso quiere decir que los n√∫meros negativos pierden el signo y se ordenan como si fueran positivos.

Por ejemplo, si recibes **\[5, -10, -2, -25, -7\]** deber√≠as devolver **\[-2, 5, -7, -10, -25\]**.

Puedes usar el m√©todo **Math.abs(num)** para obtener el valor absoluto de un n√∫mero.

``` javascript
function sortAbsoluteNumbers(numbers) {
  // tu c√≥digo aqu√≠
  }
```

<details>

<summary>Ver soluci√≥n</summary>

``` javascript
function sortAbsoluteNumbers(numbers) {
  return numbers.sort((a, b) => Math.abs(a) - Math.abs(b))
}
```

</details>

# Transformaci√≥n de Arrays en JavaScript

Ya hemos visto c√≥mo podemos crear arrays, modificarlos y buscar en ellos. Ahora vamos a ver c√≥mo podemos transformarlos. Esto es, c√≥mo podemos crear nuevos arrays a partir de los que ya tenemos.

# filter: Un nuevo Array con los elementos que cumplan una condici√≥n

El m√©todo filter crea un nuevo array con todos los elementos que devuelven **true** al ejecutar una funci√≥n que le pasamos como par√°metro.

Por ejemplo, podr√≠amos filtrar en un nuevo array todos los n√∫meros pares de un array de n√∫meros:

``` javascript
const numbers = [1, 2, 3, 4, 5, 6, 7]

const evenNumbers = numbers.filter(function (number) {
  return number % 2 === 0
})

console.log(evenNumbers) // [2, 4, 6]
```

O quedarnos con todas las cadenas de texto que tengan la letra **a**:

``` javascript
const strings = ['hola', 'adi√≥s', 'casa', 'coche', 'perro', 'gato']

// en las cadenas de texto podemos usar el m√©todo `includes`
// para saber si una cadena contiene otra:
const stringsWithA = strings.filter(string => string.includes('a'))

console.log(stringsWithA) // ['hola', 'adi√≥s', 'casa', 'gato']
```

# map: Un nuevo Array con los elementos transformados

El m√©todo **map** crea un nuevo array de la misma longitud que el original, pero con los elementos transformados por una funci√≥n que le pasamos como par√°metro. As√≠ que la funci√≥n recibir√° cada elemento del array y tendremos que devolver el elemento transformado.

Por ejemplo, podr√≠amos crear un array con el doble de cada n√∫mero de un array de n√∫meros:

``` javascript
const numbers = [1, 2, 3]

const doubleNumbers = numbers.map((number) => {
  return number * 2
})

console.log(doubleNumbers) // [2, 4, 6]
```

O podr√≠amos crear un array con la longitud de cada cadena de texto de un array de cadenas:

``` javascript
const strings = ['hola', 'javascript', 'midu', 'programaci√≥n']

const stringsLength = strings.map((string) => string.length)

console.log(stringsLength) // [4, 10, 4, 12]
```

# map + filter: Un nuevo Array con los elementos transformados y filtrados

En JavaScript podemos crear un encadenamiento de m√©todos. De esta forma, si un m√©todo devuelve un array, podemos llamar a otro m√©todo sobre ese array sin necesidad de guardarlo en una variable.

Imagina que queremos crear un array con el doble de los n√∫meros y s√≥lo quedarnos con los que sean mayores que 5. Podr√≠amos hacerlo as√≠:

``` javascript
const numbers = [1, 2, 3, 4, 5, 6, 7]

const numsGreaterThanFive = numbers
  .map(number => number * 2) // [2, 4, 6, 8, 10, 12, 14]
  .filter(number => number > 5) // [6, 8, 10, 12, 14]

console.log(numsGreaterThanFive) // [6, 8, 10, 12, 14]
```

Tambi√©n podr√≠amos hacerlo al rev√©s, primero filtrando y luego transformando. Por ejemplo, filtrar los n√∫meros pares y luego multiplicarlos por 2:

``` javascript
const numbers = [1, 2, 3, 4, 5, 6, 7]

const doubleEvenNumbers = numbers
  .filter(number => number % 2 === 0) // [2, 4, 6]
  .map(number => number * 2) // [4, 8, 12]

console.log(doubleEvenNumbers) // [4, 8, 12]
```

# reduce: Un √∫nico valor a partir de un array

El m√©todo **reduce** es un poco m√°s complejo que los anteriores. Este m√©todo te permite crear un √∫nico valor a partir de un Array.

Recibe dos par√°metros: una funci√≥n que se ejecutar√° por cada elemento y un valor inicial, opcional, que ser√° donde podremos acumular los valores.

El primer par√°metro de **reduce**, que es la funci√≥n que se ejecutar√° por cada elemento, recibe tres par√°metros:

-   **El acumulador:** el valor que se va a ir acumulando en cada iteraci√≥n
-   **El elemento actual:** el elemento del Array que estamos iterando en ese momento.
-   **El √≠ndice:** la posici√≥n del elemento actual en el Array.

Y debe devolver el valor que se va a acumular en cada iteraci√≥n.

Un caso de uso muy t√≠pico de **reduce** es sumar todos los elementos de un Array:

``` javascript
const numbers = [1, 2, 3]

const sum = numbers.reduce((accumulator, currentNumber) => {
  return accumulator + currentNumber
}, 0) // <- el 0 es el valor inicial

console.log(sum) // 6
```

Vamos a ver qu√© est√° pasando en cada iteraci√≥n:

-   **Iteraci√≥n 1:** el acumulador vale 0 (ya que 0 es el valor inicial) y el elemento actual vale 1. As√≠ que devolvemos 0 + 1 = 1
-   **Iteraci√≥n 2:** el acumulador vale 1 (el valor que devolvimos en la iteraci√≥n anterior) y el elemento actual vale 2. As√≠ que devolvemos 1 + 2 = 3
-   **Iteraci√≥n 3:** el acumulador vale 3 (el valor que devolvimos en la iteraci√≥n anterior) y el elemento actual vale 3. As√≠ que devolvemos 3 + 3 = 6

Por lo tanto, el valor final de **sum** es 6.

¬øRecuerdas que hemos visto antes c√≥mo usar **map** y **filter** juntos? Pues podr√≠as usar **reduce** para tener que evitar crear un array intermedio. Por ejemplo, imagina que queremos doblar los n√∫meros pares y s√≥lo quedarnos con los mayores de 5 (como hicimos en el ejemplo anterior):

``` javascript
const numbers = [1, 2, 3, 4, 5, 6, 7]

const doubleEvenNumbers = numbers.reduce((accumulator, currentNumber) => {
  const isEven = currentNumber % 2 === 0
  const doubled = currentNumber * 2
  const isGreaterThanFive = doubled > 5

  // si es par y mayor que 5, lo a√±adimos al array
  if (isEven && isGreaterThanFive) {
    // para ello devolvemos un nuevo array con el valor actual
    return accumulator.concat(doubled)
  } else {
    // si no, devolvemos lo que ya ten√≠amos
    return accumulator
  }
}, []) // <- el array vac√≠o es el valor inicial

console.log(doubleEvenNumbers) // [8, 12]
```

Lo interesante en este caso es que no hemos tenido que crear un array intermedio con **map** y **filter**. Hemos ido acumulando los valores que nos interesaban en cada iteraci√≥n y los que no nos interesaban los hemos descartado devolviendo lo que ya ten√≠amos en el acumulador.

::: {.callout-tip}
Ten cuidado con reduce. Como puedes ver, su carga cognitiva es mayor que la de map y filter. As√≠ que si puedes usar map y filter para hacer lo mismo, hazlo. S√≥lo usa reduce cuando no te quede m√°s remedio.
:::

# Actividad Pr√°ctica

**Recibes dos par√°metros:** una lista de palabras **words** y una palabra **word**. Primero, busca el √≠ndice de la palabra en la lista. Despu√©s, usa ese √≠ndice (que ser√° un n√∫mero) y devuelve todas las palabras de **words** que sean m√°s largas (**length**) que el n√∫mero del √≠ndice.

Ten en cuenta que la palabra **word** siempre existir√° en el array, por lo que no es necesario comprobar si existe o no.

``` javascript
function buscaPalabras(words, word) {
  // tu c√≥digo aqu√≠
}
```

<details>

<summary>Ver soluci√≥n</summary>

``` javascript
function buscaPalabras(words, word) {
  const index = words.indexOf(word)
  return words.filter(word => word.length > index)
}
```

</details>

# Matrices

En matem√°ticas y en programaci√≥n, una matriz se refiere a una colecci√≥n de elementos dispuestos en filas y columnas. En t√©rminos m√°s sencillos, y en JavaScript, podemos representar una matriz como un array de arrays.

## Creaci√≥n de Matrices

Para empezar, aqu√≠ se muestra c√≥mo se puede crear una matriz simple de 2x3 en JavaScript:

``` javascript
const matriz = [
  [1, 2, 3],
  [4, 5, 6]
]
```

::: {.callout-tip}
Las matrices no tienen por qu√© ser cuadradas. Pueden tener cualquier n√∫mero de filas y columnas.
:::

# Acceso a los Elementos de una Matriz

Para acceder a los elementos de una matriz, necesitaremos utilizar dos √≠ndices: uno para la *fila* y otro para la *columna*.

Por ejemplo, si queremos acceder al n√∫mero **6** en la matriz anterior, har√≠amos lo siguiente:

``` javascript
let numero = matriz[1][2]
console.log(numero) // -> 6
```

Aqu√≠, el primer √≠ndice, **\[1\]**, se refiere a la segunda fila (recuerda que los arrays en JavaScript tienen un √≠ndice base cero), y el segundo √≠ndice, **\[2\]**, se refiere a la tercera columna.

# Iteraci√≥n sobre Matrices

Podemos utilizar bucles anidados para iterar sobre todos los elementos de una matriz. Aqu√≠ hay un ejemplo de c√≥mo hacerlo utilizando un bucle for:

``` javascript
for (let i = 0; i < matriz.length; i++) { // {1}
  for (let j = 0; j < matriz[i].length; j++) { // {2}
    console.log(matriz[i][j])
  }
}
```

En este ejemplo, el bucle externo recorre **{1}** cada fila de la matriz, mientras que el bucle interno **{2}** recorre cada elemento dentro de una fila espec√≠fica.

Puedes usar otros bucles para iterar sobre una matriz, como un bucle while o un bucle for...of. Tambi√©n puedes utilizar el m√©todo **forEach()** de los arrays para iterar sobre una matriz, pero tendr√°s que anidar dos llamadas a **forEach()** para iterar sobre todos los elementos de la matriz.

``` javascript
matriz.forEach((fila, filaIndex) => {
  fila.forEach((elemento, columnaIndex) => {
    console.log('Fila ' + filaIndex)
    console.log('Columna ' + columnaIndex)
    console.log('Elemento ', elemento)
    console.log('')
  })
})
```

# Ejemplo pr√°ctico de Matrices

Un ejemplo sencillo de entender pero muy √∫til es el juego del 3 en raya. En este juego, los jugadores se turnan para colocar sus fichas en una cuadr√≠cula de **3x3**.

El objetivo del juego es colocar tres fichas en una fila, columna o diagonal.

Para representar el tablero de juego, podemos utilizar una matriz de **3x3**. Cada elemento de la matriz puede ser una cadena que represente una ficha:

``` javascript
const tablero = [
  ['X', 'O', 'X'],
  ['O', 'X', 'O'],
  ['O', 'O', 'X']
]
```

Ahora, para **buscar si hay un ganador en el tablero**, podemos utilizar un bucle **for** para iterar sobre cada fila y columna del tablero.

Si encontramos tres fichas iguales en una fila, columna o diagonal, entonces tenemos un ganador.

``` javascript
// Verifica las l√≠neas horizontales
for (let i = 0; i < 3; i++) {
  if (
    tablero[i][0] === tablero[i][1] &&
    tablero[i][1] === tablero[i][2]
  ) {
    console.log(`El ganador es: ${tablero[i][0]}`);
  }
}

// Verifica las l√≠neas verticales
for (let i = 0; i < 3; i++) {
  if (
    tablero[0][i] === tablero[1][i] &&
    tablero[1][i] === tablero[2][i]
  ) {
    console.log(`El ganador es: ${tablero[0][i]}`);
  }
}

// Verifica la diagonal de arriba izquierda a derecha abajo
if (
  tablero[0][0] === tablero[1][1] &&
  tablero[1][1] === tablero[2][2]
) {
  console.log(`El ganador es: ${tablero[0][0]}`);
}

// Verifica la diagonal de derecha arriba a izquierda abajo
if (
  tablero[0][2] === tablero[1][1] &&
  tablero[1][1] === tablero[2][0]
) {
  console.log(`El ganador es: ${tablero[0][2]}`);
}
```

Las matrices son muy √∫tiles y necesarias para muchos juegos (ajedrez, damas, buscaminas, etc.) y aplicaciones (hojas de c√°lculo, bases de datos, etc.). As√≠ que es importante que te familiarices con ellas.

# Actividad Pr√°ctica

Recibimos una matriz de cadenas de texto. Tenemos que localizar la posici√≥n de la palabra **"JavaScript"** en la matriz y devolver su posici√≥n como un **array de dos elementos**: el √≠ndice de la fila y el √≠ndice de la columna.

``` javascript
const matrix = [
  ['HTML', 'CSS', 'JavaScript'],
  ['Java', 'C++', 'Python'],
  ['Ruby', 'Go', 'Swift']
]

const position = findJavaScript(matrix)
console.log(position) // -> [0, 2]
```

Si no encuentra la palabra debe devolver **\[-1, -1\]**. Usa el siguiente c√≥digo como punto de partida:

``` javascript
function findJavaScript(matrix) {
  // tu c√≥digo aqu√≠
}
```

<details>

<summary>Ver soluci√≥n</summary>

``` javascript
function findJavaScript(matrix) {
  for (let i = 0; i < matrix.length; i++) {
    for (let j = 0; j < matrix[i].length; j++) {
      if (matrix[i][j] === 'JavaScript') {
        return [i, j]
      }
    }
  }

  return [-1, -1]
}
```

</details>

# Algoritmos con Arrays

Los *algoritmos* son una serie de **pasos que se realizan para resolver un problema**. En este caso, vamos a ver algunos *algoritmos* que se pueden realizar con arrays donde se pueden aplicar los conceptos de complejidad algor√≠tmica (cu√°nto tarda un algoritmo en ejecutarse).

# Algoritmo para encontrar el n√∫mero mayor

El primer algoritmo que vamos a ver es el de encontrar el n√∫mero mayor de un array. Para ello, vamos a crear una funci√≥n que reciba un array de n√∫meros y devuelva el n√∫mero mayor.

``` javascript
function findMaxAlgorithm(array) {
  let max = array[0] // recuperamos el primer elemento del array

  // recorremos el array desde el segundo elemento
  for (let i = 1; i < array.length; i++) {
    // ¬øes el elemento actual mayor que el m√°ximo?
    if (array[i] > max) {
      // si es as√≠, lo guardamos como nuevo m√°ximo
      max = array[i]
    }
  }

  // devolvemos el m√°ximo n√∫mero que hemos encontrado
  return max;
}
```

::: {.callout-tip}
En JavaScript podr√≠amos usar el m√©todo **Math.max** para encontrar el n√∫mero mayor de un array. Se usar√≠a as√≠: **Math.max(...array)**. Pero por motivos did√°cticos, hemos creado nuestro propio algoritmo. Siempre que puedas, te recomiendo usar **Math.max** en su lugar.
:::

# Complejidad algor√≠tmica

Para calcular la complejidad algor√≠tmica del algoritmo anterior, tenemos que tener en cuenta el n√∫mero de operaciones que se realizan.

En nuestro ejemplo, para encontrar el mayor n√∫mero de un array tenemos que recorrer todos los elementos del array. Si el array tiene 10 elementos, tendremos que recorrerlo 10 veces. Si tiene 100 elementos, tendremos que recorrerlo 100 veces. Es decir, **el n√∫mero de operaciones que se realizan es igual al n√∫mero de elementos del array**.

En programaci√≥n se usa la notaci√≥n O(n) para indicar que el n√∫mero de operaciones que se realizan es igual al n√∫mero de elementos del array. En este caso, n es el n√∫mero de elementos del array.

# B√∫squeda binaria

Imagina que tienes un array de n√∫meros ordenados de menor a mayor. Por ejemplo, **\[11, 18, 23, 25, 48, 55, 88, 111, 120\]**. Si te pido que busques el n√∫mero **55** en el array, ¬øc√≥mo lo har√≠as?.

Una forma de hacerlo ser√≠a recorrer el array desde el principio hasta el final y comprobar si el n√∫mero que estamos buscando es igual al n√∫mero actual. Si es as√≠, hemos encontrado el n√∫mero. Si no, seguimos buscando.

``` javascript
function findNumber(array, number) {
  for (let i = 0; i < array.length; i++) {
    if (array[i] === number) {
      return true
    }
  }

  return false
}
```

::: {.callout-tip}
Obviamente, podr√≠amos usar el m√©todo **.includes()** para comprobar si un array contiene un elemento. Pero por motivos did√°cticos, hemos creado nuestro propio algoritmo. Siempre que puedas, te recomiendo usar **.includes()** en su lugar.
:::

La complejidad algor√≠tmica de este algoritmo es O(n). Es decir, el n√∫mero de operaciones que se realizan es igual al n√∫mero de elementos del array. Pero podemos hacerlo mejor.

Existe un algoritmo muy popular llamado b√∫squeda binaria que nos permite encontrar un elemento en un array ordenado en O(log n). Es decir, el n√∫mero de operaciones que se realizan es igual al logaritmo del n√∫mero de elementos del array. ¬øQu√© significa esto?.

Imagina que tenemos un array de 10 elementos. Si aplicamos la b√∫squeda binaria, el n√∫mero de operaciones que se realizan es igual a 3. Si tenemos un array de 100 elementos, el n√∫mero de operaciones que se realizan es igual a 6. ¬øVes la diferencia? ¬°Es mucho m√°s r√°pido!

::: {.callout-tip}
Para aplicar la b√∫squeda binaria, tenemos que tener en cuenta que el array tiene que estar ordenado de menor a mayor. Si no, no funcionar√°.
:::

# Implementaci√≥n de la b√∫squeda binaria

La idea de la b√∫squeda binaria es ir dividiendo el array en dos mitades. Si el elemento que estamos buscando es mayor que el elemento de la mitad del array, tenemos que buscar en la mitad derecha. Si el elemento que estamos buscando es menor que el elemento de la mitad del array, tenemos que buscar en la mitad izquierda. Y as√≠ sucesivamente hasta encontrar el elemento que estamos buscando.

``` javascript
function busquedaBinaria(array, elemento) {
  let index = 0 // primer elemento del array
  let final = array.length - 1 // √∫ltimo elemento del array a buscar
  
  // mientras el √≠ndice sea menor o igual que el final
  // seguiremos buscando
  while (index <= final) {
    // calculamos la mitad del array
    // como puede ser impar, usamos Math.floor para redondear hacia abajo
    const mitad = Math.floor((index + final) / 2)
    
    // si el elemento de la mitad es igual al elemento que estamos buscando
    // entonces hemos encontrado el elemento
    if (array[mitad] === elemento) {
      return mitad
    } else if (array[mitad] < elemento) {
      // si el elemento de la mitad es menor que
      // el elemento que estamos buscando
      // entonces tenemos que buscar en la mitad derecha
      index = mitad + 1
    } else {
      // si el elemento de la mitad es mayor que
      // el elemento que estamos buscando
      // entonces tenemos que buscar en la mitad izquierda
      final = mitad - 1
    }
  }
  
  // si llegamos hasta aqu√≠, es que no hemos encontrado el elemento
  // devolvemos -1, para indicar que no se ha encontrado
  return -1
}
```

::: {.callout-tip}
En JavaScript podr√≠amos usar el m√©todo **Array.prototype.indexOf** para encontrar el √≠ndice de un elemento en un array. Se usar√≠a as√≠: **array.indexOf(elemento)**. Pero por motivos did√°cticos, hemos creado nuestro propio algoritmo. Siempre que puedas, te recomiendo usar **Array.prototype.indexOf** en su lugar.
:::

# Actividad Pr√°ctica

En una biblioteca queremos saber qu√© libro es el que menos p√°ginas tiene y el que m√°s p√°ginas. Por suerte, no hay dos libros con el mismo n√∫mero de p√°ginas.

Necesitamos que la funci√≥n reciba un array de n√∫meros, sin ordenar, y que devuelva un array de dos posiciones con el √≠ndice del libro con menos p√°ginas y el √≠ndice del libro con m√°s p√°ginas.

``` javascript
function minAndMaxWord(words) {
  // tu c√≥digo aqu√≠
}
```

<details>

<summary>Ver soluci√≥n</summary>

``` javascript
function minAndMaxWord(words) {
  let min = 0
  let max = 0

  for (let i = 1; i < words.length; i++) {
    if (words[i] < words[min]) {
      min = i
    }

    if (words[i] > words[max]) {
      max = i
    }
  }

  return [min, max]
}
```

</details>

# Objetos

Los objetos en JavaScript son una colecci√≥n de propiedades y m√©todos que definen un elemento a trav√©s de una clave y un valor.

Por ejemplo, si pensamos en una persona, podemos definir sus propiedades como su nombre, su edad, su altura, su peso, etc. Y sus m√©todos como caminar, correr, saltar, etc. Declaraci√≥n y asignaci√≥n de objetos

# Declaraci√≥n y asignaci√≥n de objetos

Para declarar un objeto usamos las llaves **{}** y dentro las propiedades y m√©todos separados por comas **,**. Cada propiedad o m√©todo se define con una clave y un valor separados por dos puntos **:**.

Por ejemplo, vamos a crear un objeto que represente a una persona:

``` javascript
const persona = { 
  name: 'Dani',
  age: 30,
  isWorking: true
}
```

Las propiedades y m√©todos de un objeto pueden ser de cualquier tipo de JavaScript, incluso otros objetos o arrays.

``` javascript
const persona = {
  name: 'Dani',
  age: 30,
  isWorking: true,
  family: ['Miguel', 'Maria'], // array
  address: { // otro objeto
    street: 'Calle de la piruleta',
    number: 13,
    city: 'Barcelona'
  }
}
```

Y, claro, como hemos comentado antes, tambi√©n podemos tener funciones. **Cuando una funci√≥n es parte de un objeto se le llama m√©todo**.

``` javascript
const persona = {
  name: 'Dani',
  age: 30,
  isWorking: true,
  family: ['Miguel', 'Maria'],
  address: {
    street: 'Calle de la piruleta',
    number: 13,
    city: 'Barcelona'
  },
  walk: function () { // <- m√©todo
    console.log('Estoy caminando')
  }
}
```

# Acceder a propiedades y m√©todos de un objeto

Para acceder a las propiedades y m√©todos de un objeto usamos el punto . y el nombre de la propiedad o m√©todo.

``` javascript
const persona = { name: 'Dani' }
console.log(persona.name) // Dani
```

Si intentamos acceder a una propiedad o m√©todo que no existe, nos devolver√° **undefined**.

``` javascript
const persona = { name: 'Dani' }
console.log(persona.fullName) // -> undefined
```

Puedes usar variables para acceder a las propiedades y m√©todos de un objeto. Para ello, tienes que usar la notificaci√≥n por corchetes **\[\]**.

``` javascript
const persona = { name: 'Dani' }
let property = 'name'

console.log(persona[property]) // -> Dani
```

Tambi√©n necesitas usar los corchetes si la clave de la propiedad o m√©todo tiene espacios o caracteres especiales.

``` javascript
const persona = { 'full name': 'Dani' }

console.log(persona['full name']) // -> Dani

// ‚ùå no puedes hacer esto
// persona.full name
```

::: {.callout-tip}
Siempre que puedas, evita usar espacios o caracteres especiales en las claves de las propiedades y m√©todos de un objeto. Aunque se puede, es m√°s complicado de leer y de escribir.
:::

Igual que las propiedades, puedes acceder a los m√©todos de un objeto usando cualquiera de las dos formas anteriormente comentadas:

``` javascript
const persona = {
  name: 'Dani',
  walk: function () {
    console.log('Estoy caminando')
  }
}

persona.walk() // -> Estoy caminando

let method = 'walk'
persona[method]() // -> Estoy caminando
```

::: {.callout-tip}
**persona[method]()** parece un poco raro, pero si lo separas parte por parte, ver√°s que tiene sentido. **persona** es el objeto. Accedemos a la propiedad **method** del objeto persona con **persona\[method\]**. Y, finalmente, ejecutamos la funci√≥n con **persona[method]()**. Es decir, estamos ejecutando **persona.walk()**.
:::

# A√±adir y modificar propiedades de un objeto

Igual que podemos acceder a las propiedades de un objeto, podemos a√±adir nuevas propiedades o modificar las existentes.

``` javascript
const persona = { name: 'Dani' }

persona.age = 30

console.log(persona) // -> { name: 'Dani', age: 30 }
```

En el c√≥digo estamos modificando el objeto **persona** a√±adiendo la propiedad **age** con el valor **30**.

::: {.callout-tip}
F√≠jate que, al igual que en los Arrays, podemos a√±adir propiedades a un objeto aunque sea una constante. Esto es porque no estamos reasignando la variable **persona**, si no que estamos modificando una propiedad interna del objeto.
:::

# Eliminar propiedades de un objeto

Para eliminar una propiedad de un objeto usamos la palabra reservada **delete**.

``` javascript
const persona = { name: 'Dani', age: 18 }

delete persona.age

console.log(persona) // -> { name: 'Dani' }
```

# Actividad Pr√°ctica

Tenemos una funci√≥n que recibe dos par√°metros. **name** y **subs**. Haz que la funci√≥n devuelva un objeto con la siguiente informaci√≥n:

-   **name** con el valor del par√°metro **name**
-   **subscribers** con el valor del par√°metro **subs**
-   **hash**, con el valor de la longitud del string **name** multiplicado por el par√°metro **subs**
-   Un m√©todo **getStatus** que devuelva el texto **El canal de \<name\> tiene \<subs\> suscriptores**. Por ejemplo, para name = \* 'Dani' y subs = 100, el m√©todo **getStatus** devolver√≠a **El canal de Dani tiene 100 suscriptores**.

¬°Ojo! El m√©todo **getStatus** debe devolver el texto, NO imprimirlo por consola.

``` javascript
function createObject(name, subs) {
  // tu c√≥digo aqu√≠
}
```

<details>

<summary>Ver soluci√≥n</summary>

``` javascript
function createObject(name, subs) {
  return {
    name: name,
    subscribers: subs,
    hash: name.length * subs,
    getStatus: function () {
      return `El canal de ${this.name} tiene ${this.subscribers} suscriptores`
    }
  }
}
```

</details>

# Atajos para trabajar con objetos

Trabajar con objetos es muy com√∫n en JavaScript. En esta clase vamos a ver algunos atajos que nos permiten trabajar con ellos de forma m√°s c√≥moda, tanto a la hora de crearlos como a la hora de recuperar sus propiedades.

## Atajo al crear un objeto

Imagina que quieres crear un objeto y que algunas de sus propiedades usen como valor algunas variables que ya tenemos.

``` javascript
const name = 'Spidey'
const universe = 42

const spiderman = {
  name: name,
  universe: universe,
  powers: ['web', 'invisibility', 'spider-sense']
}
```

En este caso, podemos usar un atajo para crear el objeto. **Si la propiedad y la variable tienen el mismo nombre**, podemos omitir el valor y dejar solo el nombre de la propiedad.

``` javascript
const name = 'Spidey'
const universe = 42

const spiderman = {
  name, // <- autom√°ticamente asigna el valor de la variable name
  universe, // <- autom√°ticamente asigna el valor de la variable universe
  powers: ['web', 'invisibility', 'spider-sense']
}
```

F√≠jate que si tuvieramos **powers** fuera del objeto, podr√≠amos crear el objeto en la misma l√≠nea:

``` javascript
const name = 'Spidey'
const universe = 42
const powers = ['web', 'invisibility', 'spider-sense']

const spiderman = { name, universe, powers }
```

# Destructuraci√≥n: el atajo al recuperar propiedades

En la anterior clase hemos visto que para recuperar una propiedad de un objeto podemos usar la notaci√≥n de corchetes o la notaci√≥n de punto:

``` javascript
const spiderman = {
  name: 'Spidey',
  universe: 42,
  powers: ['web', 'invisibility', 'spider-sense']
}

console.log(spiderman['name']) // Spidey
console.log(spiderman.name) // Spidey
```

A veces queremos recuperar el valor de la propiedad y guardarlo en una variable, para usarlo m√°s adelante. Har√≠amos algo as√≠:

``` javascript

const universe = spiderman.universe
console.log(universe) // 42

const powers = spiderman['powers'][1]
console.log(powers) // 'invisibility'
```

::: {.callout-tip}
**spiderman\['powers'\]\[1\]** de nuevo puede parecer un poco confuso, pero hay que separarlo en partes. **spiderman** es el objeto. Accedemos a la propiedad **powers** y como es un array, podemos acceder a su segundo elemento con **\[1\]**. Y ah√≠ est√° el valor que queremos: **invisibility**.
:::

A la hora de acceder a las propiedades existe un atajo llamado **desestructuraci√≥n** (o destructuring en ingl√©s) muy interesante que nos permite recuperar el valor de una propiedad y guardarlo en una variable de una.

Lo importante es que tengamos en cuenta que **la variable que se crear√° tendr√° el mismo nombre que la propiedad que estamos recuperando**.

``` javascript
const { universe } = spiderman
console.log(universe) // 42
```

Adem√°s, puedes recuperar tantas propiedades como quieras, separ√°ndolas por comas.

``` javascript
const { universe, name, powers } = spiderman
console.log(universe) // 42
console.log(name) // 'Spidey'
console.log(powers) // ['web', 'invisibility', 'spider-sense']
```

# Renombrar variables y valores por defecto

Si quieres que la variable que se crea tenga un **nombre diferente al de la propiedad**, puedes hacerlo as√≠:

``` javascript
const { universe: universeNumber } = spiderman
console.log(universeNumber) // 42
```

Lo que estamos haciendo es recuperar la propiedad **universe** pero crear la constante con el nombre **universeNumber**.

Si la propiedad no existe, podemos asignarle un valor por defecto:

``` javascript
const { name, isAvenger = false } = spiderman
console.log(name) // 'Spidey'
console.log(isAvenger) // false
```

El objeto que hemos creado antes no ten√≠a la propiedad **isAvenger**, pero al recuperarla le hemos asignado un valor por defecto de **false**. Si no le hubi√©ramos asignado un valor por defecto, la variable **isAvenger** ser√≠a **undefined**.

As√≠ que si recuperamos una propiedad que no existe, la variable que se crear√° tendr√° el valor por defecto que le hayamos asignado. Y lo hacemos usando el operador **=**.

::: {.callout-tip}
Esto es muy √∫til, por ejemplo, para recuperar opciones o configuraci√≥n del usuario que quiz√°s no ha definido todos los valores pero tenemos claro qu√© comportamiento queremos que tenga nuestra aplicaci√≥n por defecto.
:::

# Objetos anidados y atajo

Ya sabemos que podemos tener un objeto dentro de un objeto:

``` javascript
const spiderman = {
  name: 'Spidey',
  universe: 42,
  powers: ['web', 'invisibility', 'spider-sense'],
  partner: {
    name: 'Mary Jane',
    universe: 42,
    powers: ['red hair', 'blue eyes']
  }
}
```

Para acceder a las propiedades de un objeto anidado, podemos usar la notaci√≥n de corchetes o la notaci√≥n de punto:

``` javascript
console.log(spiderman.partner.name) // 'Mary Jane'
console.log(spiderman['partner']['name']) // 'Mary Jane'
```

Si queremos recuperar la propiedad **name** del objeto **partner** y guardarla en una variable, podemos hacerlo as√≠:

``` javascript
const { partner } = spiderman
const { name } = partner
console.log(name) // 'Mary Jane'
```

Pero tambi√©n podemos hacerlo en una sola l√≠nea:

``` javascript
const { partner: { name } } = spiderman
console.log(name) // 'Mary Jane'
```

Lo que estamos haciendo es: del objeto **spiderman** extrae la propiedad **partner**, y de esta, extrae la propiedad **name**. Como resultado s√≥lo crearemos la variable **name** con el valor **'Mary Jane'**.

# Quiz

:::{.question}
¬øC√≥mo se llama el atajo que nos permite recuperar el valor de una propiedad de un objeto?

:::{.choices}
:::{.choice}
dot notation o notaci√≥n de punto
:::

::: {.choice .correct-choice}
desestructuraci√≥n o destructuring
:::

:::{.choice}
extracting o extracci√≥n
:::
:::
:::

:::{.question}
¬øQu√© se imprimir√° en la consola al ejecutar el siguiente c√≥digo:

``` javascript
const person = {
  name: 'John',
  age: 30,
  hobbies: ['reading', 'music', 'sports']
}
          
const { age: personAge } = person
console.log(age)
```

:::{.choices}
:::{.choice}
30
:::

::: {.choice .correct-choice}
ReferenceError: age is not defined
:::

:::{.choice}
undefined
:::
:::
:::

:::{.question}
¬øQu√© se imprimir√° en la consola al ejecutar el siguiente c√≥digo:

``` javascript
const person = {
  name: 'John',
  age: 30,
  hobbies: ['reading', 'music', 'sports']
}
          
const { 
  weight = 70,
  height = 180,
  } = person

console.log(weight, height)
```

:::{.choices}
::: {.choice .correct-choice}
70 180
:::

:::{.choice}
ReferenceError: weight is not defined
:::

:::{.choice}
undefined undefined
:::
:::
:::

# Iterando Objetos en JavaScript

El manejo de objetos es uno de los pilares en JavaScript y es crucial conocer c√≥mo podemos iterar o recorrer los mismos. Existen varias formas de hacerlo y en esta clase vamos a revisar algunas de las m√°s comunes: el bucle **for...in** y los m√©todos **Object.keys()**, **Object.values()** y **Object.entries()**.

## Iterando con for...in

La estructura de control **for...in** nos permite crear un bucle que itera sobre todas las propiedades enumerables de un objeto, en un orden arbitrario.

``` javascript
const spiderman = {
  name: 'Spidey',
  universe: 42,
  powers: ['web', 'invisibility', 'spider-sense']
}

for (const property in spiderman) {
  console.log(`${property}: ${spiderman[property]}`);
}

// -> name: Spidey
// -> universe: 42
// -> powers: web,invisibility,spider-sensibles
```

::: {.callout-tip}
No confundas el bucle **for...in** con el de **for...of** que vimos en la secci√≥n de arrays. El primero itera sobre las propiedades enumerables de un objeto, mientras que el segundo itera sobre los elementos de un objeto iterable (como los elementos de un array, por ejemplo).
:::

# Transformar un objeto en un array

A veces queremos transformar un objeto en un array para poder iterar sobre √©l. Para esto podemos utilizar el m√©todo **Object.keys(), Object.values()** o **Object.entries()**.

Cada uno de estos m√©todos retorna un array, pero cada uno de ellos contiene elementos diferentes. Vamos a verlos uno por uno.

## Iterar con Object.keys()

El m√©todo **Object.keys()** retorna un array con las propiedades enumerables de un objeto.

``` javascript
const spiderman = {
  name: 'Spidey',
  universe: 42,
  powers: ['web', 'invisibility', 'spider-sense']
}

const properties = Object.keys(spiderman)

console.log(properties.length) // 3

properties.forEach(property => {
  console.log(property)
})

// -> name
// -> universe
// -> powers
```

Este c√≥digo hace algo muy similar al anterior, pero utilizando **Object.keys()** para obtener las propiedades del objeto.

::: {.callout-tip}
**¬øQu√© son las propiedades enumerables?** Por defecto, cuando a√±adimos propiedades a un objeto, estas son enumerables, es decir, que se pueden iterar sobre ellas. Sin embargo, como veremos m√°s adelante, podemos crear propiedades que, por lo que sea, nos interesa que no sean enumerables. A veces estas son m√°s de uso interno, como m√©todos auxiliares que el propio lenguaje JavaScript tiene, y no queremos que aparezcan cuando iteramos sobre un objeto.
:::

## Iterando con Object.values()

El m√©todo **Object.values()** retorna un array con los valores correspondientes a las propiedades enumerables de un objeto.

``` javascript
const values = Object.values(spiderman)

values.forEach(value => {
  console.log(value)
})

// -> Spidey
// -> 42
// -> [ 'web', 'invisibility', 'spider-sense' ]
```

Como ves, la diferencia con **Object.values()** es que este m√©todo retorna los valores y **Object.keys()** retorna las propiedades.

## Iterando con Object.entries()

El m√©todo **Object.entries()** retorna un array de arrays, donde cada subarray es un par \[propiedad, valor\] correspondiente a las propiedades enumerables de un objeto.

``` javascript
const entries = Object.entries(spiderman)

entries.forEach(entry => {
  console.log(entry)
})

// -> [ 'name', 'Spidey' ]
// -> [ 'universe', 42 ]
// -> [ 'powers', [ 'web', 'invisibility', 'spider-sense' ] ]
```

Lo interesante es que este m√©todo nos da acceso tanto a las propiedades como a los valores. Lo puedes ver m√°s claro en el siguiente ejemplo:

``` javascript
const entries = Object.entries(spiderman)

entries.forEach(entry => {
  const property = entry[0]
  const value = entry[1]

  console.log(`${property}: ${value}`)
})
```

# Actividad Pr√°ctica

Tienes una funci√≥n que recibe un objeto como par√°metro. La funci√≥n debe retornar un array con el nombre de las propiedades que su tipo sea **boolean**.

Por ejemplo, para el objeto **{ a: true, b: 42, c: false }** la funci√≥n debe retornar **\['a', 'c'\]** ya que son las dos propiedades que tienen valores booleanos.

``` javascript
function getKeysOfBooleanValues(obj) {
    // tu c√≥digo aqu√≠
  }
```

<details>

<summary>Ver soluci√≥n</summary>

``` javascript
function getKeysOfBooleanValues(obj) {
  return Object.keys(obj).filter(key => typeof obj[key] === 'boolean')
}
```

</details>

# Operador de Encadenamiento Opcional

Si intentamos acceder a una propiedad de un objeto que no existe... **¬°se romper√° nuestra aplicaci√≥n!**

Por suerte, existen formas de evitar que esto ocurra. En esta clase veremos algunas de ellas y presentaremos **el operador de Encadenamiento Opcional**, tambi√©n llamado *Optional Chaining*.

Este operador es especialmente √∫til cuando trabajamos con objetos que podr√≠an tener estructuras complejas o variables que podr√≠an no estar definidas en determinados momentos de la ejecuci√≥n de nuestro c√≥digo.

# **El error fatal de intentar leer una propiedad de** undefined

**Uno de los errores m√°s comunes en JavaScript**, y que estoy seguro que ver√°s tarde o temprano, es el que dice **que no puedes leer una propiedad de undefined**.

Este error ocurre cuando intentamos acceder a una propiedad de un objeto que no existe. Por ejemplo:

``` javascript
const gamesystem = {
  name: 'PS5',
  price: 550,
  specs: {
    cpu: 'AMD Ryzen Zen 2',
    gpu: 'AMD Radeon RDNA 2',
  }
}

console.log(gamesystem.name) // -> PS5

console.log(gamesystem.specifications) // -> undefined

console.log(gamesystem.specifications.ram) 
// ‚ùå Uncaught TypeError: Cannot read property 'ram' of undefined
```

El error parece inocente pero f√≠jate. En lugar de usar la propiedad **specs** hemos usado **specifications**. Pero esto es suficiente para que JavaScript nos diga que no puede leer la propiedad **ram** de **undefined**.

# Evitar el error con if

Una forma de evitar este error es usando un **if** para comprobar si la propiedad existe antes de intentar acceder a ella:

``` javascript
if (typeof gamesystem.specifications === 'object') {
  console.log(gamesystem.specifications.ram)
} else {
  console.log('No hay especificaciones')
}
```

::: {.callout-tip}
¬°Cuidado con esto! Al usar el operador **typeof** con un valor **null** nos dice que es **object**. Esto es un error hist√≥rico del lenguaje. As√≠ que si la propiedad **specifications** es **null**, el **if** se ejecutar√° y obtendremos un error al intentar acceder a **ram**. Para evitar esto, podemos a√±adir una comprobaci√≥n extra: **gamesystem.specifications !== null**.
:::

Estamos usando el operador **typeof** para comprobar si la propiedad **specifications** es un objeto. Ya lo vimos en la primera secci√≥n del curso y nos ayuda a asegurarnos que **specifications** existe y es un objeto, antes de acceder a su propiedad **ram**.

## El operador in para comprobar si una propiedad existe

Otra forma de comprobar si una propiedad existe es usando el operador **in**. Este operador comprueba si una propiedad existe en un objeto y devuelve **true** o **false**:

``` javascript
console.log('name' in gamesystem) // -> true
console.log('specifications' in gamesystem) // -> false
console.log('specs' in gamesystem) // -> true

if ('specifications' in gamesystem) {
  console.log(gamesystem.specifications.ram)
} else {
  console.log('No hay especificaciones')
}
```

¬°Pero ojo! ¬øQu√© pasa si la propiedad existe pero su valor es **undefined**?

``` javascript
const gamesystem = {
  name: 'PS5',
  price: 550,
  specifications: undefined,
}

console.log('specifications' in gamesystem) // -> true

gamesystem.specifications.ram
// ‚ùå Uncaught TypeError: Cannot read property 'ram' of undefined
```

El operador **in** puede ser interesante para comprobar si una propiedad existe en un objeto, pero no nos sirve para comprobar si el valor de esa propiedad es **undefined** y habr√≠a que hacer comprobaciones extra para evitar el error.

``` javascript
if (
  'specifications' in gamesystem &&
  gamesystem.specifications !== undefined &&
  gamesystem.specifications !== null) {
  console.log(gamesystem.specifications.ram)
} else {
  console.log('No hay especificaciones')
}
```

Mucho c√≥digo para algo tan simple. Por suerte, existe una forma m√°s sencilla de hacerlo.

## El operador de Encadenamiento Opcional, ?.

El Operador de Encadenamiento Opcional **?**. permite leer el valor de una propiedad ubicada profundamente dentro de una cadena de objetos conectados, sin tener que validar expresamente que cada referencia en la cadena es v√°lida.

``` javascript
const gamesystem = {
  name: 'PS5',
  price: 550,
  specs: {
    cpu: 'AMD Ryzen Zen 2',
    gpu: 'AMD Radeon RDNA 2',
  }
}

console.log(gamesystem.specifications?.cpu)
// -> undefined
console.log(gamesystem.specs?.cpu)
// -> AMD Ryzen Zen 2
```

Si la propiedad **specifications** no existe, el operador **?**. devuelve **undefined** y no se produce ning√∫n error. Si la propiedad existe, el operador **?**. devuelve el valor de la propiedad.

## Beneficios del Operador de Encadenamiento Opcional

Uno de los principales beneficios del operador de encadenamiento opcional es que simplifica nuestro c√≥digo y lo hace m√°s legible. En lugar de tener que hacer varias comprobaciones para asegurarnos de que un objeto y sus propiedades existen, podemos intentar acceder directamente a la propiedad que nos interesa, y JavaScript no se quejar√° si no existe.

Este operador es especialmente √∫til en aplicaciones con datos din√°micos, donde no siempre podemos garantizar la estructura exacta de nuestros objetos.

``` javascript
const user = {
  name: 'Peter',
  settings: {
    theme: 'dark',
    notifications: {
      email: true,
      push: false,
      marketing: undefined
    }
  }
}

// la forma cl√°sica de acceder a una propiedad anidada
// de forma segura
let email = undefined
if (user && user.settings &&
  user.settings.notifications &&
  user.settings.notifications.email) {
  email = user.settings.notifications.email
}

console.log(email) // -> true

// con Optional Chaining Operator
const email = user?.settings?.notifications?.email
console.log(email) // -> true
```

El operador de encadenamiento opcional es una excelente herramienta para trabajar con objetos en JavaScript, especialmente cuando no podemos garantizar la estructura o presencia de ciertos datos. **Nos ayuda a escribir un c√≥digo m√°s limpio, legible y resistente a errores**.

# Actividad Pr√°ctica

Somos un equipo de submarinistas. Estamos explorando el fondo marino pero no sabemos qu√© nos vamos a encontrar porque vamos casi a ciegas. Vamos con un peque√±o robot y funciona con un programa que recibe tres par√°metros:

-   Un objeto con la informaci√≥n del fondo marino
-   Una cadena de texto con el nombre del lugar que queremos explorar
-   Una cadena de texto con el nombre del objeto que queremos encontrar

Por ejemplo. Con el objeto **ocean** que nos llega como primer par√°metro, podemos explorar el lugar **deep** y buscar el objeto **treasure**. As√≠ que intentar√≠amos acceder a **ocean.deep.treasure**.

Si lo encontramos el robot nos devuelve **true** y si no lo encuentra nos devuelve **false**. S√≥lo necesitamos saber si lo hemos encontrado o no, no necesitamos saber su valor.

Vamos a necesitar asegurarnos que el robot no se rompa, que cuesta mucho dinero, en el caso que no pueda encontrar el lugar o el objeto que le hemos pedido. As√≠ que vamos a usar el operador de encadenamiento opcional para evitar errores.

Pista: ¬°Recuerda que en una clase anterior hemos visto c√≥mo podemos acceder a una propiedad de un objeto usando una variable! Por ejemplo, si tenemos un objeto **person** y una variable **key** con el valor **name**, podemos acceder a la propiedad **name** del objeto **person** usando **person\[key\]** y ser√≠a como hacer **person.name**.

``` javascript
function searchInOcean(ocean, section, item) {
    // tu c√≥digo aqu√≠
  }
```

<details>

<summary>Ver soluci√≥n</summary>

``` javascript
function searchInOcean(ocean, section, item) {
  return ocean?.[section]?.[item] !== undefined
}
```

</details>

# Rest Operator

El operador de propagaci√≥n o **rest operator** es una caracter√≠stica de JavaScript que nos permite capturar un n√∫mero indefinido de argumentos en una funci√≥n. Es muy √∫til cuando no sabemos cu√°ntos argumentos vamos a recibir o queremos trabajar con un n√∫mero variable de argumentos.

## Sintaxis del operador de propagaci√≥n

El operador de propagaci√≥n se representa con tres puntos suspensivos **...** seguidos de un nombre de variable. Por convenci√≥n, se suele usar el nombre **rest**.

``` javascript
function sum(...rest) {
  console.log(rest)
}

sum(1, 2, 3, 4, 5) // -> [1, 2, 3, 4, 5]

sum('a', 'b', 'c') // -> ['a', 'b', 'c']

sum() // -> []
```

En este ejemplo, la funci√≥n **sum** recibe un n√∫mero indefinido de argumentos y los guarda en un array llamado **rest**. Luego, simplemente imprimimos el array **rest** por consola.

## Usos comunes del operador de propagaci√≥n

El operador de propagaci√≥n es muy vers√°til y se puede utilizar en muchas situaciones diferentes. Algunos de los usos m√°s comunes son:

-   **Capturar argumentos de una funci√≥n**: como hemos visto en el ejemplo anterior, el operador de propagaci√≥n nos permite capturar un n√∫mero indefinido de argumentos en una funci√≥n.

-   **Concatenar arrays**: podemos usar el operador de propagaci√≥n para concatenar dos o m√°s arrays en uno solo.

``` javascript
const arr1 = [1, 2, 3]
const arr2 = [4, 5, 6]
const arr3 = [...arr1, ...arr2]

console.log(arr3) // -> [1, 2, 3, 4, 5, 6]
```

-   **Copiar arrays**: tambi√©n podemos usar el operador de propagaci√≥n para copiar un array.

``` javascript
const arr1 = [1, 2, 3]
const arr2 = [...arr1]

console.log(arr2) // -> [1, 2, 3]
```

-   **Crear objetos**: podemos usar el operador de propagaci√≥n para crear un nuevo objeto a partir de uno existente.

``` javascript
const obj1 = { a: 1, b: 2 }
const obj2 = { ...obj1, c: 3 }

console.log(obj2) // -> { a: 1, b: 2, c: 3 }
```

-   **Eliminar propiedades de un objeto**: tambi√©n podemos usar el operador de propagaci√≥n para eliminar propiedades de un objeto.

``` javascript
const obj1 = { a: 1, b: 2, c: 3 }
const { c, ...obj2 } = obj1

console.log(obj2) // -> { a: 1, b: 2 }
```

## Rest Operator vs Spread Operator

Es importante tener en cuenta que el operador de propagaci√≥n o **rest operator** es diferente del operador de propagaci√≥n o **spread operator**. Aunque ambos utilizan la misma sintaxis de tres puntos suspensivos **...**, tienen diferentes prop√≥sitos y se utilizan en diferentes contextos.

-   **Rest Operator**: se utiliza para capturar un n√∫mero indefinido de argumentos en una funci√≥n o para desestructurar un objeto o array en variables.

-   **Spread Operator**: se utiliza para expandir un objeto o array en otro objeto o array, para concatenar arrays o para copiar un objeto o array.

# Actividad Pr√°ctica

Tenemos una funci√≥n que recibe un n√∫mero indefinido de argumentos. La funci√≥n debe devolver un array con los argumentos que sean de tipo **string**.

Por ejemplo, si llamamos a la funci√≥n con los argumentos **'a', 1, 'b', 2, 'c'**, la funci√≥n deber√≠a devolver **\['a', 'b', 'c'\]**.

``` javascript
function getStrings(...rest) {
    // tu c√≥digo aqu√≠
  }
```

<details>
<summary>Ver soluci√≥n</summary>

``` javascript
function getStrings(...rest) {
  return rest.filter(arg => typeof arg === 'string')
}
```

</details>

# Promesas y async/await

Las promesas son un objeto de JavaScript que representa la eventual finalizaci√≥n (o falla) de una operaci√≥n as√≠ncrona, y su resultado.

Las promesas son una forma de trabajar con c√≥digo as√≠ncrono en JavaScript. Nos permiten ejecutar tareas en segundo plano y manejar el resultado de esas tareas de forma m√°s sencilla y legible.

## Crear una promesa

Para crear una promesa, usamos la clase **Promise** y pasamos una funci√≥n con dos par√°metros: **resolve** y **reject**.

-   **resolve**: se llama cuando la promesa se resuelve satisfactoriamente y se le pasa el valor resultante.

-   **reject**: se llama cuando la promesa falla y se le pasa el motivo del fallo.

``` javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('¬°La promesa se ha resuelto!')
  }, 2000)
})

promise.then((result) => {
  console.log(result) // -> ¬°La promesa se ha resuelto!
})

// -> ¬°La promesa se ha resuelto!
```

En este ejemplo, creamos una promesa que se resuelve despu√©s de 2 segundos y luego imprimimos el resultado por consola.

## Encadenar promesas

Una de las caracter√≠sticas m√°s poderosas de las promesas es que podemos encadenarlas para ejecutar tareas en secuencia.

``` javascript
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('¬°La primera promesa se ha resuelto!')
  }, 2000)
})

const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('¬°La segunda promesa se ha resuelto!')
  }, 2000)
})

promise1
  .then((result) => {
    console
    console.log(result) // -> ¬°La primera promesa se ha resuelto!
    return promise2
  })
  .then((result) => {
    console.log(result) // -> ¬°La segunda promesa se ha resuelto!
  })

// -> ¬°La primera promesa se ha resuelto!
// -> ¬°La segunda promesa se ha resuelto!
```

En este ejemplo, creamos dos promesas y las encadenamos para que se ejecuten en secuencia. Primero se resuelve la **promise1** y luego la **promise2**.

## async/await

El operador **async** se utiliza para declarar una funci√≥n as√≠ncrona, es decir, una funci√≥n que devuelve una promesa. El operador **await** se utiliza para esperar a que una promesa se resuelva antes de continuar con la ejecuci√≥n de la funci√≥n.

``` javascript
async function fetchData() {
  const response = await fetch('https://api.example.com/data')
  const data = await response.json()
  return data
}

fetchData()
  .then((data) => {
    console.log(data)
  })
  .catch((error) => {
    console.error(error)
  })

// -> { key: 'value' }
```

En este ejemplo, creamos una funci√≥n **fetchData** que utiliza el operador **await** para esperar a que la promesa devuelta por **fetch** se resuelva antes de continuar con la ejecuci√≥n de la funci√≥n.

## Beneficios de async/await

El uso de **async/await** tiene varios beneficios:

-   **C√≥digo m√°s legible**: el uso de **async/await** hace que el c√≥digo sea m√°s f√°cil de leer y entender, ya que se parece m√°s a la forma en que escribimos c√≥digo s√≠ncrono.

-   **Manejo de errores**: podemos usar **try/catch** para manejar los errores de forma m√°s sencilla y clara.

-   **Encadenamiento de promesas**: podemos encadenar promesas de forma m√°s sencilla y legible.

-   **Mejor manejo de la l√≥gica as√≠ncrona**: **async/await** nos permite escribir c√≥digo as√≠ncrono de forma m√°s natural y estructurada.

# Actividad Pr√°ctica

Tenemos una funci√≥n que recibe un n√∫mero y devuelve una promesa que se resuelve con el doble del n√∫mero recibido.

``` javascript
function doubleNumber(number) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(number * 2)
    }, 2000)
  })
}

doubleNumber(5)
  .then((result) => {
    console.log(result) // -> 10
  })

// -> 10
```

Tu tarea es modificar la funci√≥n **doubleNumber** para que utilice **async/await** en lugar de crear una promesa manualmente.

``` javascript
async function doubleNumber(number) {
  // tu c√≥digo aqu√≠
}

doubleNumber(5)
  .then((result) => {
    console.log(result) // -> 10
  })

// -> 10
```

<details>
<summary>Ver soluci√≥n</summary>

``` javascript
async function doubleNumber(number) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(number * 2)
    }, 2000)
  })
}

doubleNumber(5)
  .then((result) => {
    console.log(result) // -> 10
  })

// -> 10
```

</details>

# Quiz

:::{.question}
¬øQu√© es una promesa en JavaScript?

:::{.choices}

:::{.choice}
Un objeto que representa la eventual finalizaci√≥n (o falla) de una operaci√≥n as√≠ncrona, y su resultado.
:::

:::{.choice}
Un objeto que representa un valor que puede estar disponible ahora, en el futuro o nunca.
:::

:::{.choice}
Un objeto que representa un valor que puede cambiar en cualquier momento.
:::

:::{.choice .correct-choice}
Un objeto que representa la eventual finalizaci√≥n (o falla) de una operaci√≥n as√≠ncrona, y su resultado.
:::

:::
:::

:::{.question}
¬øQu√© hace el operador **await** en una funci√≥n as√≠ncrona?

:::{.choices}

:::{.choice}
Espera a que una promesa se resuelva antes de continuar con la ejecuci√≥n de la funci√≥n.
:::

:::{.choice}
Detiene la ejecuci√≥n de la funci√≥n hasta que se resuelva una promesa.
:::

:::{.choice .correct-choice}
Espera a que una promesa se resuelva antes de continuar con la ejecuci√≥n de la funci√≥n.
:::

:::
:::

:::{.question}
¬øQu√© hace el operador **async** en una funci√≥n?

:::{.choices}

:::{.choice}
Declara una funci√≥n que devuelve una promesa.
:::

:::{.choice}
Declara una funci√≥n que se ejecuta de forma as√≠ncrona.
:::

:::{.choice .correct-choice}
Declara una funci√≥n as√≠ncrona que devuelve una promesa.
:::

:::
:::

# M√≥dulos

Los m√≥dulos son una forma de organizar y reutilizar c√≥digo en JavaScript. Nos permiten dividir nuestro c√≥digo en archivos separados y exportar e importar funciones, variables y clases entre ellos.

## Exportar e importar

Para exportar una funci√≥n, variable o clase de un m√≥dulo, usamos la palabra clave **export** seguida del nombre de la funci√≥n, variable o clase que queremos exportar.

``` javascript
// math.js
export function sum(a, b) {
  return a + b
}

export const PI = 3.14159
```

Para importar una funci√≥n, variable o clase de un m√≥dulo, usamos la palabra clave **import** seguida del nombre de la funci√≥n, variable o clase que queremos importar y el nombre del m√≥dulo entre llaves.

``` javascript
// app.js
import { sum, PI } from './math.js'

console.log(sum(1, 2)) // -> 3
console.log(PI) // -> 3.14159
```

## Exportar e importar por defecto

Tambi√©n podemos exportar e importar por defecto una funci√≥n, variable o clase de un m√≥dulo. Para exportar por defecto, usamos la palabra clave **export default** seguida del nombre de la funci√≥n, variable o clase que queremos exportar por defecto.

``` javascript
// math.js
export default function sum(a, b) {
  return a + b
}

export const PI = 3.14159
```

Para importar por defecto una funci√≥n, variable o clase de un m√≥dulo, usamos la palabra clave **import** seguida del nombre de la funci√≥n, variable o clase que queremos importar y el nombre del m√≥dulo entre llaves.

``` javascript
// app.js
import sum, { PI } from './math.js'

console.log(sum(1, 2)) // -> 3
console.log(PI) // -> 3.14159
```

## Exportar e importar todo

Tambi√©n podemos exportar e importar todo un m√≥dulo. Para exportar todo, usamos la palabra clave **export \***.

``` javascript
// math.js
export function sum(a, b) {
  return a + b
}

export const PI = 3.14159
```

Para importar todo un m√≥dulo, usamos la palabra clave **import \***.

``` javascript
// app.js
import * as math from './math.js'

console.log(math.sum(1, 2)) // -> 3
console.log(math.PI) // -> 3.14159
```

## M√≥dulos en el navegador

Los m√≥dulos tambi√©n se pueden utilizar en el navegador. Para importar un m√≥dulo en un archivo HTML, usamos la etiqueta **script** con el atributo **type="module"** y la ruta del archivo que queremos importar en el atributo **src**.

``` html
<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script type="module" src="app.js"></script>
</body>
</html>
```

En el archivo **app.js**, podemos importar un m√≥dulo de la misma forma que en Node.js.

``` javascript
// app.js
import { sum, PI } from './math.js'

console.log(sum(1, 2)) // -> 3
console.log(PI) // -> 3.14159
```

## M√≥dulos en Node.js

En Node.js, los m√≥dulos se pueden utilizar de la misma forma que en el navegador. Para exportar e importar un m√≥dulo, usamos la palabra clave **export** y **import**.

``` javascript
// math.js
export function sum(a, b) {
  return a + b
}

export const PI = 3.14159
```

``` javascript
// app.js
import { sum, PI } from './math.js'

console.log(sum(1, 2)) // -> 3
console.log(PI) // -> 3.14159
```

## M√≥dulos en CommonJS

En CommonJS, los m√≥dulos se pueden utilizar de la misma forma que en Node.js. Para exportar e importar un m√≥dulo, usamos la palabra clave **module.exports** y **require**.

``` javascript
// math.js
function sum(a, b) {
  return a + b
}

const PI = 3.14159

module.exports = { sum, PI }
```

``` javascript
// app.js
const { sum, PI } = require('./math.js')

console.log(sum(1, 2)) // -> 3
console.log(PI) // -> 3.14159
```

# Actividad Pr√°ctica

Tenemos un m√≥dulo que exporta una funci√≥n que recibe un n√∫mero y devuelve el doble del n√∫mero recibido.

``` javascript
// math.js
export function doubleNumber(number) {
  return number * 2
}
```

Tu tarea es importar la funci√≥n **doubleNumber** en un archivo **app.js** y usarla para duplicar el n√∫mero **5**.

``` javascript
// app.js
// tu c√≥digo aqu√≠
```

<details>
<summary>Ver soluci√≥n</summary>

``` javascript
// app.js
import { doubleNumber } from './math.js'

console.log(doubleNumber(5)) // -> 10
```

</details>

# Quiz

:::{.question}
¬øQu√© es un m√≥dulo en JavaScript?

:::{.choices}

:::{.choice}
Un objeto que representa la eventual finalizaci√≥n (o falla) de una operaci√≥n as√≠ncrona, y su resultado.
:::

:::{.choice}
Un archivo que contiene c√≥digo JavaScript que se puede exportar e importar en otros archivos.
:::

:::{.choice .correct-choice}
Un archivo que contiene c√≥digo JavaScript que se puede exportar e importar en otros archivos.
:::

:::
:::

:::