# JavaScript

Esté capítulo está basado en el Curso de **"Aprende JavaScript"** en la url [AprendeJavaScript.dev](https://aprendejavascript.dev/) creado por Miguel Ángel [statick](https://porfolio.dev/#sobre-mi), el cual es un desarrollador FullStack y Creador de Contenido, sin más que agregar comencemos.

## ¿Qué es JavaScript?

JavaScript es uno de los lenguajes de programación más usados y populares del mundo. Nació en 1995 para darle interactividad a las páginas web y desde entonces ha evolucionado hasta convertirse en un lenguaje de programación de propósito general. Dicho de otra forma: se puede usar casi para cualquier cosa.

## ¿Qué es programar?

Es el acto de construir un programa o conjunto de instrucciones para decirle a una computadora qué y cómo queremos que haga algo. No es diferente a cuando "programamos" la lavadora, sólo que en vez de pulsar un botón, vamos a usar texto. A este texto se le conoce como "código".

## ¿Por qué aprender JavaScript?

JavaScript es, a día de hoy, el único lenguaje de programación que todos los navegadores web entienden sin necesidad de realizar ningún paso previo. Esto hace que casi cualquier página web que visitas tiene alguna línea de JavaScript en su interior.

Su curva de aprendizaje para iniciarte es muy corta ya que en muy poco tiempo puedes empezar a hacer cosas interesantes. Para alcanzar a ser un buen programador en JavaScript necesitarás años de práctica, pero para empezar a hacer cosas interesantes bastará con poco tiempo.

Por si fuera poco, JavaScript es uno de los lenguajes de programación más demandados en el mercado laboral. Es normal, ya que es un lenguaje muy versátil y que se puede usar para casi cualquier cosa.

Además, con JavaScript vas a poder desarrollar casi cualquier cosa que te propongas. Desde aplicaciones web, móviles y de escritorio a backend, videojuegos, inteligencia artificial, Internet de las cosas. Todo un mundo de posibilidades con un sólo lenguaje.

## Quiz

:::::: question
**¿JavaScript sólo se puede usar para crear páginas web?**

::::: choices
::: choice
Verdadero
:::

::: {.choice .correct-choice}
Falso
:::
:::::
::::::

::::::: question
**¿Qué es programar en el mundo del software?**

:::::: choices
::: choice
Crear páginas web y que el usuario pueda usarlas
:::

::: {.choice .correct-choice}
Es el acto de construir un programa o conjunto de instrucciones para decirle a una comptuadora qué y cómo queremos que haga algo
:::

::: choice
Cualquier cosa que hagamos en un ordenador
:::
::::::
:::::::

# La consola del navegador

Ahora es necesario utilizar un navegador web, ya que vamos a empezar a escribir código JavaScript.

Todos los navegadores tienen una herramienta llamada **consola**. La consola nos permite ejecutar código JavaScript en tiempo real y ver el resultado. También ahí podemos ver los errores, advertencias y trazas que se producen en nuestro código.

Aunque podemos ejecutar código JavaScript de otras formas, para empezar, vamos a usar esta herramienta que nos ofrece el navegador.

::: callout-tip
Recuerda que llamamos código a las instrucciones que le damos a la computadora para que haga algo.
:::

## Cómo abrir la consola

Para abrir la consola del navegador debes hacer lo siguiente:

1.  Abre tu navegador web favorito, por ejemplo, Google Chrome, Firefox, Safari o Edge.

2.  Ve a la página **about:blank** en la barra de direcciones. Así evitaremos que la página web que hemos cargado nos moleste.

3.  Haz **click derecho** en cualquier parte de la página y selecciona la opción **Inspeccionar Elemento** o **Inspect**.

Aquí podrás ejecutar tu código JavaScript y ver el resultado. Es lo que usaremos en un inicio. Más adelante pasaremos a usar un editor como **VSCode**.

En **Google Chrome** o **Brave**, este es el aspecto de la consola

![](images/paste-28.png)

En **Firefox**, este es el aspecto de la consola

![](images/paste-29.png)

## Quiz

:::::: question
**¿Para qué sirve la consola del navegador?**

::::: choices
::: choice
La consola sirve para poder jugar con JavaScript. Es la única forma de poder ejecutar nuestro código y por eso todos los navegadores lo incorporan.
:::

::: {.choice .correct-choice}
La consola nos permite ejecutar código JavaScript en tiempo real y ver el resultado. También ahí podemos ver los errores, advertencias y trazas que se producen en nuestro código.
:::
:::::
::::::

# Editores y entornos de desarrollo

En la actualidad existen muchos editores de código y entornos de desarrollo que nos permiten escribir código de forma más cómoda y eficiente. Algunos de los más populares son:

-   **Visual Studio Code**: Es uno de los editores de código más populares y es el que usaremos en este curso.

    ::: center
    ![](images/paste-41.png)
    :::

-   **Runjs**: Un entorno de desarrollo online que nos permite escribir código JavaScript y ver el resultado en tiempo real.

    ::: center
    ![](images/paste-38.png)
    :::

-   **Zed Code Editor**: Un editor de código muy sencillo y minimalista.

    ::: center
    ![](images/paste-39.png)
    :::

# Tipos de Datos

En JavaScript, como cualquier otro lenguaje de programación, vamos a querer trasladar la información del mundo real a nuestro código. Para ello, necesitamos entender qué tipos de datos existen en el lenguaje para poder representar la información que necesitamos.

En JavaScript tenemos 9 tipos de datos que se dividen en dos grandes grupos: **primitivos** o **no primitivos**.

## Tipos Primitivos.

Dentro de los tipos primitivos tenemos 7 tipos de datos:

-   number
-   string
-   boolean
-   null
-   undefined
-   symbol
-   bigint

No te preocupes, no tienes ni recordarlos ni entenderlos todos ahora. En esta lección vamos a ver los tres primeros que son, sin ninguna duda, los que más vamos a usar al inicio del curso.

## Números

Los números (tipo number) son los datos más básicos que podemos representar en JavaScript. En JavaScript, no hay una diferencia entre números enteros y números decimales, todos los números son de tipo number:

``` javascript
7
3.14
19.95
2.998e8
-1
```

## Operadores aritméticos

Con los números, puedes usar los operadores aritméticos para realizar operaciones matemáticas. En JavaScript tenemos los siguientes operadores aritméticos:

-   +: suma
-   -: resta
-   \*: multiplicación
-   /: división
-   %: módulo (resto de la división)
-   \*\*: exponente

Al usar los operadores aritméticos, el resultado siempre será un número. Por ejemplo:

``` javascript
2 + 2 // 4
4 - 2 // 2
3 * 2 // 6
2 / 2 // 1
2 % 2 // 0
3 ** 3 // 27
```

## ¿Qué significa el // que ves en los ejemplos?

Es un comentario. En JavaScript, los comentarios se escriben con **//** y todo lo que escribas después de\`*//* será ignorado por el navegador. Los comentarios son muy útiles para explicar qué hace nuestro código.

Al igual que las matemáticas, las operaciones siguen un orden de precedencia. Por ejemplo, si queremos calcular el resultado de **2 + 2 \* 3**, primero se multiplicará **2 \* 3** y luego se sumará **2 + 6**. El resultado será **8**.

También puedes usar paréntesis para cambiar el orden de las operaciones.

``` javascript
2 + 2 * 3 // 8
(2 + 2) * 3 // 12
```

## Cadenas de texto

La cadena de texto (tipo string) es otro tipo de dato muy común. En JavaScript, las cadenas de texto se representan entre **comillas simples**, **dobles** o **acentos graves**:

``` javascript
'Estás aprendiendo JavaScript'

"JavaScript te va a gustar"

`Esto es una cadena de texto`
```

Las comillas simples y dobles funcionan igual, pero al usar **acentos graves** podemos escribir cadenas de texto que ocupen varias líneas:

``` javascript
`Esto es una cadena de texto
que ocupa varias líneas. Puedes escribir
tantas líneas como quieras`
```

## Concatenación

Para unir dos cadenas de texto, podemos usar el operador +:

``` javascript
'Estás aprendiendo ' + 'JavaScript' // 'Estás aprendiendo JavaScript'
```

Como ves, el operador **+** de concatenación de cadenas de texto es visualmente el mismo que el operador **+** de **suma de números**. El operador **+** funciona de forma diferente dependiendo del tipo de dato que estemos usando.

## Booleanos

Los booleanos representa sólo dos valores: true (verdadero) o false (falso). Por ejemplo:

-   ¿La luz está encendida (true) o apagada (false)?
-   ¿Está lloviendo (true) o no está lloviendo (false)?
-   ¿Está el usuario logueado (true) o no está logueado (false)?

Estos son ejemplos de preguntas que podemos responder con un valor booleano.

-   true
-   false

## Quiz

:::::: question
**¿Cuántos tipos de datos existen en JavaScript?**

::::: choices
::: choice
Sólo existen 2 tipos de datos
:::

::: {.choice .correct-choice}
9 tipos de datos que se dividen en dos grandes grupos
:::
:::::
::::::

::::::: question
**¿Cuántos valores se pueden representar en el tipo de dato Boolean?**

:::::: choices
::: choice
true y false
:::

::: {.choice .correct-choice}
Cualquier valor que se te ocurra
:::

::: choice
Números, cadenas de texto y verdadero/falso.
:::
::::::
:::::::

::::::: question
**El operador + se utiliza para...**

:::::: choices
::: choice
Sólo sirve para sumar dos números
:::

::: choice
Concatenar dos textos
:::

::: {.choice .correct-choice}
Depende del tipo de dato que se esté utilizando
:::
::::::
:::::::

# Los operadores de comparación

Los operadores de comparación en JavaScript nos permiten comparar dos valores. Siempre devuelven un valor booleano (true o false).

Por ejemplo, podemos comparar si un número es mayor que otro con el operador **\>**, o si un número es menor que otro con el operador **\<**.

``` javascript
5 > 3 // true
5 < 3 // false
```

También tenemos los operadores **\>=** y **\<=** que nos permiten comparar si un número es mayor o igual que otro, o si un número es menor o igual que otro.

``` javascript
5 >= 3 // true
5 >= 5 // true
5 <= 3 // false
5 <= 5 // true
```

Para saber si dos valores son iguales podemos usar el operador **===** o, para saber si son diferentes, el operador **!==**.

``` javascript
5 === 5 // true
5 !== 5 // false
```

## Actividad

1.  Escribe un código que compruebe si 10 es mayor o igual que 9

2.  Comprueba que 0 es igual a 0

<details>

<summary>Respuesta</summary>

R1.

``` javascript
10 >= 9 // true
```

R2.

``` javascript
0 === 0 // true
```

</detais>

## Comparando cadenas de texto

No sólo podemos usar los comparadores para comparar números, también podemos usarlos para comparar cadenas de texto y otros tipos de datos.

``` javascript
'JavaScript' === 'JavaScript' // true
'JavaScript' === 'Java' // false
"JavaScript" !== 'PHP' // true
`Estoy Aprendiendo JavaScript` === 'Estoy Aprendiendo JavaScript' // true
```

::: callout-tip
Fíjate que puedes comparar cadenas de texto que usan comillas simples, dobles o acentos graves. Al final, siguen siendo cadenas de texto y lo importante es que sean iguales.
:::

## ¿Y si usamos el operador \> con cadenas de texto?

Aunque no es muy común, podemos usar los operadores **\>** , **\>=**, **\<** y **\<=** para comparar cadenas de texto.

JavaScript comparará las cadenas de texto según el valor de su código Unicode.

Por ejemplo, la letra **A** tiene un valor de **65** y la letra **B** tiene un valor de **66**. Por lo tanto, la letra **A** es menor que la letra **B**. Pero ten cuidado, ya que las letras mayúsculas tienen un valor menor que las letras minúsculas.

``` javascript
'Alfa' > 'Beta' // false
'Omega' > 'Beta' // true
'alfa' > 'Alfa' // true
```

## Comparando booleanos

También podemos comparar booleanos con los operadores de comparación.

``` javascript
true === true // true
true === false // false
false !== false // false
```

Por si te preguntas cómo se comportan los operadores de mayor o menor que (**\>** y **\<**) con booleanos te diré que, aunque no tiene sentido, debes saber que true es mayor que false.

``` javascript
true > false // true
false < true // true
true > true // false
false < false // false
```

## Comparando valores de diferentes tipos

Por ahora hemos visto cómo comparar valores de un mismo tipo, pero ¿Qué pasa si queremos comparar valores de diferentes tipos? En JavaScript es algo que es posible pero no suele ser recomendable.

En clases posteriores veremos cómo funciona este tipo de mecanismo y explicaremos el operador de igualdad débil **==** y el operador de desigualdad débil **!=** pero, por ahora, nos limitaremos a utilizar siempre el operador de igualdad estricta **===** y el operador de desigualdad estricta **!==**.

## Quiz

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: question
**¿Cuál es el resultado de 24 \> 12?**

::::: choices
::: {.choice .correct-choice}
true
:::

::: choice
false
:::
:::::

:::::: question
**Los operadores de compración solo se pueden usar con números**

::::: choices
::: choice
Sí, sólo ahí tiene sentido
:::

::: {.choice .correct-choice}
No, se pueden usar con otros tipos de datos como cadenas de textos o boleanos
:::
:::::
::::::

# Operadores lógicos en JavaScript

Los operadores lógicos en JavaScript (y en muchos otros lenguajes de programación) se utilizan para evaluar expresiones lógicas.

En JavaScript, hay tres operadores lógicos: AND (&&), OR (\|\|) y NOT (!).

## Operador lógico AND &&

El operador lógico AND se indica con &&. Devuelve true cuando ambos valores que conecta son true.

``` javascript
true && true // → true
true && false // → false
false && false // → false
```

Un ejemplo en la vida real sería preguntar. **¿Están todas las luces encendidas?** Se comprueba cada luz y si todas están encendidas (true), entonces la respuesta es **true**. Si alguna luz está apagada (false), entonces la respuesta es **false**.

## Operador lógico OR \|\|

El operador lógico OR se indica con \|\| y devuelve true cuando cualquiera de los valores que conecta es true.

``` javascript
true || true // → true
true || false // → true
false || false // → false
```

Un ejemplo en la vida real sería preguntar. **¿Hay alguna luz encendida?** Se comprueba cada luz y si alguna está encendida (true), entonces la respuesta es **true**. Sólo si todas las luces están apagadas (false), entonces la respuesta es **false**.

## Operador lógico NOT !

El operador lógico NOT se indica con ! e invierte el valor de un valor booleano. Se pone delante del valor que queremos invertir.

``` javascript
!true // → false
!false // → true
```

Un ejemplo en la vida real sería pulsar el interruptor de la luz. Si la luz está encendida (true), entonces pulsando el interruptor la apagamos (false). Si la luz está apagada (false), entonces pulsando el interruptor la encendemos (true).

## Combinando operadores lógicos, aritméticos y de comparación

Los operadores lógicos y los operadores de comparación se pueden combinar para crear expresiones más complejas. Por ejemplo, podemos preguntar si un número está entre dos valores.

``` javascript
2 < 3 && 3 < 4 // → true
```

En este caso, la expresión se evalúa como **true** porque **2 \< 3** es **true** y **3 \< 4** es **true**. Si cualquiera de las dos expresiones fuera **false**, entonces la expresión sería **false**.

También puedes usar paréntesis para agrupar operaciones y usar operadores lógicos y aritméticos.

``` javascript
(2 + 2) < 3 && (10 < (8 * 2)) // → false
```

Igualmente, es importante que sepas que las operaciones aritméticas tienen precedencia sobre las operaciones de comparación.

``` javascript
2 + 2 < 3 && 10 < 8 * 2
// Primero se hacen las operaciones aritméticas:
// → 4 < 3 && 10 < 16
// Ahora las comparaciones:
// → false && true
// Finalmente:
// → false
```

## Actividad

1.  Comprueba si 7 es mayor que 8 y menor que 10

2.  Tenemos un producto en una tienda. Cuesta 1500 y tenemos un descuento del 25%. Tengo \$1150 en mi billetera. Escribe un código que me diga si puedo comprarlo. No utilizar parentesis.

<details>

<summary>Respuesta</summary>

R1.

``` javascript
7 > 8 && 7 < 10 // false
```

R2.

``` javascript
1150 >= 1500 * 0.75 // false
```

</details>

# Dos o más operandos

Aunque todos los ejemplos que has visto hasta ahora usan dos operandos, los operadores lógicos también pueden usarse con más de dos operandos.

``` javascript
true && true && true // → true
```

También puedes mezclar operadores lógicos:

``` javascript
true && true || false // → true
!true && !true // → false
false && true || !true // → false
```

Ahora te puede costar un poco entender qué está pasando, pero con la práctica te irá resultando más fácil. Prueba a hacer los ejercicios y a jugar con los operadores lógicos para que te vayan quedando más claros.

## Quiz

:::::: question
**¿Qué operador lógico se utiliza para comprobar si dos o más condiciones son verdaderas?**

::::: choices
::: choice
OR (\|\|)
:::

::: {.choice .correct-choice}
AND (&&)
:::
:::::
::::::

:::::: question
**¿Qué operador lógico se utiliza para invertir el valor de un booleano?**

::::: choices
::: choice
OR (\|\|)
:::

::: {.choice .correct-choice}
NOT (!)
:::
:::::
::::::

:::::: question
**¿Qué valor devuelve la expresión false \|\| true?**

::::: choices
::: choice
false
:::

::: {.choice .correct-choice}
true
:::
:::::
::::::

# Variables

A la hora de crear programas, es vital poder almacenar la información para poder utilizarla en un futuro. En JavaScript, usamos variables para conseguirlo.

Para crear una variable podemos usar la palabra reservada **let** y le damos un nombre a la variable. Por ejemplo:

``` javascript
let numero
```

Tenemos una variable llamada numero pero no le hemos asignado ningún valor. Para asignarle un valor, usamos el operador de asignación =:

``` javascript
let numero = 1
```

Ahora, podemos referirnos a la variable numero y obtener el valor que le hemos asignado.

``` javascript
numero + 1 // -> 1 + 1
```

También podemos reasignarle un valor a la variable:

``` javascript
numero = 5
numero + 1 // -> 5 + 1
```

::: callout-tip
¡Ojo! Si no guardas el valor de esta nueva operación, el valor de la variable **numero** seguirá siendo **5**.

``` javascript
numero = 5
numero + 1 // -> 5 + 1
numero + 1 // -> 5 + 1
```
:::

Ten en cuenta que el valor de la variable no tiene porque ser un número. Puede ser cualquier tipo de dato, como un texto o un booleano.

``` javascript
let welcomeText = 'Hola'
let isCool = true
```

## Actividad

1.  Crea una variable llamada mensaje y asígnale el valor "Hola JavaScript"

2.  Crea una variable llamada resultado y asígnale la suma de 2 y 3

<details>

<summary>Respuesta</summary>

R1.

``` javascript
let mensaje = 'Hola JavaScript'
```

R2.

``` javascript
let resultado = 2 + 3
```

</details>

## Constantes const

Las constantes son variables que no pueden ser reasignadas. Para crear una constante, usamos la palabra reservada const:

``` javascript
const PI = 3.1415
```

Si intentas reasignar el valor de una constante, obtendrás un error:

``` javascript
PI = 3 // -> TypeError: Assignment to constant variable.
```

Como no se pueden reasignar, las constantes siempre deben ser inicializadas con algún valor. Esto es otra diferencia respecto a let, que no es necesario inicializarla con un valor.

``` javascript
let numero // ✅
const RADIUS // ❌ SyntaxError: Missing initializer in const declaration
```

Son muy útiles para almacenar valores que no van a cambiar. Siempre que puedas, procura usar constantes para que tu código sea más predecible.

## Actividad

1.  Crea una constante llamada IS_DISABLED y asígnale el booleano true

<details>

<summary>Respuesta</summary>

``` javascript
const IS_DISABLED = true
```

</details>

## Variables var

En JavaScript, también podemos crear variables usando la palabra reservada **var**. Es la forma más antigua y es normal que encuentres muchos tutoriales que lo usen. Sin embargo, a día de hoy, no es recomendable usar **var** ya que tiene comportamientos extraños que pueden causar errores en tu código.

En una clase posterior te explicaré cuál es la diferencia entre **let**, **const** y **var** además de por qué, siempre que puedas, deberías evitar var.

## El nombre de las variables

En JavaScript, los nombres de las variables pueden contener letras, números y el guión bajo (\_). Además, el primer carácter del nombre de la variable no puede ser un número.

Es importante tener en cuenta que los nombres de las variables son sensibles a las mayúsculas y minúsculas, lo que significa que **miVariable** y **mivariable** son dos variables diferentes en JavaScript.

``` javascript
let miVariable = 1
let mivariable = 2
miVariable + mivariable // -> 1 + 2
```

También es importante que los nombres de las variables sean descriptivos. Por ejemplo, si queremos almacenar el nombre de un usuario, podemos llamar a la variable userName. De esta forma, cuando leamos el código, sabremos que la variable contiene el nombre de un usuario.

``` javascript
let n = 'Pepe' // ❌ Mal, no es descriptivo
let userName = 'Juan' // ✅ Bien, se entiende
```

## Convenciones y nomenclaturas

En JavaScript, existen diferentes nomenclaturas para nombrar las variables: **camelCase**, **snake_case** y **SCREAMING_CASE**.

**camelCase** es la forma más común de nombrar las variables en JavaScript. Consiste en escribir la primera palabra en minúsculas y las siguientes palabras con su primera letra en mayúsculas. Por ejemplo:

``` javascript
let camelCase = 1
let camelCaseIsCool = 2
let userName = 'statick'
```

**snake_case** es una forma de nombrar que consiste en escribir todas las palabras en minúsculas y separarlas con guiones bajos. Por ejemplo:

``` javascript
let snake_case = 1
let snake_case_is_cool = 2
let user_name = 'statick'
```

En algunos lenguajes de programación es muy común usar snake_case para nombrar las variables. En JavaScript no lo es tanto, pero todavía puedes encontrar código que lo use.

Lo más habitual, y es buena idea, es usarlo en los nombres de archivos. Por ejemplo, **mi_archivo.js**. Esto es porque algunos sistemas operativos distinguen entre mayúsculas y minúsculas y, por tanto, **mi_archivo.js** y **Mi_archivo.js** son dos archivos diferentes.

::: callout-tip
También existe kebab-case, que es una forma de nombrar que consiste en escribir todas las palabras en minúsculas y separarlas con guiones. Por ejemplo: mi-archivo.js. Es muy similar a snake_case pero con guiones en vez de guiones bajos. No se puede usar para nombrar variables pero sí es común usarlo en los nombres de archivos.
:::

**SCREAMING_CASE** es una forma de nombrar que consiste en escribir todas las palabras en mayúsculas y separarlas con guiones bajos. Por ejemplo:

``` javascript
const SCREAMING_CASE = 1
const SCREAMING_CASE_IS_COOL = 2
const USER_NAME = 'statick'
```

Para las constantes, con valores que no van a cambiar, es muy común usar **SCREAMING_CASE**. Así se puede distinguir fácilmente de las variables que sí cambian de valor. Por eso, no debes usarla para nombrar variables con **let**.

## Quiz

:::::: question
**¿Qué es una variable?**

::::: choices
::: {.choice .correct-choice}
En JavaScript, una variable es un contenedor de información que se utiliza para almacenar datos en un programa.
:::

::: choice
Una variable es un tipo de dato que se utiliza para almacenar información en un programa.
:::
:::::
::::::

:::::: question
**¿Qué peculiaridad tienen las variables const en JavaScript?**

::::: choices
::: {.choice .correct-choice}
No se pueden reasignar
:::

::: choice
Sólo pueden guardar números
:::
:::::
::::::

::::::: question
**Siempre hay que asignar un valor a una variable**

:::::: choices
::: choice
Sí, siempre
:::

::: choice
No, nunca
:::

::: {.choice .correct-choice}
Sólo si es una variable const
:::
::::::
:::::::

## null y undefined

¿Recuerdas que te he comentado que existen diferentes tipos de datos en JavaScript? Hemos visto números, cadenas de texto y booleanos.

En esta clase vas a aprender otros dos tipos de datos que, aunque son similares, tienen ligeras diferencias. Son **null** y **undefined**.

La particularidad de estos dos tipos de datos es que cada uno sólo tiene un valor. El tipo **null** sólo puede tener el valor **null** y el tipo **undefined** sólo puede tener el valor undefined.

::: callout-tip
Es como el tipo booleano que podía ser **true** y **false** pero, en este caso, sólo tiene un valor.
:::

## La diferencia entre null y undefined

Mientras que null es un valor que significa que algo no tiene valor, undefined significa que algo no ha sido definido. Por ejemplo, si creamos una variable sin asignarle ningún valor, su valor será undefined:

``` javascript
let rolloDePapel // -> undefined
```

También podemos asignar directamente el valor undefined a una variable:

``` javascript
let rolloDePapel = undefined // -> undefined
```

En cambio, para que una variable tenga el valor null, sólo podemos conseguirlo asignándole explícitamente ese valor:

``` javascript
let rolloDePapel = null
```

Un caso bastante ilustrativo para entender la diferencia entre null y undefined es el siguiente:

![](images/paste-30.png)

## Actividad

1.  Crea una variable con let llamada capacidad y asígnale un valor null

2.  Crea una variable con let llamada dinero y asegúrate que tenga un valor de undefined

<details>

<summary>Respuesta</summary>

R1.

``` javascript
let capacidad = null
```

R2.

``` javascript
let dinero
```

</details>

## Comparaciones con null y undefined

Al usar la igualdad estricta que hemos visto en la clase anterior, null y undefined son considerados diferentes entre sí:

``` javascript
null === undefined // -\> false
```

Sólo cuando comparamos null con null o undefined con undefined obtenemos true:

``` javascript
null === null // -\> true undefined === undefined // -\> true
```

## Quiz

:::::: question
**null y undefined son dos valores que significan lo mismo.**

::::: choices
::: choice
Sí, ambos indican la ausencia de valor.
:::

::: {.choice .correct-choice}
No, null es un valor que indica algo vacío, mientras que undefined indica algo que no está definido todavía.
:::
:::::
::::::

::::::: question
**¿Qué valor tiene una variable a la que no se le ha asignado nada al declararla?**

:::::: choices
::: choice
Un valor null
:::

::: {.choice .correct-choice}
Un valor undefined
:::

::: choice
No se puede declarar a una variable sin asignar un valor
:::
::::::
:::::::

# Operador typeof

El operador **typeof** devuelve una cadena de texto que indica el tipo de un operando. Puede ser usado con cualquier tipo de operando, incluyendo variables y literales.

``` javascript
const MAGIC_NUMBER = 7
typeof MAGIC_NUMBER // "number"
```

También puedes usarlo directamente con los valores que quieras comprobar:

``` javascript
typeof undefined // "undefined"
typeof true // "boolean"
typeof 42 // "number"
typeof "Hola mundo" // "string"
```

## Actividad

1.  Tengo una variable llamada userName. Excribe el código necesario para ver su tipo.

<details>

<summary>Respuesta</summary>

``` javascript
let userName
typeof userName // "undefined"
```

</details>

Existe, sin embargo, un valor especial en JavaScript, **null**, que es considerado un bug en el lenguaje. El operador **typeof** devuelve **"object"** cuando se usa con **null**:

``` javascript
typeof null // "object"
```

Lo correcto sería que **typeof null** devolviera **"null"**, pero es un [error histórico que no se puede corregir sin romper el código existente](https://2ality.com/2013/10/typeof-null.html).

Por eso, si quieres comprobar si una variable es **null**, debes usar la comparación estricta **===**:

``` javascript
const foo = null
foo === null // true
```

Otra pregunta es... ¿Qué es ese **object**? Es un tipo de dato que está en el centro de JavaScript y que veremos en detalle más adelante.

## Usando con operadores de comparación

El operador **typeof** es muy útil cuando se usa con operadores de comparación. Por ejemplo, para comprobar si una variable es del tipo que esperamos:

``` javascript
const age = 42
typeof age === "number" // true
```

Una vez que tenemos expresiones lógicas, podemos empezar a encadenar operadores lógicos para comprobar múltiples condiciones:

``` javascript
const age = 42
typeof age === "number" && age > 18 // true
```

## Actividad

1.  Tengo una variable llamada dogId pero no tengo claro si es una cadena de texto. Escribe el código necesario para asegurarte.

<details>

<summary>Respuesta</summary>

``` javascript
typeof dogId === "string" // false
```

</details>

## Quiz

:::::: question
**¿Para qué sirve el operador typeof en JavaScript?**

::::: choices
::: choice
Nos permite leer el valor de una variable
:::

::: {.choice .correct-choice}
Nos da el tipo de dato de una variable
:::
:::::
::::::

:::::: question
**El operador typeof siempre devuelve una cadena de texto con el tipo del operando.**

::::: choices
::: {.choice .correct-choice}
Si, siempre devuelve una cadena de texto
:::

::: choice
Depende del tipo de dato que le pasemos, Si le pasamos un número, nos devolverá un number
:::
:::::
::::::

## Comentarios

En JavaScript, los comentarios son **una forma de agregar explicaciones al código que se ignora al ejecutar el programa**.

Los comentarios son útiles para explicar el por qué del código, documentar los cambios realizados en el código y hacer que el código sea más fácil de entender para otros desarrolladores.

Hay **dos tipos de comentarios en JavaScript**: los comentarios de una sola línea y los comentarios de varias líneas.

## Comentarios de una sola línea //

Los comentarios de una sola línea comienzan con **//** y se utilizan para agregar una explicación en una sola línea de código. Por ejemplo:

``` javascript
// Sólo usamos 6 decimales
const PI = 3.141592

// Iniciamos el radio por 10, pero puede cambiar
let radio = 10
```

También puedes añadir un comentario de una sola línea al final de una línea de código. Por ejemplo:

``` javascript
const PI = 3.141592 // Sólo usamos 6 decimales
```

## Comentarios de varias líneas /\* \*/

Los comentarios de varias líneas comienzan con /\* y terminan con \*/. Se utilizan para agregar notas explicativas que ocupan varias líneas de código. Por ejemplo:

``` javascript
/*
  Este es un comentario de varias líneas.
  Se utiliza para agregar notas explicativas que ocupan varias líneas de código.
*/
```

Ten en cuenta que también puedes lograr varias líneas usando el tipo de comentario //, sólo que en este caso, cada línea de código debe comenzar con //. Por ejemplo:

``` javascript
// Este es un comentario de varias líneas.
// Se utiliza para agregar notas explicativas que ocupan varias líneas de código.
```

Es importante tener en cuenta que **los comentarios no afectan el funcionamiento del código**. Es decir, si se eliminan los comentarios, el código seguirá funcionando de la misma manera.

Es recomendable utilizar comentarios con moderación y de manera efectiva para hacer que el código sea más fácil de entender y mantener. **Los comentarios deben ser claros y concisos, y deben explicar lo que hace el código sin repetir lo que ya es obvio**.

Es mejor que tu código sea lo suficientemente claro como para no necesitar comentarios, pero si es necesario, **utiliza comentarios para explicar el por qué del código, no el qué**.

## Quiz

:::::: question
**¿Para qué sirven los comentarios en JavaScript?**

::::: choices
::: {.choice .correct-choice}
Sirven para documentar nuestro código y explicar qué hace cada parte de él
:::

::: choice
Para cambiar el comportamiento de nuestro código
:::
:::::
::::::

:::::: question
**¿Cómo se escriben los comentarios en JavaScript?**

::::: choices
::: choice
Puedes usar \# para escribir comentarios de una línea o varias
:::

::: {.choice .correct-choice}
Puedes usar // para escribir comentarios de una línea o /\* \*/ para escribir comentarios de varias líneas
:::
:::::
::::::

## console.log()

**console.log()** es una función integrada en *JavaScript* que se utiliza para imprimir mensajes en la consola del navegador o del editor de código. Se utiliza principalmente para depurar el código y para **imprimir valores de variables y mensajes para ayudar en el proceso de desarrollo**.

::: callout-tip
En programación, una función es un conjunto de instrucciones que se pueden usar una y otra vez para hacer una tarea específica. Muchas veces, las funciones se utilizan para evitar repetir código y son parametrizables. Más adelante tendremos una sección sólo para ellas.
:::

## Sintaxis

Para poder mostrar estos mensajes en consola, debes escribir **console.log()** y dentro de los paréntesis, el mensaje que quieres mostrar.

``` javascript
console.log('Hola, JavaScript')
// -> 'Hola, JavaScript'
```

También puedes averiguar el valor de una variable, escribiendo el nombre de la variable dentro de los paréntesis.

``` javascript
const nombre = 'JavaScript'
console.log(nombre)
// -> 'JavaScript'
```

Como ya sabes concatenar cadenas de texto, puedes mostrar un mensaje y el valor de una variable en el mismo **console.log()**.

``` javascript
const nombre = 'JavaScript'
console.log('Hola, ' + nombre)
// -> 'Hola, JavaScript'
```

Además, puedes mostrar varios mensajes y valores de variables en el mismo **console.log()** separándolos por comas.

``` javascript
const nombre = 'JavaScript'
const version = 2023
console.log(nombre, version)
// -> 'JavaScript 2023'
```

## Más métodos de console

Además de **console.log()**, existen otros métodos que puedes utilizar para imprimir mensajes en la consola. Algunos de ellos son:

::: callout-tip
-   **console.error():** Imprime un mensaje de error en la consola.

-   **console.warn():** Imprime un mensaje de advertencia en la consola.

-   **console.info():** Imprime un mensaje de información en la consola.
:::

Como ves, la sintaxis es la misma que **console.log()**, sólo cambia el nombre del método.

::: callout-tip
Aunque puedes usar **console.log()** para imprimir cualquier tipo de mensaje, es recomendable utilizar los métodos que acabamos de ver para imprimir mensajes de error, advertencia e información ya que tienen un formato especial que los hace más fáciles de identificar.
:::

``` javascript
console.error('Error')
// ❌ Error
console.warn('Advertencia')
// ⚠️ Advertencia
console.info('Información')
// ℹ️ Información
```

Prueba estos métodos en la consola del navegador y observa los resultados.

## Quiz

::::::: question
**¿Cuál es la sintaxis adecuada para imprimir un mensaje en la consola del navegador?**

:::::: choices
::: choice
console("mensaje")
:::

::: {.choice .correct-choice}
console.log("mensaje")
:::

::: choice
console.write("mensaje")
:::
::::::
:::::::

::::::: question
**¿Cómo podrías usar console.log() para imprimir múltiples valores o variables en una sola línea de código?**

:::::: choices
::: choice
Utilizando una sintaxis especial que formatea los valores o variables en una sola línea de código
:::

::: choice
No es posible imprimir múltiples valores o variables en una sola línea de código con console.log()
:::

::: {.choice .correct-choice}
Separando cada valor o variable con comas dentro de los paréntesis de console.log()
:::
::::::
:::::::

::::::: question
**¿Cuál es la diferencia entre console.log() y console.error() en JavaScript?**

:::::: choices
::: {.choice .correct-choice}
console.log() se utiliza para imprimir mensajes en la consola del navegador, mientras que console.error() se utiliza para imprimir mensajes de error.
:::

::: choice
console.log() se utiliza para imprimir mensajes de error en la consola del navegador, mientras que console.error() se utiliza para imprimir mensajes normales
:::

::: choice
No hay diferencia entre console.log() y console.error() en JavaScript
:::
::::::
:::::::

# Código Condicional con if

El código condicional es un bloque de código que se ejecuta sólo si se cumple una condición. En JavaScript usamos la palabra reservada if para crear un bloque condicional, así:

``` javascript
if (condición) {
  // código que se ejecuta si la condición es verdadera
}
```

Como ves, ponemos la condición entre paréntesis y el código se ejecuta si la condición entre llaves es **true**. Si la condición es **false**, el código no se ejecuta.

Imagina que quieres mostrar un mensaje si la edad de un usuario es mayor o igual a 18 años. Podrías hacerlo así:

``` javascript
const edad = 18

if (edad >= 18) {
  console.log('Eres mayor de edad')
}
```

## else

Es posible utilizar la palabra clave **else** para ejecutar un bloque de código diferente si la condición es falsa:

``` javascript
const edad = 17

if (edad >= 18) {
  console.log('Eres mayor de edad')
} else {
  console.log('Eres menor de edad')
}
```

Esto es útil para ejecutar un bloque de código u otro dependiendo de si se cumple o no una condición. else if

También podemos utilizar la palabra clave **else if** para comprobar más de una condición:

``` javascript
const edad = 17

if (edad >= 18) {
  console.log('Eres mayor de edad')
} else if (edad >= 16) {
  console.log('Eres casi mayor de edad')
} else {
  console.log('Eres menor de edad')
}
```

El programa comprueba la primera condición. Si es **true**, ejecuta el código dentro del bloque **if**. Si es **false**, comprueba la siguiente condición. Si es **true**, ejecuta el código dentro del bloque **else if**. Si es false, ejecuta el código dentro del bloque **else**.

Dicho de otra forma, entrará en el primer bloque que cumpla la condición y no entrará en los demás. Si no cumple ninguna, entonces entrará en el bloque **else**.

## Anidación de condicionales

Es posible anidar condicionales dentro de otros condicionales. Por ejemplo:

``` javascript
const edad = 17
const tieneCarnet = true

if (edad >= 18) {
  if (tieneCarnet) {
    console.log('Puedes conducir')
  } else {
    console.log('No puedes conducir')
  }
} else {
  console.log('No puedes conducir')
}
```

En muchas ocasiones vas a querer evitar la anidación innecesaria de condicionales ya que se hacen difíciles de leer y mantener. En estos casos es mejor utilizar operadores lógicos para crear la condición:

``` javascript
const edad = 17
const tieneCarnet = true

// si es mayor de edad y tiene carnet entonces...
if (edad >= 18 && tieneCarnet) {
  console.log('Puedes conducir')
} else {
  console.log('No puedes conducir')
}
```

Otra técnica muy interesante es la de guardar el resultado de la condición en una variable, para que tus condiciones sean mucho más legibles:

``` javascript
const edad = 17
const tieneCarnet = true
const puedeConducir = edad >= 18 && tieneCarnet

if (puedeConducir) {
  console.log('Puedes conducir')
} else {
  console.log('No puedes conducir')
}
```

::: callout-tip
¡Wow! ¿Has visto cómo hemos mejorado la legibilidad de nuestro código? ¡Es mucho más fácil de leer y entender! A este tipo de técnica se le llama *refactorización* y consiste en mejorar el código sin cambiar su comportamiento.
:::

## La importancia de las llaves

Es importante que sepas que las llaves **{ }** no siempre son obligatorios. Si el bloque de código sólo tiene una línea, puedes omitir las llaves:

``` javascript
const edad = 17

if (edad >= 18)
  console.log('Eres mayor de edad')
else
  console.log('Eres menor de edad')
```

También lo puedes escribir en la misma línea:

``` javascript
const edad = 18

if (edad >= 18) console.log('Eres mayor de edad')
else console.log('Eres menor de edad')
```

Sin embargo, **te recomiendo que mientras estés aprendiendo siempre escribas las llaves**. Esto te ayudará a evitar errores y a que tu código sea más legible.

## Quiz

:::::: question
**¿Qué es un bloque condicional en JavaScript?**

::::: choices
::: {.choice .correct-choice}
Un bloque de código que se ejecuta sólo si se cumple una condición
:::

::: choice
Un bloque de código que se ejecuta siempre
:::
:::::
::::::

::::::: question
**¿Qué palabra clave se utiliza en JavaScript para crear un bloque condicional?**

:::::: choices
::: choice
if
:::

::: {.choice .correct-choice}
else
:::

::: choice
then
:::
::::::
:::::::

::::::: question
**¿Qué palabra clave se utiliza en JavaScript para ejecutar un bloque de código si la condición de un bloque condicional es falsa?**

:::::: choices
::: choice
if
:::

::: choice
then
:::

::: {.choice .correct-choice}
else
:::
::::::
:::::::

## Actividad

1.  Crea una variable llamada **temperatura** y asígnale un valor numérico. Escribe un bloque condicional que imprima en la consola si la temperatura es mayor o igual a 25 grados.

2.  Crea una variable llamada **esVerano** y asígnale un valor booleano. Escribe un bloque condicional que imprima en la consola si es verano o no.

<details>

<summary>Respuesta</summary>

R1.

``` javascript
const temperatura = 25

if (temperatura >= 25) {
  console.log('Hace calor')
}
```

R2.

``` javascript
const esVerano = true

if (esVerano) {
  console.log('Es verano')
}
```

</details>

# Bucles con while

Un bucle es una **estructura de control** que permite repetir un bloque de instrucciones. Vamos, **repetir una tarea tantas veces como queramos**.

En JavaScript, existen varias formas de lograrlo, y una de ellas es el bucle con **while**. El bucle **while** es una estructura de control de flujo que ejecuta una sección de código mientras se cumple una determinada condición.

En esta clase, vamos a explicar cómo funciona el bucle **while** en JavaScript y cómo podemos utilizarlo en nuestros programas.

## Sintaxis

La sintaxis del bucle **while** es similar a la de un condicional **if**. La única diferencia es que, en lugar de ejecutar el código una sola vez, se ejecuta mientras se cumpla la condición.

``` javascript
while (condición) {
  // código a ejecutar mientras se cumpla la condición
}
```

El bucle comienza evaluando la condición dentro de los paréntesis. Si la condición es **true**, se ejecuta el código dentro de las llaves.

Después de ejecutar el código, la condición se evalúa de nuevo, y si sigue siendo verdadera, el código dentro de las llaves se ejecuta de nuevo. **Este proceso se repite hasta que la condición se evalúa como falsa**.

Ten en cuenta que, si la condición es falsa desde el principio, el código dentro de las llaves nunca se ejecutará.

::: callout-tip
A cada vuelta del bucle se le llama **iteración**. Una iteración es la repetición de un proceso o acción un número determinado de veces, de manera ordenada y sistemática.
:::

## Ejemplo de uso de while

Vamos a crear la cuenta atrás de un cohete. Creamos una variable **cuentaAtras** que contenga el número de segundos que faltan para el lanzamiento. En este caso, vamos a empezar con 10 segundos.

``` javascript
let cuentaAtras = 10
```

Para quitarle un segundo a la cuenta atrás, vamos a utilizar el operador de resta (**-**) y el operador de asignación (**=**).

``` javascript
let cuentaAtras = 10
cuentaAtras = cuentaAtras - 1
console.log(cuentaAtras) // -> 9
```

Sabiendo esto y cómo funciona el bucle while, podemos crear la cuenta atrás del cohete.

``` javascript
// iniciamos la variable fuera del bucle
let cuentaAtras = 10

// mientras la cuenta atrás sea mayor que 0
while (cuentaAtras > 0) {
  // mostramos el valor de la cuenta atrás en cada iteración
  console.log(cuentaAtras)
  // restamos 1 a la cuenta atrás
  cuentaAtras = cuentaAtras - 1
}

console.log('¡Despegue! 🚀')
```

Si ejecutas este código en consola, deberías ver los números del 10 al 1, y después el mensaje de despegue.

## Cuidado con los bucles infinitos

Los bucles **while** son muy potentes, pero también pueden ser peligrosos. Si la condición nunca se evalúa como falsa, el bucle se ejecutará infinitamente.

``` javascript
while (true) {
  console.log('¡Hola hasta el infinito!')
}
```

Esto evaluará la condición **true** como verdadera, y ejecutará el código dentro de las llaves una y otra vez.

## Saliendo de un bucle con break

Podemos controlar cuándo queremos salir de un bucle utilizando la palabra reservada **break**. Cuando el intérprete de JavaScript encuentra la palabra **break**, sale del bucle y continúa ejecutando el código que haya después.

``` javascript
let cuentaAtras = 10

while (cuentaAtras > 0) {
  console.log(cuentaAtras)
  cuentaAtras = cuentaAtras - 1

  // si la cuenta atrás es 5, salimos del bucle
  if (cuentaAtras === 5) {
    break // <---- salimos del bucle
  }
}
```

¿Cuál es el valor de **cuentaAtras** en este código? Veamos, el bucle estaba haciendo una cuenta atrás... pero le hemos dicho que cuando tuviese el valor **5** saliese del bucle. Por lo tanto, el valor de **cuentaAtras** es **5**.

Usar **break** puede ser útil en bucles si queremos salir de ellos por alguna condición en concreto o para evitar justamente los bucles infinitos.

## Saltando una iteración con continue

Igual que tenemos la posibilidad de "romper" el bucle con **break**, también podemos saltarnos una iteración con **continue**. Cuando el intérprete de JavaScript encuentra la palabra **continue**, salta a la siguiente iteración del bucle.

``` javascript
let cuentaAtras = 10

while (cuentaAtras > 0) {
  cuentaAtras = cuentaAtras - 1

  // si la cuenta atrás es un número par...
  if (cuentaAtras % 2 === 0) {
    continue // <---- saltamos a la siguiente iteración
  }

  console.log(cuentaAtras)
}
```

¿Qué aparece en la salida de la consola? El bucle está haciendo una cuenta atrás... pero le hemos dicho que si el número es par, se salte esa iteración y deje de ejecutar el código que le sigue.

Por ello, los números pares no aparecen en la consola.

## Anidación de bucles

Podemos anidar bucles dentro de otros bucles. Imagina que en nuestra cuenta atrás para el cohete, tenemos que revisar que 3 cosas están en sus parámetros: el oxígeno, el combustible y la temperatura.

``` javascript
const NUMERO_REVISIONES = 3
let cuentaAtras = 10

// mientras la cuenta atrás sea mayor que 0
while (cuentaAtras > 0) {
  // mostramos el valor de la cuenta atrás
  console.log(cuentaAtras)

  // creamos una variable para contar las revisiones realizadas
  // y la inicializamos a cero
  let revisionesRealizadas = 0

  // hasta que no hayamos realizado las 3 revisiones...
  while (revisionesRealizadas < NUMERO_REVISIONES) {
    // y sumamos 1 a las revisiones realizadas
    revisionesRealizadas = revisionesRealizadas + 1
    console.log(revisionesRealizadas + ' revisiones realizadas...')
  }

  // ahora podemos restar 1 a la cuenta atrás
  cuentaAtras = cuentaAtras - 1
}
```

::: callout-tip
¿Por qué la constante la hemos puesto toda en mayúsculas? Como ya explicamos en la clase de introducción a JavaScript, es una convención para indicar que es una constante y que no va a cambiar.
:::

Además del bucle anidado, hay algo también muy interesante en el código anterior y es la creación de la variable **let revisionesRealizadas**.

Ten en cuenta que esa variable se creará y se inicializará a **0** en cada iteración del bucle.

Las variables creadas con **let** y **const** que se crean dentro de un bucle, solo existen dentro de ese bucle. Cuando el bucle termina, la variable desaparece. De hecho si intentas acceder a ella fuera del bucle, te dará un error.

``` javascript
let cuentaAtras = 10

while (cuentaAtras > 0) {
  let revisionesRealizadas = 3
  console.log(revisionesRealizadas)
  cuentaAtras = cuentaAtras - 1
}

console.log(revisionesRealizadas) // -> ERROR: ReferenceError
```

Esto también pasa con otras estructuras de control. Eso es porque el alcance de las variables creadas con **let** y **const** es el bloque entre **{ }** en el que se crean. Lo iremos viendo más adelante para que vayas practicando, no te preocupes.

## Quiz

:::::: question
**¿Cuál es la sintaxis correcta para utilizar un bucle while en JavaScript?**

::::: choices
::: {.choice .correct-choice}
![](images/paste-31.png)
:::

::: choice
![](images/paste-34.png)
:::
:::::
::::::

::::::: question
**¿Cuál es la palabra reservada que se utiliza para salir de un bucle en JavaScript?**

:::::: choices
::: {.choice .correct-choice}
break
:::

::: choice
continue
:::

::: choice
exit
:::
::::::
:::::::

:::::::: question
**¿Cuántas veces saldrá en consola la palabra 'Café'?**

::: center
![](images/paste-36.png)
:::

:::::: choices
::: {.choice .correct-choice}
6
:::

::: choice
4
:::

::: choice
5
:::
::::::
::::::::

# Bucles con do while

Aunque no es muy famoso ni muy utilizado, es interesante que sepas que existe en JavaScript un bucle que se ejecuta al menos una vez, y luego se repite mientras se cumpla una condición. Este bucle se llama **do while** y tiene la siguiente sintaxis:

``` javascript
do {
  // código que se ejecuta al menos una vez
} while (condición);
```

Vamos a aprovechar para hacer más interesante la clase. Por eso te voy a presentar una función integradas en JavaScript que nos van a dar mucho juego: **confirm**.

# confirm

La función **confirm** muestra un cuadro de diálogo con dos botones: "Aceptar" y "Cancelar". Si el usuario pulsa "Aceptar", la función devuelve **true**. Si pulsa "Cancelar", devuelve **false**.

``` javascript
confirm("¿Te gusta JavaScript?");
```

Llamar a la función **confirm** es una expresión y, por lo tanto, produce un valor que podemos guardar en una variable.

``` javascript
let respuesta = confirm("¿Te gusta JavaScript?")
console.log(respuesta) // -> true o false
```

# Usando do while

Vamos a hacer un programa que saldrá de un bucle **do while** cuando el usuario pulse "Cancelar" en el cuadro de diálogo que muestra la función **confirm**.

``` javascript
let respuesta

do {
  respuesta = confirm("¿Te gusta JavaScript?");
} while (respuesta)
```

::: callout-tip
¿Por qué hay que poner la variable **respuesta** fuera? Porque si no, no podría ser usada en la condición del bucle. Ya vas viendo lo que comentámos antes del ámbito de las variables.
:::

Si el usuario pulsa "Aceptar", la variable **respuesta** valdrá **true** y el bucle se repetirá. Si el usuario pulsa "Cancelar", la variable **respuesta** valdrá **false** y el bucle se detendrá.

## Quiz

::::::: question
¿Cuántas veces como mínimo se ejecutará el código dentro de un bucle do{ ... } while?

:::::: choices
::: choice
Ninguna vez
:::

::: choice
Depende de la condición
:::

::: {.choice .correct-choice}
Una vez
:::
::::::
:::::::

# Expresiones y declaraciones

En JavaScript, existen dos tipos de elementos fundamentales para escribir código: **expresiones** y **declaraciones**. Aunque estos términos pueden parecer confusos al principio, son conceptos clave para comprender cómo funciona JavaScript.

# Declaraciones

Las declaraciones en JavaScript son sentencias que definen la creación de una variable, función o clase. **Podríamos decir que las declaraciones son como las instrucciones que le damos a JavaScript para que haga algo**.

::: callout-tip
Las funciones y las clases las veremos más adelante en el curso, no te preocupes.
:::

Por ejemplo, una declaración de variable es una sentencia que le da un nombre y un valor a una variable. El siguiente código es un ejemplo de una declaración de variable:

``` javascript
let nombre = "Juan"
```

Este código no lo puedes usar con el método **console.log**, ya que no produce ningún valor. Si lo intentas, obtendrás un error:

``` javascript
console.log(let nombre = "Juan") // SyntaxError
```

# Expresiones

**Las expresiones en JavaScript son sentencias que producen un valor**. Las expresiones pueden ser tan simples como un solo número o una cadena de texto, o tan complejas como el cálculo de una operación matemática, la evaluación de diferentes valores o la llamada a una función.

Por ejemplo, una expresión numérica es una sentencia que produce un número:

``` javascript
2 + 3 // -> 5
```

De hecho, lo que guardamos en las variables son expresiones. Por ejemplo, en el siguiente código, la expresión **2 + 3** se evalúa y el resultado se guarda en la variable **resultado**:

``` javascript
let resultado = 2 + 3
```

En ese código tenemos la declaración que queremos guardar en la variable resultado el **resultado** de la expresión **2 + 3**.

# ¿Por qué es importante la diferencia?

La diferencia entre declaraciones y expresiones es importante ya que no podemos usar una declaración donde se espera una expresión y viceversa.

Por ejemplo, ya hemos conocido las estructuras de control **if** y **while**. Ambas esperan una expresión que se evalúa a un valor booleano. Por lo tanto, no podemos usar una declaración en su lugar:

``` javascript
// ❌ Ambos códigos están mal y sirven para
// ilustrar que no debes usar declaraciones
// cuando espera expresiones

if (let nombre = "Juan") { // ❌ SyntaxError
  console.log("Hola, Juan")
}

while (let i = 0) { // ❌ SyntaxError
  console.log("Iteración")
  i = i + 1
}
```

# Quiz

::::::: question
¿Qué son las declaraciones en JavaScript y para qué se utilizan?

:::::: choices
::: {.choice .correct-choice}
Las declaraciones en JavaScript son sentencias que definen la creación de una variable, función o clase para que puedan ser usadas posteriormente en el código.
:::

::: choice
Las declaraciones en JavaScript son sentencias que producen un valor. Se utilizan para calcular un valor y devolverlo en una expresión.
:::

::: choice
Las declaraciones en JavaScript son sentencias que se utilizan para realizar operaciones matemáticas complejas.
:::
::::::
:::::::

::::::: question
¿Qué son las expresiones en JavaScript y para qué se utilizan?

:::::: choices
::: choice
Las expresiones en JavaScript son sentencias que definen la creación de una variable
:::

::: {.choice .correct-choice}
Las expresiones en JavaScript son sentencias que producen un valor.
:::

::: choice
Las expresiones sólo se usan como condiciones de los condicionales if y los bucles.
:::
::::::
:::::::

# Bucles con for

La estructura de control **for** en JavaScript es muy útil para ejecutar una serie de instrucciones un número determinado de veces. A diferencia de **while** que usa una condición para determinar si se ejecuta o no el bloque de código, **for** usa un contador que se incrementa en cada iteración hasta que se cumple una condición.

La sintaxis de **for** es la siguiente:

``` javascript
for (inicialización; condición; actualización) {
  // código a ejecutar
}
```

Importante, fíjate que **for** tiene tres partes separadas por ;:

-   La *inicialización* se realiza antes de que se inicie el bucle y se utiliza para declarar variables y asignar valores iniciales.

-   La *condición* es una expresión *booleana* que se evalúa antes de cada iteración del bucle. Si la expresión se evalúa como **true**, se ejecuta el bloque de código dentro del bucle. Si la expresión se evalúa como **false**, el bucle termina.

-   La actualización se utiliza para actualizar el valor de la variable de control del bucle después de cada iteración. Normalmente, se incrementa o decrementa el valor de la variable de control del bucle.

# Ejemplo de uso de for

El siguiente ejemplo muestra cómo se puede usar **for** para imprimir los números del 1 al 10:

``` javascript
for (let number = 1; number <= 10; number++) {
  console.log(number)
}
```

-   La inicialización es la declaración de la variable **number** y la asignación del valor **1**.
-   La condición es que mientras **number \<= 10**, se itera el bucle.
-   La actualización es **number++** que incrementa el valor de **number** en 1 después de cada iteración.

Oh, espera, **¿qué es eso de number++? Te lo explico**.

# Incrementando números con ++

El operador **++** nos permite incrementar el valor de una variable número en 1. Por ejemplo, si tenemos la variable **i** con el valor **5**, **i++** incrementaría el valor de **i** en 1, es decir, **i** pasaría a valer **6**.

``` javascript
let i = 5
i++
console.log(i) // -> 6
```

Es una forma abreviada de escribir **i = i + 1**. Y, como ves, es la forma más típica de usar en bucles como **for** para no tener que escribir **i = i + 1** cada vez.

# Iterando al revés

El método **for** en JavaScript también se puede utilizar para iterar al revés Para ello, se utiliza la sintaxis **i--** en la sección de actualización del bucle en lugar de **i++**.

La sintaxis del método for para iterar en reversa es la siguiente:

``` javascript
for (let i = 10; i >= 0; i--) {
  if (i === 0) {
    console.log('¡Despegue 🚀!')
  } else {
    console.log('Faltan ' + i + ' segundos')
  }
}
```

# Llevando más allá el bucle for

Aunque siempre los ejemplos con **for** son los mismos, ten en cuenta que puedes hacer cualquier cosa en la inicialización, condición y actualización. Podrías, por ejemplo, usar dos variables a la vez.

``` javascript
for (let i = 0, j = 5; i < 5; i++, j--) {
  console.log(i, j);
}
```

La coma **,** nos permite declarar dos variables en la inicialización y actualizarlas en la actualización. En este caso la **,** es un **operador que evalua cada uno de sus operandos** (de izquierda a derecha) y retorna el valor del último operando.

No es muy común su uso, pero es bueno saber que existe.

# continue y break

Al igual que en **while**, **for** también tiene las palabras reservadas **continue** y **break** para controlar el flujo de ejecución del bucle.

Recuerda que **continue** se usa para saltar a la siguiente iteración del bucle y **break** para salir del bucle.

Ejemplo:

``` javascript
for (let i = 0; i < 10; i++) {
  const esPar = i % 2 === 0
  if (esPar) {
    continue
  }

  // Solo mostramos este consola.log si es impar
  console.log(i)

  // Salimos del bucle al llegar al 7
  if (i === 7) {
    break
  }
}
```

# Bucles anidados con for

Imagina que quieres crear **la tabla de multiplicar del 1 al 10**. Para ello, necesitas un bucle que itere del 1 al 10 y, dentro de ese bucle, otro bucle que itere del 1 al 10. Esto se puede hacer con dos bucles **for** anidados (uno dentro del otro).

``` javascript
for (let i = 1; i <= 10; i++) {
  for (let j = 1; j <= 10; j++) {
    const resultado = i * j
    console.log(i + ' x ' + j + ' = ' + resultado)
  }
}
```

# Quiz

::: question
¿Cuál es la sintaxis correcta para crear un bucle for en JavaScript?

::: choices

::: choice
![](images/paste-42.png)
:::

::: {.choice .correct-choice}
![](images/paste-44.png)
:::

:::
:::

::: question
¿Cuántas veces veremos el mensaje "Hola" en consola?

``` javascript
for (let i = 0; i < 10 && i !== 3; i++) {
  console.log('Hola')
}
```

::: choices

::: {.choice}
10 veces
:::

::: choice
4 veces
:::

::: {.choice .correct-choice}
3 veces
:::

:::
:::

# Switch

En JavaScript, la sentencia **switch** es una estructura de control que nos permite ejecutar diferentes bloques de código dependiendo del valor de una **expresión**. Esta estructura es útil cuando queremos realizar diferentes acciones basadas en una única variable.

# Sintaxis

La sentencia switch evalúa una expresión, comparando el valor con los diferentes casos que le hemos definido. Si hay coincidencia ejecuta el bloque de código asociado. Para ello, se utiliza la sentencia **break** para separar cada caso y evitar que se sigan evaluando el resto de casos.

``` javascript
switch (expresión) {
  case valor1:
    // código a ejecutar si la expresión coincide con valor1
    break

  case valor2:
    // código a ejecutar si la expresión coincide con valor2
    break
  default:
    // código a ejecutar si la expresión no coincide con ningún valor
    break
}
```

:::{.callout-tip}
La condición de **default** es opcional. No es obligatorio que la uses si no la necesitas. Es como el **else** de las condiciones **if**.
:::
Por ejemplo si queremos mostrar un mensaje diferente dependiendo del día de la semana:

``` javascript
const dia = "lunes"

switch (dia) {
  case "lunes":
    console.log("¡Hoy es lunes! 😢")
    break

  default:
    console.log("No es lunes, YAY! 🚀")
    break
}
```

Vamos a hacer esto un poco más interesante. En JavaScript podemos recuperar la información de la hora y la fecha usando el objeto **Date**. Este objeto tiene un método llamado **getDay()** que nos devuelve el día de la semana en formato numérico, siendo 0 el domingo y 6 el sábado.

:::{.callout-tip}
Igual que **console** es un objeto. También **Date** lo es. Un objeto en JavaScript no es muy diferente a un objeto en la vida real. Tiene propiedades y funciones que podemos usar. En este caso, **getDay()** es una función que nos devuelve el día de la semana.
:::

``` javascript
const dia = new Date().getDay()

// segun el dia de la semana, mostramos un mensaje diferente
switch (dia) {
  case 0:
    console.log("¡Hoy es domingo! 😴")
    break
  case 1:
    console.log("¡Nooo, es lunes! 😢")
    break
  case 2:
    console.log("¡Hoy es martes! 🥵")
    break
  case 3:
    console.log("¡Hoy es miércoles! 🤓")
    break
  default:
    console.log("Se acerca el fin de! 🚀")
    break
}
```
# switch vs if

Muchas veces verás que puedes escribir el mismo código usando **switch** o **if**. El ejemplo anterior con un **if**:

``` javascript
const dia = new Date().getDay()

if (dia === 0) {
  console.log("¡Hoy es domingo! 😴")
} else if (dia === 1) {
  console.log("¡Nooo, es lunes! 😢")
} else if (dia === 2) {
  console.log("¡Hoy es martes! 🥵")
} else if (dia === 3) {
  console.log("¡Hoy es miércoles! 🤓")
} else {
  console.log("Se acerca el fin de! 🚀")
}
```

A veces es más fácil de leer con **switch** y otras con **if**. ¡Depende de ti! Aunque más adelante, en el curso, veremos alternativas a **switch** usando algunas estructuras de datos.

# Agrupando cases

En ocasiones, queremos que varios casos ejecuten el mismo código. En lugar de repetir el mismo código en cada caso, podemos agruparlos usando el mismo **case** para cada uno de ellos.

``` javascript
const dia = new Date().getDay()

switch (dia) {
  case 0:
  case 6:
    console.log("¡Hoy es fin de semana! 🥳")
    break
  case 1:
  case 2:
  case 3:
  case 4:
    console.log("¡Nooo, a trabajar! 😢")
    break
  case 5:
    console.log("¡Hoy es viernes! 🤓")
    break
}
```

Como ves, en este caso, tampoco estamos usando el **default**. Como te comentaba antes, es totalmente opcional, no tienes por qué usarlo siempre.

# ¡No olvides el break!

Es muy importante que no te olvides de poner el **break** al final de cada caso. Si no lo pones, se ejecutarán todos los casos que vengan después del que coincide. Por ejemplo:

``` javascript
// ❌ Este código no es correcto
// Lo muestro para que veas qué pasa
// si no pones break en tus casos
const dia = new Date().getDay()

switch (dia) {
  case 0:
    console.log("¡Hoy es domingo! 😴")
  case 1:
    console.log("¡Nooo, es lunes! 😢")
  case 2:
    console.log("¡Hoy es martes! 🥵")
  case 3:
    console.log("¡Hoy es miércoles! 🤓")
  default:
    console.log("Se acerca el fin de! 🚀")
}
```

Si hoy es martes (**2**), se ejecutarán todos los casos después de ese, ya que no hay ningún **break** que lo impida. Por lo tanto, el resultado en consola sería:


``` bash
¡Hoy es martes! 🥵
¡Hoy es miércoles! 🤓
Se acerca el fin de! 🚀
```

# El patrón switch(true)

Existe un patrón que se usa a veces con **switch** que es **switch(true)**. Esto es, en lugar de evaluar una expresión, evalúa una condición ignorando por completo el valor de la expresión.

Por ejemplo:

``` javascript
let edad = 25;

switch(true) {
  case (edad >= 18 && edad < 25):
    console.log("Eres mayor de edad y eres joven");
    break;
  case (edad >= 25 && edad < 40):
    console.log("Eres mayor de edad y estás en plena madurez");
    break;
  case (edad >= 40):
    console.log("Eres mayor de edad y estás en la mejor edad");
    break;
  default:
    console.log("Eres menor de edad");
}
```

Es un patrón algo más avanzado y es una alternativa a usar **if** y **else if**. En mi opinión, es más difícil de leer, ya que puede crear un poco de confusión. Pero es bueno que lo conozcas por si te lo encuentras en algún sitio.

# Quiz

::: question
¿Cuál es la función de la palabra reservada default en una declaración switch en JavaScript?

::: choices

::: {.choice .correct-choice}
Es el caso que se ejecuta cuando se produce un error en el switch
:::

::: choice
Es el caso que se ejecuta cuando ninguno de los casos coincide con la expresión
:::

::: {.choice}
Es un caso opcional que se puede utilizar para realizar acciones adicionales
:::

:::
:::

::: question
¿Qué problema tiene este código?

``` javascript
switch (day) {
  case 0:
    console.log('Hoy es Domingo')
  case 1:
    console.log('Hoy es Lunes')
  case 2:
    console.log('Hoy es Martes')
  default:
    console.log('Es otro día')
}
```

::: choices

::: choice
No tiene ningún problema
:::

::: choice
Se repite mucho código
:::

::: {.choice .correct-choice}
Falta usar break en cada caso
:::

:::
:::

::: question
¿Se puede hacer esto con switch?

``` javascript

let x = 5

switch (true) {
  case (x < 0):
    console.log('x es negativo')
    break
  case (x > 0):
    console.log('x es positivo')
    break
  default:
    console.log('x es cero')
}
```

::: choices

::: choice
No, porque no se puede usar una expresión booleana en el switch
:::

::: choice
No, porque no se puede saber el valor de x dentro
:::

::: {.choice .correct-choice}
Sí, no hay ningún problema
:::

:::
:::

# Tu primera función

Las *funciones* son uno de los conceptos más importantes en *JavaScript* y casi cualquier lenguaje de programación.

**Una función es un bloque de código que realiza una tarea específica cuando se llama**. Puedes pensar en una función como en un microondas: le das algo para cocinar, le pasas algunos parámetros (como el tiempo y la potencia) y luego hace su trabajo y te devuelve el resultado.

En JavaScript, las funciones se pueden definir de varias maneras, pero la forma más común y básica es mediante la palabra clave **function**. Esta es tu primera función:

``` javascript
function saludar() {
  console.log('Hola Diego')
}
```

Como ves, declarar una función consiste de:

*   La palabra reservada **function** que indica que estamos definiendo una función.

*   El nombre de la función, en este caso **saludar**. Normalmente usamos verbos para nombrar funciones, ya que son acciones que realizan.

*   Un par de paréntesis **( )** después del nombre. Pueden contener parámetros. En este caso, no tenemos ninguno.

*   Un bloque de código entre llaves **{ }**. En este caso, solo tenemos una línea de código, pero podríamos tener muchas más.

Nuestra función ahora mismo no devuelve nada pero cada vez que la llamemos, imprimirá **Hola** en la consola.

:::{.callout-tip}
Las funciones pueden devolver un resultado (un número, una cadena de texto, un booleano...) o puede no devolver nada. En ese caso, la función devuelve **undefined**.
:::

saludar() // -> Hola Diego
saludar() // -> Hola Diego
saludar() // -> Hola Diego

# Devolviendo un resultado

Las funciones pueden devolver un resultado. Para ello, utilizamos la palabra reservada **return** y después el valor que queremos devolver:

``` javascript
function sumar() {
  return 1 + 1
}
```

Ahora, cada vez que llamemos a la función **sumar**, nos devolverá el resultado de la suma:

``` javascript
// podemos guardar el resultado en una variable
const resultado = sumar()

// o ver en consola directamente el resultado
console.log(sumar()) // -> 2
```

:::{.callout-tip}
En la siguiente clase verás cómo puedes pasar parámetros a una función para hacerlas todavía más interesantes y reutilizables.
:::

:::{.callout-info}
Recuerda, si no utilizamos **return**, la función devolverá **undefined**.
:::

# Una función realmente útil

La función **saludar** y **sumar** no parecen muy útiles, pero con lo poco que sabemos ya podemos hacer cosas más productivas. Por ejemplo, podemos crear una función que nos devuelva un número aleatorio del 1 al 10.

Para ello vamos a descubrir **Math**, un objeto incorporado en JavaScript que tiene propiedades y métodos para constantes y funciones matemáticas. Vamos a ver dos métodos que nos van a ser muy útiles:

*   **Math.random():** devuelve un número aleatorio entre 0 y 1, con decimales.
*   **Math.floor():** redondea un número hacia abajo.

:::{.callout-tip}
**Math.random** es parecido a **console.log**, en el sentido que son métodos que JavaScript incorpora de serie y que podemos utilizar en cualquier punto de nuestro programa.
:::

Sabiendo esto, podríamos crear una **función que nos devuelva un número aleatorio del 1 al 10**:

``` javascript
function getRandomNumber() {
  // recuperamos un número aleatorio entre 0 y 1
  const random = Math.random() // por ejemplo: 0.6803487380457318

  // lo multiplicamos por 10 para que esté entre 0 y 10
  const multiplied = random * 10 // -> 6.803487380457318

  // redondeamos hacia abajo para que esté entre 0 y 9
  const rounded = Math.floor(multiplied) // -> 6

  // le sumamos uno para que esté entre 1 y 10
  const result = rounded + 1 // -> 7

  // devolvemos el resultado
  return result
}
```

¡Bueno! Hay que ver cuantas cosas has puesto en práctica en muy pocas líneas de código: *constantes*, *variables*, *operadores*, comentarios... ¡y todo en una función!

¿Sabes lo mejor? Que **esa función va a acompañarte durante toda tu carrera**. Es muy común necesitar crear un número aleatorio en un programa, así que es muy útil tener una función que lo haga por nosotros.

:::{.callout-info}
En la función hemos utilizado varias variables para ir guardando los resultados intermedios. Podríamos haberlo hecho todo en una sola línea, pero así es más fácil de entender.
:::

# Quiz

::: question
¿Qué es una función en JavaScript?

::: choices

::: choice
Algo que se puede hacer con JavaScript de base
:::

::: {.choice .correct-choice}
Un bloque de código que realiza una tarea específica cuando se llama
:::

::: choice
Una variable que almacena información
:::

:::
:::

::: question
¿Cuál es la sintaxis básica de una función en JavaScript?

::: choices

::: {.choice .correct-choice}
function nombreFuncion() { ... }
:::

::: choice
const function() { ... }
:::

::: choice
fn nombreFuncion() { ... }
:::

:::
:::

::: question
¿Qué devuelve una función declarada con function si no tiene una declaración de retorno explícita?

::: choices

::: choice
null
:::

::: {.correct-choice}
undefined
:::

::: choice
0
:::

:::
:::

# Parámetros

Hasta ahora hemos visto como crear funciones y cómo llamarlas. Pero para poder desbloquear todo el potencial de las funciones, **necesitamos que puedan recibir parámetros**. Esto es, que su comportamiento pueda cambiar según los datos que le pasemos.

Imagina que queremos que nuestra función de **saludar**, pueda saludar a cualquier persona, no solo a Miguel. Para ello, podemos hacer que la función acepte un parámetro, que será el nombre de la persona a la que queremos saludar.

``` javascript
function saludar(nombre) {
  console.log("Hola " + nombre)
}
```

Ahora, cada vez que llamemos a la función, podemos pasarle una cadena de texto:

``` javascript
saludar('Diego') // -> Hola Diego
saludar('Itziar') // -> Hola Itziar
saludar('Carmen') // -> Hola Carmen
```
Ya ves como algo que parece tan sencillo, tiene un poder enorme. **Las funciones son la base de la programación y nos permiten crear programas complejos a partir de pequeñas piezas**.

Por ejemplo, para crear una calculadora, deberíamos empezar a crear funciones que realicen las operaciones básicas. En este caso necesitaremos parametrizar la función para que acepte los dos números para hacer la operación.

``` javascript
function sumar(a, b) {
  return a + b
}

function restar(a, b) {
  return a - b
}
```
Y ya podríamos usarlas:
``` javascript
const resultadoSuma = sumar(2, 3)
console.log(resultadoSuma) // -> 5

const resultadoResta = restar(5, 2)
console.log(resultadoResta) // -> 3
```

# Parámetros y argumentos

En el ejemplo anterior, hemos visto que podemos pasarle valores a la función cuando la llamamos. A estos valores se les llama **argumentos**. Y a los valores que recibe la función, se les llama **parámetros**.

``` javascript
// la función suma tiene dos parámetros: a y b
function sumar(a, b) {
  return a + b
}

// cuando llamamos a la función, le pasamos dos argumentos: 2 y 3
const resultadoSuma = sumar(2, 3)
```
Normalmente mucha gente confunde los términos y usa parámetro para referirse a los argumentos. Pero es importante que sepas diferenciarlos, porque son cosas distintas.

# El orden de los parámetros importa

Algo muy importante, y un error muy común al empezar a crear funciones, es olvidar que el orden de los parámetros importa.

Vamos a crear una función que simule un microondas. Le pasaremos el plato, tiempo y potencia. Y nos devolverá el resultado del plato cocinado.

``` javascript
function cocinarMicroondas(plato, tiempo, potencia) {
  if (plato === '🐥' && tiempo === 1 && potencia === 5) {
    return '🍗'
  }

  if (plato === '🥚' && tiempo === 2 && potencia === 3) {
    return '🍳'
  }

  return '❌ Plato no soportado'
}
```
:::{.callout-tip}
Sí, puedes hacer un **return** dentro de un condicional. Esto hace que la función se detenga y devuelva el valor indicado en el **return**.
:::
Si usamos bien los parámetros, la función funciona correctamente:

``` javascript
const resultado = cocinarMicroondas('🐥', 1, 5)
console.log(resultado) // -> 🍗
```
Pero si cambiamos el orden de los parámetros, la función no funciona:

``` javascript
const resultado = cocinarMicroondas(1, 5, '🐥')
console.log(resultado) // -> '❌ Plato no soportado'
```
Esto es porque la función espera que el primer parámetro sea el plato, el segundo el tiempo y el tercero la potencia. **Si cambiamos el orden, podemos tener comportamientos inesperados o errores**.

Más adelante veremos una forma en la que podemos evitar este tipo de errores.

# Quiz

::: question
¿Qué son los parámetros de una función en JavaScript?

::: choices

::: {.correct-choice}
Valores que espera recibir una función al llamarla para usarlos dentro de ella
:::

::: choice
Valores que devuelve una función
:::

::: choice
Valores que se declaran dentro de una función
:::

:::
:::

::: question

¿Qué son los argumentos de una función en JavaScript?

::: choices

::: choice
Valores que espera recibir una función
:::

::: {.correct-choice}
Valores que se pasan a una función al llamarla
:::

::: choice
Lo mismo que los parámetros
:::

:::
:::

::: question
¿Qué pasa si cambiamos el orden de los parámetros al llamar una función?
:::

::: choices

::: choice
La función se detiene y no devuelve nada
:::

::: choice
La función devuelve undefined
:::

::: {.correct-choice}
Podemos tener comportamientos inesperados o errores
:::

:::
:::

# Function Expression

Hasta ahora hemos visto cómo podemos declarar funciones usando la palabra clave **function**.

Sin embargo, existen dos formas más de declarar funciones en JavaScript: function expression y arrow function. En este caso, hablemos de la primera.

# ¿Qué es una function expression?

Una **function expression** es una función que se asigna a una variable. Por ejemplo:

``` javascript// esto es una function expression
const sum = function (a, b) {
  return a + b
}

// esto es una declaración de función
function sum(a, b) {
  return a + b
}
```

:::{.callout-tip}
¡Fíjate que la **function** no tiene nombre en la **function expression**! Cuando una función no tiene nombre se le llama función anónima. Aunque en este caso, la función está asignada a una variable que sí tiene nombre y por eso podremos utilizarla más adelante.
:::

Con la function expression, a la función se asigna a la variable **sum**. Esto significa que podemos llamar a la función usando el nombre de la variable:

``` javascript
sum(1, 2) // 3
```

El comportamiento es muy similar al de una función declarada con la palabra clave **function**. Sin embargo, hay una diferencia muy importante entre ambas que debes conocer: el hoisting.

# Hoisting

El hoisting es un término que se usa para describir cómo JavaScript parece que mueve las declaraciones funciones al principio del código, de forma que las puedes usar incluso antes de declararlas. Por ejemplo:

``` javascript
sum(1, 2) // 3

function sum(a, b) {
  return a + b
}
```
Aquí primero usamos la función y la declaramos luego. ¡Y funciona! ¿Cómo puede ser? **¿No debería darnos un error ya que la función todavía no existe?**

Lo que está pasando es que JavaScript asigna en memoria durante la fase de compilación las declaraciones de funciones y por eso al ejecutarse el código tiene acceso a esa posición de memoria a la que se refiere la función.

Eso sería la explicación técnica del hoisting, pero si te sirve de ayuda, puedes pensar que es como si JavaScript moviese las declaraciones de funciones al principio del código.

# ¿Y qué pasa con las function expression?

Pues que no se aplica el hoisting. Por ejemplo:

``` javascript
sum(1, 2) // ❌ ReferenceError: sum is not defined

const sum = function (a, b) {
  return a + b
}
```

# Quiz

::: question
¿Qué es una function expression en JavaScript?

::: choices

::: choice
Una función que se define dentro de otra función
:::

::: choice
Una función que se declara con la palabra clave "function"
:::

::: {.correct-choice}
Una función que se asigna a una variable
:::

:::
:::

::: question
¿Qué diferencia hay entre una declaración de función y una función de expresión en JavaScript?

::: choices

::: choice
Sólo la forma en que se declaran
:::

::: {.choice .correct-choice}
El hoisting y cómo se crean
:::

::: choice
El comportamiento al llamarlas
:::

:::
:::

::: question
¿Se aplica el hoisting a las funciones de expresión en JavaScript?

::: choices

::: choice
Sí
:::

::: {.choice .correct-choice}
No
:::

:::
:::

# Funciones flecha

En esta clase vamos a hablar sobre las *funciones flecha*, también conocidas como **arrow functions** en inglés.

Las funciones flecha son una forma más concisa de crear funciones en *JavaScript*, y se han vuelto muy populares en los últimos años debido a su sintaxis simplificada.

La sintaxis básica de una función flecha es la siguiente:

``` javascript
const miFuncionFlecha = () => {
  // código a ejecutar
}
```

:::{.callout-tip}
Las funciones flecha son siempre **funciones anónimas** y **function expressions**. Esto significa que no tienen nombre y que se asignan a una variable.
:::

En lugar de la palabra clave **function**, utilizamos una flecha **=>** para definir la función. También podemos omitir los paréntesis alrededor de los parámetros si solo tenemos uno:

``` javascript
const saludar = nombre => {
  console.log("Hola " + nombre)
}
```

# Ventajas de las funciones flecha

Las funciones flecha tienen varias **ventajas sobre las funciones regulares en JavaScript**. Algunas son:

*   **Sintaxis más concisa:** la sintaxis de las funciones flecha es más corta y más fácil de leer que la sintaxis de las funciones regulares, especialmente cuando se trabaja con funciones de una sola línea.

*   **Return implícito:** las funciones flecha puede devolver el valor de la expresión sin usar la palabra clave **return** cuando son de una sola línea. Esto hace que las funciones flecha sean aún más cortas y más fáciles de leer.

*   **Funciones anónimas más legibles:** las funciones flecha son una forma más legible y concisa de crear funciones anónimas en JavaScript, lo cual puede hacer que nuestro código sea más fácil de entender.

:::{.callout-tip}
Recuerda, las funciones anónimas son funciones que no tienen nombre. Son como las que vimos en la clase anterior.
:::

# Return implícito

Cuando una función flecha tiene una sola expresión, podemos omitir las llaves **{ }** y la palabra clave return para hacerla aún más corta. Esto se conoce como **return implícito**. Vamos a pasar una función regular a una función flecha y vamos a ver cómo se ve finalmente con return implícito:

``` javascript
// Declaración de función regular
function sumar(a, b) {
  return a + b
}

// Función flecha
const sumarFlecha = (a, b) => {
  return a + b
}

// Función flecha con return implícito
const sumarFlecha = (a, b) => a + b
```
Como podemos ver, la función flecha con return implícito es mucho más corta y fácil de leer que la función regular. Esto es especialmente útil cuando estamos trabajando con funciones de una sola línea.

# Quiz

::: question
¿Qué son las funciones flecha en JavaScript?

::: choices

::: {.correct-choice}
Una forma más concisa de crear funciones en JavaScript
:::

::: choice
Una forma más compleja de crear funciones en JavaScript
:::

::: choice
Una técnica para evitar el uso de funciones en JavaScript
:::

:::
:::

::: question
¿Cuál es una de las ventajas de las funciones flecha?

::: choices

::: {.choice .correct-choice}
Return implícito
:::

::: choice
Son más rápidas
:::

::: choice
Funciones anónimas
:::

:::
:::

::: question
¿Qué devuelve la siguiente función flecha?

``` javascript
const sum = (a, b) => { a + b }
sum(2, 3)
```

::: choices

::: choice
5
:::

::: {.choice .correct-choice}
undefined
:::

::: choice
Error
:::

:::
:::

# Recursividad

La recursividad es una técnica de programación que consiste en que una función se llame a sí misma.

Pero claro, si una función se llama a sí misma, ¿cuándo termina? ¿cómo se evita que se llame infinitamente? Con una condición base.

# Ejemplo de recursividad

Vamos a crear una función que cuente desde un número hasta cero.

``` javascript
function cuentaAtras(numero) {
  // Condición base: Si el número que recibe es
  // menor de 0 entonces salimos de la función
  if (numero < 0) { return }

  // Si el número era mayor o igual a 0, lo mostramos
  console.log(numero)

  // Y llamamos a la función con el número anterior
  cuentaAtras(numero - 1)
}
```

Si llamamos a la función con el número 3, el resultado será:

``` javascript
cuentaAtras(3)
// -> 3
// -> 2
// -> 1
// -> 0
```

La ejecución la veríamos así:

```javascript
cuentaAtras(3) -> (muestra 3)
               \ 
          cuentaAtras(2) -> (muestra 2)
                       \
                  cuentaAtras(1) -> (muestra 1)
                               \
                          cuentaAtras(0) -> (muestra 0)
                                        \
                                   cuentaAtras(-1) -> salida
```

:::{.callout-info}
¡Cuidado! Si no ponemos la condición base, la función se llamará infinitamente y el navegador se quedará bloqueado. Cuando hacemos recursividad SIEMPRE hay que tener una condición que haga que la función salga de sí misma.
:::

# Usando recursividad y devolviendo un valor

La recursividad se usa muchas veces para solucionar algoritmos. Por ejemplo, vamos a crear una función que calcule el factorial de un número.

:::{.callout-tip}
El factorial de un número es el resultado de multiplicar ese número por todos los anteriores hasta llegar a 1. Por ejemplo, el factorial de 5 es 5 * 4 * 3 * 2 * 1 = 120
:::

``` javascriptfunction factorial(n) {
  // Condición base: Si el número es 0 o 1, devolvemos 1
  // y no llamamos a la función de nuevo
  if (n === 0 || n === 1) {
    return 1
  } else {
    // Si el número es mayor que 1, llamamos a la función
    return n * factorial(n - 1)
  }
}

console.log(factorial(5)) // Resultado: 120
console.log(factorial(3)) // Resultado: 6
```

```javascript
factorial(3) --------------------------> 6
        \ 
  3 * factorial(2) ---------------> 6
          \
    2 * factorial(1) -----------> 2
            \
      1 * factorial(0) -------> 1
```

La recursividad es un concepto que cuesta entender al principio. ¿Una función que se llama a sí misma? A mucha gente le vuela la cabeza.

¿Qué te recomiendo para aprenderlo? Primero, entiende los ejemplos que hemos hecho y dibuja en un papel cómo se ejecutan las funciones.

Después, haz estos ejercicios de recursividad:

Escribe una función que calcule la suma de los primeros n números enteros de forma recursiva. Por ejemplo: **suma(3) -> 1 + 2 + 3 = 6**

Escribe una función que calcule la sucesión de Fibonacci de forma recursiva. La sucesión de Fibonacci es una serie de números que empieza por 0 y 1 y cada número es la suma de los dos anteriores. Por ejemplo: **fibonacci(6) -> 8 (0, 1, 1, 2, 3, 5, 8)**


# Quiz

::: question
¿Qué es la recursividad en programación?

::: choices

::: {.choice .correct-choice}
Una técnica de programación que consiste en que una función se llame a sí misma
:::

::: choice
Un tipo de condición que permite evitar que una función se llame infinitamente
:::

::: choice
Un error que ocurre cuando una función se llama a sí misma
:::

:::
:::

::: question
¿Qué es la condición base en la recursividad?

::: choices

::: {.choice .correct-choice}
Una condición que permite evitar que una función se llame infinitamente
:::

::: choice
Una condición que permite que una función se llame infinitamente
:::

::: choice
Una condición que permite que una función se llame infinitamente
:::

:::
:::

::: question
¿Qué sucede si no se define una condición base en una función recursiva?

::: choices

::: {.choice .correct-choice}
La función se puede llamar infinitamente y el programa se bloquea
:::

::: choice
La función deja de llamarse después de un cierto número de iteraciones
:::

::: choice
La función devuelve un valor incorrecto
:::

:::
:::

::: question
¿Cuál es la salida de este código al pasar como argumento el número 3?

``` javascript
function recursive(n) {
  if (n === 0) {
    return 0
  } else {
    return n + recursive(n - 1)
  }
}
```

::: choices

::: choice
0
:::

::: {.choice .correct-choice}
6
:::

::: choice
4
:::

:::
:::

# Arrays: colecciones de elementos

Hasta ahora hemos visto algunos tipos de datos. Cadenas de texto, números, booleanos... Pero... **¿Qué pasa si queremos tener una colección de ellos?** En *JavaScript* tenemos los **arrays**.

# Declaración y asignación de arrays

Para declarar un array usamos los corchetes **[ ]** y dentro los elementos de la colección separados por comas **,**.

Por ejemplo, para crear una colección de números del 1 al 5:

``` javascript
[1, 2, 3, 4, 5]
```

Los elementos de un array pueden ser de cualquier tipo, incluso otros arrays.

``` javascript
[1, 2, 3, 4, [5, 6, 7, 8, 9]]
```
Y, aunque no siempre sea recomendable, puedes mezclar tipos de datos dentro:

``` javascript
['uno', 2, true, null, undefined]
```
Para asignar un array a una variable, lo hacemos igual que con los otros tipos de datos:

``` javascript
const numbers = [1, 2, 3, 4, 5]
let names = ['Dani', 'Miguel', 'Maria']
```

# Acceso a los elementos de un array

Para acceder a los elementos de un array usamos los corchetes **[ ]** y dentro el índice del elemento que queremos acceder. **Los índices empiezan en 0**.

``` javascript
const numbers = [1, 2, 3, 4, 5]

console.log(numbers[0]) // 1
console.log(numbers[2]) // 3
```

:::{.callout-tip}
El índice es la posición del elemento dentro del array. El primer elemento tiene índice 0, el segundo índice 1, el tercero índice 2...
:::

Si intentamos acceder a un elemento que no existe, nos devolverá **undefined**.

``` javascript
const numbers = [1, 2, 3, 4, 5]

console.log(numbers[10]) // undefined
```

Puedes usar variables para acceder a los elementos de un array.

``` javascript
const numbers = [1, 2, 3, 4, 5]
let index = 2

console.log(numbers[index]) // 3
```
# Modificar elementos de un array

Igual que podemos acceder a los elementos de un array, podemos modificarlos.

``` javascript
const numbers = [1, 2, 3, 4, 5]

numbers[0] = 10
numbers[2] = 30

console.log(numbers) // [10, 2, 30, 4, 5]
```

:::{.callout-tip}
¿Cómo es que pese a que hemos indicado que es una constante **const** podemos modificar el Array? Aunque hay una explicación mucho más larga, que veremos más adelante, la respuesta corta es que **const** sólo impide que se reasigne el valor de la variable, no que se modifique el valor en sí.
:::

# Quiz

::: question
¿Qué se imprimirá en la consola al ejecutar el siguiente código:

``` javascript
const numbers = [1, 2, 3, 4, 5]
numbers[0] = 10
numbers[2] = 30
console.log(numbers)
```

::: choices

::: choice
[1, 2, 3, 4, 5]
:::

::: {.choice .correct-choice}
[10, 2, 30, 4, 5]
:::

::: choice
Error de asignación a una constante
:::

:::
:::

# Métodos y propiedades de Array

Los arrays de JavaScript tienen una serie de métodos y propiedades que nos permiten trabajar con ellos de forma sencilla.

:::{.callout-tip}
Un método es una función que se ejecuta sobre un objeto. Una propiedad es una variable que pertenece a un objeto. En este caso, el objeto es un array.
:::

# La longitud de un array

Puedes conocer la longitud de una colección de elementos usando la propiedad **.length**:

``` javascript
const frutas = ["manzana", "pera", "plátano", "fresa"]
console.log(frutas.length) // 4
```

También puedes cortar su longitud asignando un nuevo valor a la propiedad **.length**:

``` javascript
const frutas = ["manzana", "pera", "plátano", "fresa"]
frutas.length = 2

console.log(frutas) // ["manzana", "pera"]
console.log(frutas.length) // 2
```

# Métodos de arrays

Cuando trabajamos con colecciones de elementos, vamos a querer hacer cosas con ellos. Por ejemplo: añadir un elemento, eliminarlo, buscarlo, etc. Para ello, los arrays tienen una serie de métodos que nos permiten hacer estas operaciones:

# .push()

El método **.push()** nos permite añadir un elemento al final de un array:

``` javascript
const frutas = ["plátano", "fresa"]
frutas.push("naranja")
console.log(frutas) // ["plátano", "fresa", "naranja"]
```

Además, el método **.push()** devuelve la nueva longitud del array:

``` javascript
const frutas = ["plátano", "fresa"]
console.log(frutas.length) // 2

const newLength = frutas.push("naranja")
console.log(newLength) // 3
console.log(frutas) // ["plátano", "fresa", "naranja"]
```

# .pop()

El método **.pop()** elimina y devuelve el último elemento de un array:

``` javascript
const frutas = ["plátano", "fresa", "naranja"]
const ultimaFruta = frutas.pop()

console.log(frutas) // ["plátano", "fresa"]
console.log(ultimaFruta) // "naranja"
```

# .shift()

El método **.shift()** elimina y devuelve el primer elemento de un array. Es lo mismo que .pop(), pero con el primer elemento en lugar del último:

``` javascript
const frutas = ["plátano", "fresa", "naranja"]
const primeraFruta = frutas.shift()

console.log(frutas) // ["fresa", "naranja"]
console.log(primeraFruta) // "plátano"
```

# .unshift()

El método **.unshift()** añade un elemento al principio de un array. Es lo mismo que **.push()**, pero con el primer elemento en lugar del último:

``` javascript
const frutas = ["plátano", "fresa", "naranja"]
frutas.unshift("manzana")

console.log(frutas) // ["manzana", "plátano", "fresa", "naranja"]
```

# Concatenar arrays

Podemos concatenar dos arrays usando el método **concat()**.

``` javascript
const numbers = [1, 2, 3]
const numbers2 = [4, 5]

const allNumbers = numbers.concat(numbers2)

console.log(allNumbers) // [1, 2, 3, 4, 5]
```

Otra forma de concatenar arrays es usando el operador **...** (spread operator). Este operador propaga los elementos de un array. Así que podríamos hacer lo siguiente:

``` javascript
const numbers = [1, 2, 3]
const numbers2 = [4, 5]

//                    1, 2, 3        4, 5                     
const allNumbers = [...numbers, ...numbers2]

console.log(allNumbers) // [1, 2, 3, 4, 5]
```

Más adelante hablaremos más de este operador y sus diferentes utilidades.

# Ejercicio práctico

En un restaurante se reciben pedidos de comida a domicilio. Vamos a escribir una función **procesarPedido** que recibe un pedido, que es un array de platos. Lo que debemos hacer es:

*   El primer elemento lo sacamos del array, ya que es el nombre del cliente.
*   Añadimos al principio del array la cadena de texto "bebida", ya que es una promoción que tenemos.
*  Después añadimos al final del array el nombre del usuario que sacamos antes.

Recuerda que debes devolver el array modificado:

``` javascript
function procesarPedido(pedidos) {
  // tu código aquí
}
```

<details>
<summary>Ver solución</summary>

``` javascript
function procesarPedido(pedidos) {
  const nombreCliente = pedidos.shift()
  pedidos.unshift("bebida")
  pedidos.push(nombreCliente)

  return pedidos
}
```

</details>

# Iteración de Arrays en JavaScript

Ya hemos visto en clases anteriores cómo podemos crear bucles con **for** y **while**. Con estas estructuras de control, y una nueva que veremos en este clase, podemos también recorrer cada uno de los elementos de un array.

Además, veremos como los propios arrays tienen un método **.forEach** que nos permite ejecutar una función para cada uno de los elementos del array.

# Bucle while

El bucle **while** vimos que permitía ejecutar un bloque de código mientras una condición era verdadera. En el caso de la iteración de arrays, la condición generalmente se basa en el índice del elemento.

Podemos, por ejemplo, crear una variable con **let** para guardar un puntero al índice del elemento que estamos iterando. En cada iteración, podemos incrementar el valor de la variable en 1, para que en la siguiente iteración se imprima el siguiente elemento.

``` javascript
let frutas = ['🍎', '🍌', '🍓']
let i = 0 // lo usaremos como índice

while (i < frutas.length) {
  console.log(frutas[i]) // imprime el elemento en la posición i
  i++ // incrementamos el índice en 1 para la siguiente iteración
}
```

# Bucle for

El bucle **for** nos permitía ejecutar un bloque de código un número determinado de veces. En el caso de la iteración de arrays, podemos usarlo para recorrer cada uno de los elementos del array, usando la longitud del array como condición.

``` javascript
let frutas = ['🍎', '🍌', '🍓']

for (let i = 0; i < frutas.length; i++) {
  console.log(frutas[i]) // imprime el elemento en la posición i
}
```
También podrías recorrer el array en orden inverso, empezando desde el último elemento hasta el primero, usando **i--** en lugar de **i++**.

``` javascript
let frutas = ['🍎', '🍌', '🍓']

for (let i = frutas.length - 1; i >= 0; i--) {
  console.log(frutas[i]) // imprime el elemento en la posición i
}
```

# Bucle for...of

Además de **while** y **for**, existe otra estructura de control que nos permite iterar sobre los elementos de un array: **for...of**. Esta estructura de control es más simple que **for**, ya que no necesitamos crear una variable para guardar el índice del elemento que estamos iterando.

Es mucho más sencilla y fácil de entender:

``` javascript
let frutas = ['🍎', '🍌', '🍓']

for (let fruta of frutas) {
  console.log(fruta) // imprime el elemento en la posición i
}
```

:::{.callout-tip}
Como ves, hay algunas limitaciones en el uso de **for...of**. Por ejemplo, no podemos usarlo para recorrer un array en orden inverso y tampoco tenemos acceso al índice del elemento que estamos iterando.
:::

# El método array.forEach()

Ya hemos visto en la clase anterior que los arrays tienen métodos que nos permiten realizar operaciones sobre ellos, como añadir elementos o eliminarlos. Pero tiene muchos más métodos que iremos viendo que nos ayuda a trabajar con ellos.

Uno de esos métodos es **array.forEach()**, que nos permite ejecutar una **function** para cada uno de los elementos del array. Esta función recibe como parámetros el elemento que se está iterando en ese momento, el índice del elemento y el propio array.

``` javascript
let frutas = ['🍎', '🍌', '🍓']

frutas.forEach(function (fruta, index, originalArray) {
  console.log(fruta) // imprime el elemento en la posición i
})
```

Usando una **arrow function** e indicando sólo los parámetros que necesitamos de nuestra función podemos simplificarlo aún más:

``` javascript
let frutas = ['🍎', '🍌', '🍓']

frutas.forEach((fruta) => {
  console.log(fruta) // imprime el elemento en la posición i
})
```

:::{.callout-tip}
Algo importante es que **array.forEach()** no devuelve nada, por lo que no podemos asignar el resultado a una variable.
:::

**¿Cuál usar? Depende...**

::: table
| **Método** | **Acceso al Índice** | **Acceso al Valor** | **Puede Usar Break** | **Control Manual del Índice** |
|------------|----------------------|---------------------|----------------------|--------------------------------|
| **for**    | ✅                   | ✅                  | ✅                   | ✅                             |
| **while**  | ✅                   | ✅                  | ✅                   | ✅                             |
| **for...of**| ❌                  | ✅                  | ✅                    | ❌                             |
| **forEach**| ✅                   | ✅                  | ❌                   | ❌                             |
:::

:::{.callout-tip}
Aunque técnicamente no puedes utilizar la sentencia **break** para salir de forEach, puedes simular esto lanzando una excepción y capturándola en un bloque **try/catch** externo. Obviamente es una mala práctica que no te recomiendo.
:::

Cada uno de estos métodos tiene sus propios casos de uso. **for** y **while** son más generales y te permiten controlar el índice manualmente, lo que es útil si necesitas saltar a índices específicos, cambiar el orden de iteración o salir del bucle antes de que se complete.

**for...of** es más fácil de usar cuando solo necesitas los valores de un array y no te importa el índice. Es especialmente útil también cuando estás trabajando con iterables que no son arrays, como las cadenas de caracteres o los conjuntos (sets).

Finalmente, **forEach** es una forma muy eficiente y legible de iterar sobre un array si no necesitas **break** y si no necesitas controlar manualmente el índice.

# Ejercicio práctico

Dada una lista de números, escribe una función en JavaScript que devuelva la suma de todos los números pares en la lista. La función deberá iterar sobre cada número en la lista, comprobar si el número es par y, si es así, añadirlo a la suma total. Usa el bucle que quieras para solucionarlo.

``` javascript
function sumarPares(numeros) {
  let suma = 0
  // tu código aquí
  return suma
}
```

<details>
<summary>Ver solución</summary>

``` javascript
function sumarPares(numeros) {
  let suma = 0

  for (let numero of numeros) {
    if (numero % 2 === 0) {
      suma += numero
    }
  }

  return suma
}
```
</details>

# Búsqueda en Arrays con sus métodos

Existen varios métodos en **JavaScript** que te permiten, específicamente, buscar dentro de un Array. Estos métodos incluyen **indexOf**, **some**, **every**, **find**, **findIndex** e **includes**.

Cada uno de estos métodos tiene un propósito específico y una funcionalidad única. Vamos a explorar cada uno de ellos utilizando un Array de emojis como ejemplo.

``` javascript
const emojis = ['✨', '🥑', '😍']
```

# indexOf: ¿En qué posición está el elemento?

El método **indexOf** te permite encontrar la posición de un elemento dentro de un **Array**. Si el elemento no existe, entonces retorna **-1**.

``` javascript
const emojis = ['✨', '🥑', '😍']

const posicionCorazon = emojis.indexOf('😍')

console.log(posicionCorazon) // -> 2
```

# includes: ¿El elemento existe en el Array?

El método includes determina si un Array incluye un determinado elemento, devolviendo **true** o **false** según corresponda.

``` javascript
const emojis = ['✨', '🥑', '😍']

const tieneCorazon = emojis.includes('😍')

console.log(tieneCorazon) // -> true
```
Es la forma más sencilla y corta de buscar un elemento específico dentro de un **Array**. Sin embargo, si queremos revisar si un **Array** contiene un elemento que cumpla con una condición, entonces tenemos que utilizar otros métodos...

:::{.callout-tip}
El método **.includes()** también funciona con las cadenas de texto. Puedes utilizarlo para buscar una subcadena dentro de una cadena de texto: **'Hola mundo'.includes('Hola') // -> true**
:::
# some: ¿Alguno de los elementos cumple con la condición?

El método **some** te permite verificar si al menos uno de los elementos de un **Array** cumple con una condición.

Para utilizarlo, le pasas una función como argumento. Esta función recibe como argumento cada uno de los elementos del **Array** y debe retornar un valor **booleano**.

Si al menos uno de los elementos retorna **true**, entonces el método **some** retorna **true**. Si ninguno de los elementos retorna **true**, entonces el método **some** retorna **false**.

``` javascript
const emojis = ['✨', '🥑', '😍']

const tieneCorazon = emojis.some(emoji => emoji === '😍')
console.log(tieneCorazon) // -> true
```

¡Pero si esto ya lo podíamos hacer con **includes**! Sí, pero **some** es mucho más potente...

Podemos crear funciones más complejas para pasarle al método **some**. Por ejemplo, podemos crear una función que verifique si un **Array** contiene un elemento que sea un **string** de más de 3 caracteres.

``` javascript
const names = ['Leo', 'Isa', 'Ían', 'Lea']

const tieneNombreLargo = names.some(name => name.length > 3)
console.log(tieneNombreLargo) // -> false
```

Algo importante a tener en cuenta es que el método **some** deja de iterar sobre el **Array** en cuanto encuentra un elemento que cumple con la condición. Por ejemplo, si tenemos un **Array** de 10 elementos y el elemento número 3 cumple con la condición, el método **some** no va a iterar sobre los 7 elementos restantes:

``` javascript
const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

const tieneNumeroMayorA5 = numbers.some(number => {
  console.log(`Estoy iterando sobre el número ${number}`) // -> Imprime hasta el número 6
  return number > 5
})

console.log(tieneNumeroMayorA5) // -> true
```

# every: ¿Todos los elementos cumplen con la condición?

El método **every** te permite verificar si todos los elementos de un **Array** cumplen con una condición. Es similar a **some**, pero en lugar de verificar si al menos uno de los elementos cumple con la condición, los verifica todos.

Para utilizarlo, le pasas una función como argumento. Esta función recibe como argumento el elemento del array que está iterando en ese momento y debe retornar un valor **booleano** para saber si el elemento cumple con la condición.

Si todos los elementos retornan **true**, entonces el método **every** retorna true. Si al menos uno de los elementos retorna **false**, entonces el método **every** retorna **false**.

``` javascript
// ¿Todos los emojis son felices?
const emojis = ['😀', '😂', '😍', '😭', '🥺', '😎']
const todosSonFelices = emojis.every(emoji => emoji === '😀')
console.log(todosSonFelices) // -> false

// ¿Todos los números son pares?
const numbers = [2, 4, 7, 10, 12]
const todosSonPares = numbers.every(number => number % 2 === 0)
console.log(todosSonPares) // -> false

// ¿Todos los strings son mayores a 3 caracteres?
const names = ['Miguel', 'Juan', 'Itziar', 'Isabel']
const todosLosNombresSonLargos = names.every(name => name.length > 3)
console.log(todosLosNombresSonLargos) // -> true
```
Al igual que **some**, el método **every** deja de iterar sobre el **Array** en cuanto encuentra un elemento que no cumple con la condición.

# find: Devuelve el primer elemento que cumple con la condición

El método **find** te permite encontrar el primer elemento que cumple con una condición. Lo interesante es que este método te devuelve el elemento en sí, no un valor **booleano** como **some** y **every**. Aunque el funcionamiento es igual: hay que pasarle una función como argumento que retorne un valor **booleano**.

``` javascriptconst numbers = [13, 27, 44, -10, 81]
// encuentra el primer número negativo
const firstNegativeNumber = numbers.find(number => number < 0)

console.log(firstNegativeNumber) // -> -10
```

Si no encuentra ningún elemento que cumpla con la condición, el método **find** retorna **undefined**.

``` javascript
const numbers = [13, 27, 44, 81]
// encuentra el primer número negativo
const firstNegativeNumber = numbers.find(number => number < 0)

console.log(firstNegativeNumber) // -> undefined
```
De nuevo, igual que **some** y **every**, el método **find** deja de iterar sobre el **Array** en cuanto encuentra un elemento que cumple con la condición.

# findIndex: Devuelve el índice del primer elemento que cumple con la condición

El método **findIndex** es similar a **find**, pero en lugar de devolver el elemento que cumple con la condición, devuelve el índice de ese elemento.

``` javascript
const numbers = [13, 27, 44, -10, 81]

// encuentra el índice del primer número negativo
const firstNegativeNumberIndex = numbers.findIndex(number => number < 0)

console.log(firstNegativeNumberIndex) // -> 3

// ahora puedes usar el índice para acceder al elemento
console.log(numbers[firstNegativeNumberIndex]) // -> -10
```
Si no encuentra ningún elemento que cumpla con la condición, el método **findIndex** retorna **-1**.

``` javascript
const numbers = [13, 27, 44, 81]

// encuentra el índice del primer número negativo
const firstNegativeNumberIndex = numbers.findIndex(number => number < 0)

console.log(firstNegativeNumberIndex) // -> -1
```
# Actividad Práctica

Crear una función que reciba un array de palabras y devuelva **true** si todas las palabras terminan con la letra "a" y **false** si al menos una palabra no termina con la letra "a".

Usa el [método endsWith() de string](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith) para resolverlo.

``` javascript
function acabanEnA(words) {
  // tu código aquí
}
```

<details>
<summary>Ver solución</summary>

``` javascript
function acabanEnA(words) {
  return words.every(word => word.endsWith('a'))
}
```

</details>

# Ordenamiento de Arrays en JavaScript

*JavaScript* proporciona un método incorporado en arrays llamado **.sort()** para ordenar sus elementos. Por defecto no es muy útil pero puedes personalizar su comportamiento para que ordene los elementos de la manera que necesites.

# Ordenamiento básico con sort()

Por defecto, **.sort()** hace una ordenación un poco extraña:

``` javascript
let numeros = [5, 10, 2, 25, 7]
numeros.sort()
console.log(numeros) // [10, 2, 25, 5, 7]
```

¿Qué ha pasado? **Este comportamiento puede resultar confuso cuando se trabaja con números**, ya que **.sort()** ordenará los números en función de su valor como cadena de texto, no de su valor numérico.

Por suerte, podemos arreglarlo...

# Ordenamiento personalizado con sort()

Para personalizar cómo **sort()** ordena los elementos, puedes pasar una función de comparación como argumento. La función de comparación debe devolver:

*    Un **valor negativo** si el primer argumento debe aparecer antes que el segundo.
*    Un **valor positivo** si el segundo argumento debe aparecer antes que el primero.
*    **Cero** si ambos argumentos son iguales.

Por ejemplo, **para ordenar los números de menor a mayor**, puedes usar la siguiente función de comparación:

``` javascript
let numeros = [5, 10, 2, 25, 7]

numeros.sort(function(a, b) {
  return a - b
})

console.log(numeros) // [2, 5, 7, 10, 25]
```

**Para ordenarlos de manera descendente**, de mayor a menor, deberías cambiar el orden del **return**:

``` javascript
let numeros = [5, 10, 2, 25, 7]

numeros.sort(function(a, b) {
  return b - a
})

console.log(numeros) // [25, 10, 7, 5, 2]
```
Puedes usar una **arrow function** para simplificar el código:

``` javascript
let numeros = [5, 10, 2, 25, 7]

numeros.sort((a, b) => a - b)
```

# sort() y toSorted()

Como ves, **.sort()** modifica el array original. Si quieres obtener un array ordenado sin modificar el original, puedes usar el método **.toSorted()**. Sólo ten en cuenta que, ahora mismo, su soporte en navegadores es limitado.

``` javascript
let numeros = [5, 10, 2, 25, 7]

let numerosOrdenados = numeros.toSorted((a, b) => {
  return a - b
})

console.log(numerosOrdenados) // [2, 5, 7, 10, 25]
console.log(numeros) // [5, 10, 2, 25, 7]
```
También podrías usar el operador de propagación **(...)** para crear una copia del array original y ordenarla:

``` javascript
let numeros = [5, 10, 2, 25, 7]

const copiaNumeros = [...numeros]
// ordenamos la copia y no el original
copiaNumeros.sort((a, b) => a - b)

console.log(copiaNumeros) // [2, 5, 7, 10, 25]
console.log(numeros) // [5, 10, 2, 25, 7]
```

# Actividad Práctica

Recibes una lista de números. Debes ordenar los números de menor a mayor según su valor absoluto. Eso quiere decir que los números negativos pierden el signo y se ordenan como si fueran positivos.

Por ejemplo, si recibes **[5, -10, -2, -25, -7]** deberías devolver **[-2, 5, -7, -10, -25]**.

Puedes usar el método **Math.abs(num)** para obtener el valor absoluto de un número.

``` javascript
function sortAbsoluteNumbers(numbers) {
  // tu código aquí
  }
```

<details>
<summary>Ver solución</summary>

``` javascript
function sortAbsoluteNumbers(numbers) {
  return numbers.sort((a, b) => Math.abs(a) - Math.abs(b))
}
```

</details>