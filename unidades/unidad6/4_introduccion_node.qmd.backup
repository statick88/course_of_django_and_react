# Nodejs

::: center
![Nodejs](/images/node-logo.png){.center width="200px"}
:::

Node.js es un entorno de ejecución de JavaScript que permite ejecutar código JavaScript en el lado del servidor. Fue creado por Ryan Dahl en 2009 y está basado en el motor V8 de Google Chrome. Node.js es una herramienta muy poderosa para el desarrollo de aplicaciones web y APIs RESTful, ya que permite realizar operaciones de entrada/salida de forma asíncrona y no bloqueante.

## ¿Porqué es Node.js?

Node.js es una herramienta muy poderosa para el desarrollo de aplicaciones web y APIs RESTful, ya que permite realizar operaciones de entrada/salida de forma asíncrona y no bloqueante. Esto significa que Node.js puede manejar múltiples solicitudes simultáneamente sin bloquear el hilo principal, lo que lo hace muy eficiente para aplicaciones en tiempo real y de alta concurrencia.

## Historia y evolución de Node.js

Node.js fue creado por Ryan Dahl en 2009 y se basa en el motor V8 de Google Chrome. Inicialmente, Node.js se utilizaba principalmente para crear servidores web y aplicaciones de red, pero con el tiempo ha evolucionado para convertirse en una plataforma de desarrollo completa que se utiliza en una amplia variedad de aplicaciones, desde aplicaciones web y APIs RESTful hasta aplicaciones de escritorio y móviles.

A continuación se muestra una linea del tiempo de Node.js:

-   2009: Ryan Dahl crea Node.js

-   2010: Se lanza la primera versión estable de Node.js (v0.1.14)

-   2011: Se lanza npm (Node Package Manager)

-   2012: Se lanza la versión 0.8 de Node.js con mejoras de rendimiento y estabilidad

-   2013: Se lanza la versión 0.10 de Node.js con mejoras en el rendimiento y la estabilidad

-   2014: Se lanza la versión 0.12 de Node.js con mejoras en el rendimiento y la estabilidad

-   2015: Se lanza la versión 4.0 de Node.js con soporte para ECMAScript 6 (ES6)

-   2016: Se lanza la versión 6.0 de Node.js con soporte para ECMAScript 6 (ES6)

-   2017: Se lanza la versión 8.0 de Node.js con mejoras en el rendimiento y la estabilidad

-   2018: Se lanza la versión 10.0 de Node.js con mejoras en el rendimiento y la estabilidad

-   2019: Se lanza la versión 12.0 de Node.js con mejoras en el rendimiento y la estabilidad

-   2020: Se lanza la versión 14.0 de Node.js con mejoras en el rendimiento y la estabilidad

-   2021: Se lanza la versión 16.0 de Node.js con mejoras en el rendimiento y la estabilidad

## Características de Node.js

Node.js tiene varias características que lo hacen una herramienta muy poderosa para el desarrollo de aplicaciones web y APIs RESTful:

-   **Asíncrono y no bloqueante**: Node.js utiliza un modelo de E/S asíncrono y no bloqueante que permite manejar múltiples solicitudes simultáneamente sin bloquear el hilo principal.

-   **Eventos y callbacks**: Node.js utiliza un sistema de eventos y callbacks para manejar la asincronía y la concurrencia.

-   **Módulos y paquetes**: Node.js tiene un sistema de módulos y paquetes que permite reutilizar código y extender la funcionalidad de la plataforma.

-   **NPM (Node Package Manager)**: Node.js tiene un gestor de paquetes llamado npm que permite instalar, actualizar y gestionar paquetes de código de forma sencilla.

-   **Rendimiento y escalabilidad**: Node.js es muy eficiente en términos de rendimiento y escalabilidad, lo que lo hace ideal para aplicaciones en tiempo real y de alta concurrencia.

-   **Comunidad activa**: Node.js tiene una comunidad muy activa y una gran cantidad de paquetes y librerías disponibles en npm que facilitan el desarrollo de aplicaciones web y APIs RESTful.

## Instalación de Node.js y NPM (Node Package Manager)

Para instalar Node.js y NPM en tu sistema, sigue los siguientes pasos:

1.  Descarga e instala Node.js desde la página oficial de Node.js: <https://nodejs.org/>

2.  Verifica que Node.js y NPM se hayan instalado correctamente ejecutando los siguientes comandos en la terminal:

``` bash
node --version
npm --version
```

3.  Crea un nuevo proyecto de Node.js ejecutando el siguiente comando en la terminal:

``` bash
npm init
```

4.  Instala los paquetes necesarios para tu proyecto ejecutando el siguiente comando en la terminal:

``` bash
npm install nombre-del-paquete
```

5.  Crea un archivo JavaScript con el código de tu aplicación y ejecútalo con Node.js ejecutando el siguiente comando en la terminal:

``` bash
node nombre-del-archivo.js
```

## Primer script en Node.js: "Hello World"

Para crear tu primer script en Node.js, sigue los siguientes pasos:

1.  Crea un nuevo archivo JavaScript llamado "hello.js" con el siguiente código:

``` javascript
console.log("Hello, World!");
```

2.  Ejecuta el script con Node.js ejecutando el siguiente comando en la terminal:

``` bash
node hello.js
```

3.  Deberías ver el mensaje "Hello, World!" impreso en la consola.

::: center
![](images/paste-48.png)
:::

# Módulos en Node.js

Node.js utiliza un sistema de módulos para organizar y reutilizar código en tus aplicaciones. Los módulos en Node.js son archivos JavaScript que exportan funciones, objetos o variables para ser utilizados en otros archivos JavaScript.

## Módulos internos vs externos

En Node.js existen dos tipos de módulos: módulos internos y módulos externos.

-   **Módulos internos**: Son módulos que vienen incluidos en Node.js y se pueden utilizar sin necesidad de instalar nada adicional. Algunos ejemplos de módulos internos son fs (File System), http (HTTP), path (Path), events (EventEmitter), etc.

-   **Módulos externos**: Son módulos que no vienen incluidos en Node.js y se deben instalar a través de npm (Node Package Manager). Algunos ejemplos de módulos externos son express (Express), mongoose (Mongoose), axios (Axios), etc.

Ejemplo:

``` javascript
// Módulo interno
const fs = require('fs');

// Módulo externo
const express = require('express');

// Uso de módulos internos y externos
```

## Importación y exportación de módulos (CommonJS)

En Node.js, los módulos se importan y exportan utilizando el sistema CommonJS. Para importar un módulo en Node.js, se utiliza la función require() y para exportar un módulo se utiliza el objeto module.exports.

Ejemplo:

``` javascript
// Módulo interno
const fs = require('fs');

// Módulo externo
const express = require('express');

// Exportar una función
module.exports = function() {
    console.log("Hello, World!");
};

// Importar una función
const hello = require('./hello');
hello();
```

## require() y module.exports

La función require() se utiliza para importar módulos en Node.js y el objeto module.exports se utiliza para exportar módulos en Node.js.

Ejemplo:

``` javascript
// Exportar una función
module.exports = function() {
    console.log("Hello, World!");
};

// Importar una función
const hello = require('./hello');
hello();
```

## Uso del sistema de módulos con import y export (ES6+)

Los módulos en Node.js también se pueden importar y exportar utilizando la sintaxis de import y export de ECMAScript 6 (ES6+). Para utilizar esta sintaxis, es necesario utilizar un transpilador como Babel.

Ejemplo:

``` javascript
// Exportar una función
export default function() {
    console.log("Hello, World!");
};

// Importar una función
import hello from './hello';
hello();
```
# Módulo fs (File System)

El módulo fs (File System) de Node.js proporciona una API para interactuar con el sistema de archivos del sistema operativo. Con el módulo fs, puedes leer y escribir archivos, crear y eliminar directorios, y realizar otras operaciones relacionadas con el sistema de archivos.

## Operaciones básicas con el módulo fs

El módulo fs proporciona una serie de métodos para realizar operaciones básicas con el sistema de archivos, como leer y escribir archivos, crear y eliminar directorios, y más.

## Leer archivos

Para leer un archivo en Node.js, puedes utilizar el método fs.readFile() que acepta la ruta del archivo y una función de callback que se ejecuta cuando se completa la lectura del archivo.

Ejemplo:

``` javascript
const fs = require('fs');

fs.readFile('archivo.txt', 'utf8', (error, data) => {
    if (error) {
        console.error(error);
    } else {
        console.log(data);
    }
});
```

En el ejemplo anterior, se lee el archivo 'archivo.txt' en formato UTF-8 y se imprime su contenido en la consola.

## Escribir archivos

Para escribir un archivo en Node.js, puedes utilizar el método fs.writeFile() que acepta la ruta del archivo, los datos a escribir y una función de callback que se ejecuta cuando se completa la escritura del archivo.

Ejemplo:

``` javascript
const fs = require('fs');

fs.writeFile('archivo.txt', 'Hola, Mundo!', (error) => {
    if (error) {
        console.error(error);
    } else {
        console.log('El archivo se ha escrito correctamente.');
    }
});
```

En el ejemplo anterior, se escribe el texto 'Hola, Mundo!' en el archivo 'archivo.txt' y se imprime un mensaje en la consola si la operación se completa correctamente.

## Renombrar y eliminar archivos

Para renombrar un archivo en Node.js, puedes utilizar el método fs.rename() que acepta la ruta del archivo original y la nueva ruta del archivo.

Ejemplo:

``` javascript
const fs = require('fs');

fs.rename('archivo.txt', 'nuevo-archivo.txt', (error) => {
    if (error) {
        console.error(error);
    } else {
        console.log('El archivo se ha renombrado correctamente.');
    }
});
```

Para eliminar un archivo en Node.js, puedes utilizar el método fs.unlink() que acepta la ruta del archivo a eliminar.

## Trabajando con directorios

El módulo fs también proporciona métodos para trabajar con directorios, como crear y eliminar directorios, listar los archivos de un directorio, y más.

Ejemplo:

``` javascript
const fs = require('fs');

// Crear un directorio
fs.mkdir('directorio', (error) => {
    if (error) {
        console.error(error);
    } else {
        console.log('El directorio se ha creado correctamente.');
    }
});

// Eliminar un directorio

fs.rmdir('directorio', (error) => {
    if (error) {
        console.error(error);
    } else {
        console.log('El directorio se ha eliminado correctamente.');
    }
});

// Listar los archivos de un directorio

fs.readdir('directorio', (error, files) => {
    if (error) {
        console.error(error);
    } else {
        console.log(files);
    }
});
```
# Manejo de eventos

El manejo de eventos en Node.js es una parte fundamental para construir aplicaciones asíncronas y basadas en eventos. Node.js utiliza el patrón **EventEmitter** para manejar eventos y callbacks.

## El patrón EventEmitter

El patrón **EventEmitter** permite que un objeto emita eventos que otros objetos pueden escuchar y manejar. En Node.js, la clase **EventEmitter** se encuentra en el módulo events.
Crear una instancia de **EventEmitter**

Primero, necesitas importar la clase **EventEmitter** desde el módulo **events** y crear una instancia de esta clase.

```javascript
const EventEmitter = require('events');
const myEmitter = new EventEmitter();
```
## Emisión de eventos

Para emitir un evento, se utiliza el método **emit()**. Puedes pasar argumentos al método **emit()** que serán recibidos por los escuchadores del evento.

```javascript
myEmitter.emit('eventoPersonalizado', 'Mensaje del evento');
```
## Escucha de eventos

Para escuchar eventos, se utiliza el método **on()**. Este método toma el nombre del evento y una función de callback que se ejecutará cuando el evento sea emitido.

```javascript
myEmitter.on('eventoPersonalizado', (mensaje) => {
    console.log(`Evento recibido: ${mensaje}`);
});
```

## Ejemplo completo

Aquí tienes un ejemplo completo de cómo emitir y escuchar eventos usando **EventEmitter**.

``` javascript
const EventEmitter = require('events');
const myEmitter = new EventEmitter();

// Escuchar el evento
myEmitter.on('eventoPersonalizado', (mensaje) => {
    console.log(`Evento recibido: ${mensaje}`);
});

// Emitir el evento
myEmitter.emit('eventoPersonalizado', 'Mensaje del evento');
```
## Eventos y callbacks

En Node.js, los eventos y los callbacks se usan ampliamente para manejar operaciones asíncronas, como leer archivos, hacer solicitudes HTTP, o manejar eventos de usuarios. Utilizar el patrón de eventos permite escribir código más limpio y modular.

# Módulo http: Servidor web básico

El módulo **http** de Node.js te permite crear servidores web básicos y manejar solicitudes y respuestas HTTP. Es uno de los módulos fundamentales para construir aplicaciones web en Node.js.
Crear un servidor HTTP

Para crear un servidor HTTP, utiliza la función **http.createServer()**. Esta función recibe una función de callback que se ejecuta cada vez que se recibe una solicitud HTTP.

```javascript
const http = require('http');

const server = http.createServer((req, res) => {
    res.statusCode = 200;
    res.setHeader('Content-Type', 'text/plain');
    res.end('Hello, World!\n');
});

server.listen(3000, '127.0.0.1', () => {
    console.log('Servidor escuchando en http://127.0.0.1:3000/');
});
```

En el ejemplo anterior:

*    **http.createServer()** crea una instancia del servidor.
*    La función de callback recibe dos parámetros: **req** (solicitud) y **res** (respuesta).
*    **res.statusCode** establece el código de estado HTTP de la respuesta.
*    **res.setHeader()** establece los encabezados HTTP.
*    **res.end()** envía la respuesta y finaliza la solicitud.

## Manejar solicitudes y respuestas

El objeto **req** (solicitud) contiene información sobre la solicitud HTTP realizada, como los encabezados, el método HTTP (GET, POST, etc.) y la URL solicitada. El objeto **res** (respuesta) se usa para enviar la respuesta al cliente.

## Obtener la URL solicitada

Puedes obtener la URL solicitada de la siguiente manera:

```javascript
const http = require('http');

const server = http.createServer((req, res) => {
    console.log('URL solicitada:', req.url);
    res.statusCode = 200;
    res.setHeader('Content-Type', 'text/plain');
    res.end('Hello, World!\n');
});

server.listen(3000, '127.0.0.1', () => {
    console.log('Servidor escuchando en http://127.0.0.1:3000/');
});
```

## Manejar diferentes rutas

Puedes manejar diferentes rutas en función de la URL solicitada:

```javascript
const http = require('http');

const server = http.createServer((req, res) => {
    if (req.url === '/') {
        res.statusCode = 200;
        res.setHeader('Content-Type', 'text/plain');
        res.end('Página de inicio\n');
    } else if (req.url === '/about') {
        res.statusCode = 200;
        res.setHeader('Content-Type', 'text/plain');
        res.end('Página de acerca de\n');
    } else {
        res.statusCode = 404;
        res.setHeader('Content-Type', 'text/plain');
        res.end('Página no encontrada\n');
    }
});

server.listen(3000, '127.0.0.1', () => {
    console.log('Servidor escuchando en http://127.0.0.1:3000/');
});
```

## Manejo de rutas básicas

Para manejar rutas básicas, puedes utilizar condicionales basados en **req.url** y **req.method**. Para rutas más complejas, considera usar un framework como Express, que simplifica la gestión de rutas.

# Módulo path

El módulo **path** de Node.js proporciona utilidades para trabajar con rutas y archivos del sistema de archivos. Permite manipular rutas de manera fácil y portátil, independientemente del sistema operativo.

## Manipulación de rutas y archivos

El módulo **path** ofrece una serie de métodos para manipular rutas de archivos y directorios. A continuación se describen algunos de los métodos más comunes:

### path.join()

Une varios segmentos de una ruta en una sola. Es útil para construir rutas de manera segura, teniendo en cuenta las diferencias de sistema operativo.

```javascript
const path = require('path');

const ruta = path.join('/usuarios', 'juan', 'documentos', 'archivo.txt');
console.log(ruta); // '/usuarios/juan/documentos/archivo.txt' en sistemas UNIX y 'C:\usuarios\juan\documentos\archivo.txt' en Windows
```
### path.resolve()

Resuelve una ruta absoluta. Combina los segmentos proporcionados con la ruta actual de trabajo y resuelve la ruta final.

```javascript
const path = require('path');

const ruta = path.resolve('documentos', 'archivo.txt');
console.log(ruta); // '/ruta/completa/documentos/archivo.txt'

path.basename()
```
Obtiene el nombre del archivo o directorio de una ruta. Opcionalmente, se puede pasar una extensión para eliminarla del resultado.

```javascript
const path = require('path');

const ruta = '/usuarios/juan/documentos/archivo.txt';
console.log(path.basename(ruta)); // 'archivo.txt'
console.log(path.basename(ruta, '.txt')); // 'archivo'
```
### path.dirname()

Obtiene el directorio de una ruta. Devuelve la ruta sin el nombre del archivo o directorio final.

```javascript
const path = require('path');

const ruta = '/usuarios/juan/documentos/archivo.txt';
console.log(path.dirname(ruta)); // '/usuarios/juan/documentos'
```
### path.extname()

Obtiene la extensión del archivo en una ruta.

```javascript
const path = require('path');

const ruta = '/usuarios/juan/documentos/archivo.txt';
console.log(path.extname(ruta)); // '.txt'
```
### path.parse()

Parses una ruta en un objeto con propiedades **root**, **dir**, **base**, **ext** y **name**.

```javascript
const path = require('path');

const ruta = '/usuarios/juan/documentos/archivo.txt';
const parsed = path.parse(ruta);
console.log(parsed);
// { root: '/', dir: '/usuarios/juan/documentos', base: 'archivo.txt', ext: '.txt', name: 'archivo' }
```
### path.format()

Convierte un objeto de ruta en una ruta de cadena.

```javascript
const path = require('path');

const objetoRuta = {
    root: '/',
    dir: '/usuarios/juan/documentos',
    base: 'archivo.txt',
    ext: '.txt',
    name: 'archivo'
};
const ruta = path.format(objetoRuta);
console.log(ruta); // '/usuarios/juan/documentos/archivo.txt'
```

## Uso de path.join(), path.resolve(), y más

Al usar **path.join()** y **path.resolve()**, asegúrate de que las rutas se construyan correctamente y sean portables entre diferentes sistemas operativos. Estas funciones ayudan a evitar errores relacionados con las diferencias en las convenciones de rutas entre Windows y UNIX.

# Asincronía en Node.js

Node.js es conocido por su modelo de programación asincrónica, lo que permite realizar operaciones no bloqueantes y mejorar el rendimiento en aplicaciones concurrentes. Este modelo se basa en el uso de callbacks, promesas y **async/await**.

## Callbacks

### Concepto

Los callbacks son funciones que se pasan como argumentos a otras funciones y se ejecutan cuando se completa una operación asincrónica. Son una forma básica de manejar operaciones asincrónicas en JavaScript.

### Ejemplo básico

```javascript
const fs = require('fs');

// Función asincrónica que lee un archivo
fs.readFile('archivo.txt', 'utf8', (err, data) => {
    if (err) {
        console.error('Error al leer el archivo:', err);
        return;
    }
    console.log('Contenido del archivo:', data);
});
```
## Problemas con Callbacks

1. **Callback Hell:** Cuando se tienen múltiples operaciones asincrónicas anidadas, el código puede volverse difícil de leer y mantener.

2. **Manejo de errores:** Los errores deben ser manejados en cada callback, lo que puede llevar a código repetitivo.

## Promesas

### Concepto

Las promesas representan el valor eventual de una operación asincrónica y permiten encadenar operaciones de manera más legible que los callbacks. Una promesa puede estar en uno de tres estados: pendiente, cumplida o rechazada.

### Ejemplo básico

```javascript
const fs = require('fs').promises;

// Leer un archivo usando promesas
fs.readFile('archivo.txt', 'utf8')
    .then(data => {
        console.log('Contenido del archivo:', data);
    })
    .catch(err => {
        console.error('Error al leer el archivo:', err);
    });
```
## Encadenamiento

Las promesas permiten encadenar múltiples operaciones asincrónicas:

``` javascript
fs.readFile('archivo.txt', 'utf8')
    .then(data => {
        console.log('Contenido del archivo:', data);
        return fs.readFile('otroArchivo.txt', 'utf8');
    })
    .then(otroDato => {
        console.log('Contenido del otro archivo:', otroDato);
    })
    .catch(err => {
        console.error('Error:', err);
    });
```
## Async/Await

### Concepto

**async** y **await** son una forma de escribir código asincrónico que se parece al código síncrono. async define una función que siempre devuelve una promesa, y **await** se usa para esperar el resultado de una promesa.

### Ejemplo básico

```javascript
const fs = require('fs').promises;

async function leerArchivo() {
    try {
        const data = await fs.readFile('archivo.txt', 'utf8');
        console.log('Contenido del archivo:', data);
    } catch (err) {
        console.error('Error al leer el archivo:', err);
    }
}

leerArchivo();
```
## Ventajas

1. **Legibilidad:** El código se parece al código síncrono, lo que facilita su comprensión.
2. **Manejo de errores:** Los errores se pueden manejar con ***try/catch***, simplificando el manejo de excepciones.

### Ejemplo con múltiples operaciones

```javascript
async function leerArchivos() {
    try {
        const data1 = await fs.readFile('archivo1.txt', 'utf8');
        console.log('Contenido del archivo 1:', data1);
        
        const data2 = await fs.readFile('archivo2.txt', 'utf8');
        console.log('Contenido del archivo 2:', data2);
    } catch (err) {
        console.error('Error:', err);
    }
}

leerArchivos();
```
## Ejemplo de flujo completo

Aquí hay un ejemplo de cómo podrías usar **async/await** para realizar múltiples operaciones asincrónicas:

```javascript
const fs = require('fs').promises;

async function procesarArchivos() {
    try {
        const contenido1 = await fs.readFile('archivo1.txt', 'utf8');
        console.log('Archivo 1:', contenido1);
        
        const contenido2 = await fs.readFile('archivo2.txt', 'utf8');
        console.log('Archivo 2:', contenido2);
        
        // Realizar otra operación asincrónica
        const resultado = await otraFuncionAsincrona();
        console.log('Resultado:', resultado);
    } catch (error) {
        console.error('Error:', error);
    }
}

async function otraFuncionAsincrona() {
    // Simulación de una operación asincrónica
    return new Promise((resolve) => setTimeout(() => resolve('Resultado de otra función'), 1000));
}

procesarArchivos();
```
# NPM (Node Package Manager)

NPM es una herramienta fundamental en el ecosistema de Node.js, que permite a los desarrolladores gestionar paquetes y dependencias en sus proyectos. Ofrece una amplia gama de funcionalidades que facilitan el desarrollo y la gestión de aplicaciones Node.js.

## Introducción a NPM

NPM es el gestor de paquetes por defecto para Node.js y viene instalado con Node.js. Permite instalar, actualizar, configurar y gestionar paquetes de software que se utilizan en proyectos de Node.js.

## Conceptos Clave

**Paquete:** Un archivo comprimido que contiene código y metadatos necesarios para usar en proyectos Node.js.

**Repositorio:** Un lugar en línea (como el registro de NPM) donde se almacenan y distribuyen paquetes.

## Instalar paquetes (locales y globales)

### Paquetes Locales

Los paquetes locales se instalan en el directorio del proyecto y se guardan en la carpeta **node_modules**. Estos paquetes solo están disponibles para el proyecto específico en el que se instalan.

### Comando para instalar un paquete local

```bash
npm install <nombre-del-paquete>
```
### Ejemplo

Para instalar **express** en un proyecto local:

```bash
npm install express
```
### Paquetes Globales

Los paquetes globales se instalan en un directorio compartido y están disponibles en cualquier lugar del sistema. Estos paquetes suelen ser herramientas de línea de comandos.

### Comando para instalar un paquete global

```bash
npm install -g <nombre-del-paquete>
```

### Ejemplo

Para instalar el generador de proyectos **npx** globalmente:

```bash
npm install -g npx
```
## Uso de package.json y package-lock.json

### package.json

El archivo **package.json** es el corazón de un proyecto Node.js. Contiene metadatos del proyecto y la configuración para las dependencias, scripts y versiones.

### Estructura básica

```json
{
  "name": "mi-proyecto",
  "version": "1.0.0",
  "description": "Descripción de mi proyecto",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Autor",
  "license": "ISC",
  "dependencies": {
    "express": "^4.17.1"
  }
}
```

### Campos importantes

*   **name:** Nombre del proyecto.
*   **version:** Versión del proyecto.
*   **dependencies:** Dependencias del proyecto.
*   **scripts:** Scripts personalizados que puedes ejecutar con **npm run \<nombre-del-script\>**.

### package-lock.json

El archivo **package-lock.json** asegura que las dependencias se instalen de manera consistente. Contiene información detallada sobre las versiones exactas de cada paquete y sus dependencias.

### Propósito

*   **Consistencia:** Garantiza que todos los desarrolladores e instalaciones tengan las mismas versiones de paquetes.

*   **Rendimiento:** Mejora la velocidad de instalación al guardar una lista detallada de las dependencias.

## Scripts de NPM

NPM permite definir y ejecutar scripts personalizados que automatizan tareas comunes en el desarrollo.
Definir Scripts

Los scripts se definen en el campo **scripts** del **package.json**. Puedes definir scripts para tareas como pruebas, compilación y más.

### Ejemplo de definición de scripts

```json
"scripts": {
  "start": "node index.js",
  "test": "mocha test/",
  "build": "webpack"
}
```

### Ejecutar Scripts

Para ejecutar un script, usa el comando **npm run \<nombre-del-script\>**. No es necesario incluir el prefijo **run** para los scripts **start** y **test**.

### Ejemplo de ejecución

Para iniciar el servidor:

```bash
npm start
```
Para ejecutar las pruebas:

```bash
npm test
```
### Ejemplo completo

Imagina que tienes un proyecto con un **package.json** como el siguiente:

```json
{
  "name": "mi-app",
  "version": "1.0.0",
  "scripts": {
    "start": "node app.js",
    "build": "webpack --config webpack.config.js",
    "test": "mocha"
  },
  "dependencies": {
    "express": "^4.17.1"
  }
}
```

Puedes iniciar tu aplicación con:

```bash
npm start
```
Puedes construir tu proyecto con:

```bash
npm run build
```
Y puedes ejecutar tus pruebas con:

```bash
npm test
```
# Módulo express: Framework para servidores web

Express es un framework minimalista para Node.js que facilita la creación de servidores web y API. Proporciona una serie de características útiles que simplifican el desarrollo de aplicaciones web.

## Instalación y Configuración Básica de Express

### Instalación

Para instalar Express en tu proyecto Node.js, usa el siguiente comando en la raíz de tu proyecto:

```bash
npm install express
```

### Configuración Básica

Una vez instalado, puedes configurar un servidor básico con Express. Crea un archivo llamado **app.js** (o el nombre que prefieras) y agrega el siguiente código:

```javascript
const express = require('express');
const app = express();
const port = 3000;

// Middleware para manejar solicitudes
app.use(express.json());

// Ruta raíz
app.get('/', (req, res) => {
  res.send('¡Hola Mundo!');
});

// Iniciar el servidor
app.listen(port, () => {
  console.log(`Servidor escuchando en http://localhost:${port}`);
});
```
En este ejemplo:

*    **express()** crea una instancia de la aplicación Express.
*    **app.use(express.json())** es un middleware que analiza las solicitudes con contenido JSON.
*    **app.get('/', ...)** define una ruta para manejar solicitudes GET en la raíz del servidor.
*    **app.listen(port, ...)** inicia el servidor en el puerto especificado.

## Creación de Rutas y Middlewares

### Rutas

Las rutas definen cómo el servidor responde a las solicitudes de los clientes. Puedes definir rutas para diferentes métodos HTTP (GET, POST, PUT, DELETE, etc.).

### Ejemplo de rutas

```javascript
// Ruta GET para '/usuarios'
app.get('/usuarios', (req, res) => {
  res.send('Lista de usuarios');
});

// Ruta POST para '/usuarios'
app.post('/usuarios', (req, res) => {
  const nuevoUsuario = req.body;
  res.status(201).send(`Usuario creado: ${JSON.stringify(nuevoUsuario)}`);
});
```

## Middlewares

Los middlewares son funciones que se ejecutan durante el ciclo de vida de una solicitud. Puedes usarlos para realizar tareas como análisis de solicitudes, autenticación, etc.

### Ejemplo de middleware

```javascript
// Middleware de logging
app.use((req, res, next) => {
  console.log(`${req.method} ${req.url}`);
  next(); // Pasa el control al siguiente middleware
});
```

En este ejemplo, el middleware de logging registra el método HTTP y la URL de cada solicitud.

## Servir Archivos Estáticos

Express facilita la entrega de archivos estáticos como HTML, CSS y JavaScript. Utiliza el middleware **express.static** para servir archivos desde un directorio específico.

### Ejemplo

Supongamos que tienes un directorio **public** con archivos estáticos. Puedes servir estos archivos de la siguiente manera:

```javascript
app.use(express.static('public'));
```
Si tienes un archivo **index.html** en el directorio **public**, estará disponible en la raíz del servidor:

*   <http://localhost:3000/index.html>

## Gestión de Errores

La gestión de errores en Express se realiza mediante un middleware especial que se coloca al final de la pila de middleware.

### Ejemplo de Middleware de Manejo de Errores

```javascript
// Middleware de manejo de errores
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Algo salió mal!');
});
```

En este ejemplo:

*    **err** es el objeto de error que se pasa al middleware.
*    **req** y **res** son el objeto de solicitud y respuesta, respectivamente.
*    **next** se usa para pasar el control al siguiente middleware (en este caso, no se usa).

Este middleware captura cualquier error que ocurra en la aplicación y responde con un mensaje de error.

## Ejemplo Completo

Aquí tienes un ejemplo completo que incluye rutas, middlewares y manejo de errores:

```javascript
const express = require('express');
const app = express();
const port = 3000;

// Middleware para manejar solicitudes
app.use(express.json());
app.use(express.static('public'));

// Middleware de logging
app.use((req, res, next) => {
  console.log(`${req.method} ${req.url}`);
  next();
});

// Ruta GET para '/'
app.get('/', (req, res) => {
  res.send('¡Hola Mundo!');
});

// Ruta GET para '/usuarios'
app.get('/usuarios', (req, res) => {
  res.send('Lista de usuarios');
});

// Ruta POST para '/usuarios'
app.post('/usuarios', (req, res) => {
  const nuevoUsuario = req.body;
  res.status(201).send(`Usuario creado: ${JSON.stringify(nuevoUsuario)}`);
});

// Middleware de manejo de errores
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Algo salió mal!');
});

// Iniciar el servidor
app.listen(port, () => {
  console.log(`Servidor escuchando en http://localhost:${port}`);
});
```
Este código proporciona una base sólida para una aplicación Express, incluyendo manejo de rutas, middleware y gestión de errores.

# APIs REST con Node.js y Express

Las APIs REST (Representational State Transfer) permiten la comunicación entre clientes y servidores a través de HTTP. Express facilita la creación de APIs RESTful al proporcionar una estructura flexible y potente para definir rutas y manejar solicitudes.

## Introducción a las APIs REST

REST es un estilo arquitectónico para diseñar servicios de red. En REST, los recursos (datos o servicios) son identificados por URLs y manipulados a través de métodos HTTP.

Los principios fundamentales de REST incluyen:

*    **Stateless:** Cada solicitud del cliente al servidor debe contener toda la información necesaria para entender y procesar la solicitud.
*    **Cacheable:** Las respuestas deben ser explícitamente etiquetadas como cacheables o no cacheables.
*    **Uniform Interface:** La interfaz entre el cliente y el servidor debe ser uniforme para simplificar la interacción.
*    **Layered System:** La arquitectura debe permitir una estructura de capas para la modularidad y escalabilidad.

## Métodos HTTP (GET, POST, PUT, DELETE)

Los métodos HTTP determinan la acción que se debe realizar sobre el recurso en el servidor:

*    **GET:** Recupera datos del servidor.
*    **POST:** Envía datos al servidor para crear un nuevo recurso.
*    **PUT:** Actualiza un recurso existente en el servidor.
*    **DELETE:** Elimina un recurso del servidor.

## Ejemplos de Métodos HTTP en Express

Aquí hay ejemplos de cómo usar estos métodos en una API REST con Express:

```javascript
const express = require('express');
const app = express();
const port = 3000;

app.use(express.json());

// Datos de ejemplo
let usuarios = [
  { id: 1, nombre: 'Alice' },
  { id: 2, nombre: 'Bob' }
];

// GET: Obtener todos los usuarios
app.get('/usuarios', (req, res) => {
  res.json(usuarios);
});

// GET: Obtener un usuario por ID
app.get('/usuarios/:id', (req, res) => {
  const usuario = usuarios.find(u => u.id === parseInt(req.params.id));
  if (!usuario) return res.status(404).send('Usuario no encontrado');
  res.json(usuario);
});

// POST: Crear un nuevo usuario
app.post('/usuarios', (req, res) => {
  const nuevoUsuario = {
    id: usuarios.length + 1,
    nombre: req.body.nombre
  };
  usuarios.push(nuevoUsuario);
  res.status(201).json(nuevoUsuario);
});

// PUT: Actualizar un usuario existente
app.put('/usuarios/:id', (req, res) => {
  const usuario = usuarios.find(u => u.id === parseInt(req.params.id));
  if (!usuario) return res.status(404).send('Usuario no encontrado');

  usuario.nombre = req.body.nombre;
  res.json(usuario);
});

// DELETE: Eliminar un usuario
app.delete('/usuarios/:id', (req, res) => {
  const usuarioIndex = usuarios.findIndex(u => u.id === parseInt(req.params.id));
  if (usuarioIndex === -1) return res.status(404).send('Usuario no encontrado');

  usuarios.splice(usuarioIndex, 1);
  res.status(204).send(); // No content
});

// Iniciar el servidor
app.listen(port, () => {
  console.log(`Servidor escuchando en http://localhost:${port}`);
});
```

En este ejemplo:

*    **GET/usuarios** devuelve la lista de todos los usuarios.
*    **GET/usuarios/**
    devuelve un usuario específico por ID.
*    **POST/usuarios** crea un nuevo usuario y lo agrega a la lista.
*    **PUT/usuarios/**
    actualiza el nombre de un usuario existente.
*    **DELETE/usuarios/**
    elimina un usuario específico.

## Creación de una API RESTful

Para crear una API RESTful, sigue estos pasos básicos:

1.    **Definir Recursos:** Identifica los recursos que tu API debe manejar (por ejemplo, usuarios, productos).
2.     **Definir Rutas y Métodos:** Establece las rutas y métodos HTTP necesarios para manipular esos recursos.
3.    **Implementar Controladores:** Crea funciones que manejen las solicitudes para cada ruta.
4.    **Configurar Middleware:** Agrega middleware para manejar tareas como la validación de datos y el manejo de errores.

## Ejemplo de Estructura de Proyecto

Una estructura típica para una API RESTful en Express puede ser la siguiente:

```plaintext
myapi/
├── routes/
│   └── usuarios.js
├── controllers/
│   └── usuariosController.js
├── models/
│   └── usuario.js
├── app.js
└── package.json
```
En esta estructura:

*    **routes/usuarios.js** define las rutas relacionadas con los usuarios.
*    **controllers/usuariosController.js** contiene la lógica de negocio para manejar las solicitudes.
*    **models/usuario.js** define el esquema de datos (si se usa una base de datos).
*    **app.js** configura la aplicación Express y las rutas.

# Uso de JSON en las Respuestas

JSON (JavaScript Object Notation) es el formato más común para intercambiar datos entre el cliente y el servidor. En Express, puedes enviar respuestas en formato JSON utilizando el método **res.json()**.

### Ejemplo

```javascript
app.get('/saludo', (req, res) => {
  res.json({
    mensaje: 'Hola, mundo!',
    fecha: new Date()
  });
});
```

En este ejemplo, el servidor responde con un objeto JSON que contiene un mensaje y la fecha actual.

## Manejo de Errores en JSON

También es útil enviar errores en formato JSON para una mayor claridad y consistencia.

```javascript
app.use((err, req, res, next) => {
  res.status(500).json({
    error: 'Algo salió mal',
    detalles: err.message
  });
});
```
En este caso, si ocurre un error en el servidor, la respuesta será un JSON con el mensaje de error y detalles adicionales.

# Bases de datos en Node.js

Las bases de datos son una parte fundamental de muchas aplicaciones web, y Node.js proporciona varias opciones para interactuar con diferentes sistemas de bases de datos, tanto SQL como NoSQL.

## Introducción a bases de datos con Node.js

Node.js permite a los desarrolladores conectar y manipular bases de datos utilizando diversos paquetes y bibliotecas. Puedes usar bases de datos SQL, como MySQL o PostgreSQL, o bases de datos NoSQL, como MongoDB. La elección de la base de datos depende de los requisitos específicos de la aplicación.

### Tipos de bases de datos

1.    **Bases de datos relacionales:** Organizan datos en tablas y son ideales para aplicaciones que requieren relaciones complejas entre datos. Ejemplo: MySQL, PostgreSQL.

2.     **Bases de datos NoSQL:** Almacenan datos en documentos, pares clave-valor, o grafos, lo que permite una mayor flexibilidad en la estructura de datos. Ejemplo: MongoDB.

## Conexión con MongoDB usando Mongoose

Mongoose es una biblioteca de Node.js que proporciona una solución elegante para modelar datos de MongoDB. Facilita la creación de esquemas, la validación de datos y las operaciones CRUD.

### Instalación

Para usar Mongoose, primero debes instalarlo en tu proyecto:

```bash
npm install mongoose
```
## Conexión a MongoDB

A continuación, se muestra cómo conectarse a una base de datos MongoDB usando Mongoose:

```javascript
const mongoose = require('mongoose');

const uri = 'mongodb://localhost:27017/midatabase'; // Cambia 'midatabase' por el nombre de tu base de datos

mongoose.connect(uri, {
  useNewUrlParser: true,
  useUnifiedTopology: true
}).then(() => {
  console.log('Conectado a MongoDB');
}).catch(err => {
  console.error('Error al conectar a MongoDB', err);
});
```
## Definición de un Esquema

Después de conectarte a MongoDB, puedes definir un esquema para tus datos:

```javascript
const usuarioSchema = new mongoose.Schema({
  nombre: { type: String, required: true },
  edad: { type: Number, required: true },
  email: { type: String, required: true, unique: true }
});

const Usuario = mongoose.model('Usuario', usuarioSchema);
```

## Uso de MySQL con el paquete mysql2

El paquete **mysql2** proporciona una forma sencilla de interactuar con bases de datos MySQL desde Node.js. Permite realizar consultas y administrar la conexión con la base de datos.

### Instalación

Para instalar **mysql2**, ejecuta el siguiente comando:

```bash
npm install mysql2
```
### Conexión a MySQL

Aquí hay un ejemplo de cómo conectarte a una base de datos MySQL:

```javascript
const mysql = require('mysql2');

const connection = mysql.createConnection({
  host: 'localhost',
  user: 'tu_usuario', // Cambia por tu usuario de MySQL
  password: 'tu_contraseña', // Cambia por tu contraseña de MySQL
  database: 'midatabase' // Cambia por el nombre de tu base de datos
});

connection.connect((err) => {
  if (err) {
    console.error('Error al conectar a MySQL:', err);
    return;
  }
  console.log('Conectado a MySQL');
});
```
## Realización de consultas y operaciones CRUD

### Consultas en MongoDB

Con Mongoose, puedes realizar operaciones CRUD de manera sencilla. Aquí hay ejemplos:

*    **Crear un nuevo usuario:**

```javascript
const nuevoUsuario = new Usuario({
  nombre: 'Alice',
  edad: 30,
  email: 'alice@example.com'
});

nuevoUsuario.save()
  .then(() => console.log('Usuario creado'))
  .catch(err => console.error('Error al crear usuario', err));
```
*    **Leer usuarios:**

```javascript
Usuario.find()
  .then(usuarios => console.log(usuarios))
  .catch(err => console.error('Error al leer usuarios', err));
```
*    **Actualizar un usuario:**

```javascript
Usuario.updateOne({ email: 'alice@example.com' }, { edad: 31 })
  .then(() => console.log('Usuario actualizado'))
  .catch(err => console.error('Error al actualizar usuario', err));
```
*    **Eliminar un usuario:**

```javascript
Usuario.deleteOne({ email: 'alice@example.com' })
  .then(() => console.log('Usuario eliminado'))
  .catch(err => console.error('Error al eliminar usuario', err));
```

## Consultas en MySQL

Aquí hay ejemplos de cómo realizar operaciones CRUD en MySQL usando el paquete mysql2:

*    **Crear un nuevo usuario:**

```javascript
const nuevoUsuario = { nombre: 'Alice', edad: 30, email: 'alice@example.com' };
connection.query('INSERT INTO usuarios SET ?', nuevoUsuario, (err, results) => {
  if (err) {
    console.error('Error al crear usuario', err);
    return;
  }
  console.log('Usuario creado con ID:', results.insertId);
});
```
*    **Leer usuarios:**

```javascript
connection.query('SELECT * FROM usuarios', (err, results) => {
  if (err) {
    console.error('Error al leer usuarios', err);
    return;
  }
  console.log(results);
});
```
*    **Actualizar un usuario:**

```javascript
const usuarioActualizado = { edad: 31 };
connection.query('UPDATE usuarios SET ? WHERE email = ?', [usuarioActualizado, 'alice@example.com'], (err, results) => {
  if (err) {
    console.error('Error al actualizar usuario', err);
    return;
  }
  console.log('Usuario actualizado:', results.affectedRows);
});
```

*    **Eliminar un usuario:**

```javascript
connection.query('DELETE FROM usuarios WHERE email = ?', ['alice@example.com'], (err, results) => {
  if (err) {
    console.error('Error al eliminar usuario', err);
    return;
  }
  console.log('Usuario eliminado:', results.affectedRows);
});
```
## Levantar el contenedor con Docker Compose

Para utilizar bases de datos en tu aplicación Node.js, puedes usar Docker para crear un entorno de desarrollo consistente. Aquí te muestro cómo levantar un contenedor para MongoDB y MySQL utilizando Docker Compose.

### Ejemplo de docker-compose.yml

Crea un archivo llamado **docker-compose.yml** con el siguiente contenido:

```yaml
services:
  mongodb:
    image: mongo:latest
    container_name: mongodb
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db

  mysql:
    image: mysql:latest
    container_name: mysql
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: midatabase
      MYSQL_USER: tu_usuario
      MYSQL_PASSWORD: tu_contraseña
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql

volumes:
  mongodb_data:
  mysql_data:
```
Levantar los Contenedores

Una vez que tengas el archivo **docker-compose.yml**, puedes levantar los contenedores con el siguiente comando:

```bash
docker compose up -d
```
Esto iniciará los contenedores de MongoDB y MySQL en segundo plano. Puedes verificar que están funcionando correctamente ejecutando:

```bash
docker compose ps
```

## Conectarse a las Bases de Datos

Una vez que los contenedores estén en funcionamiento, podrás conectarte a ellos utilizando los ejemplos de conexión proporcionados anteriormente.

# Manejo de errores en Node.js

El manejo de errores es crucial para construir aplicaciones robustas y confiables. En Node.js, puedes manejar errores de diversas maneras para asegurarte de que tu aplicación se comporte de manera adecuada incluso cuando ocurren problemas.

## Captura de errores con **try/catch**

En Node.js, puedes usar bloques **try/catch** para manejar errores sin que estos interrumpan el flujo normal de tu aplicación. Este enfoque es útil para manejar errores sincrónicos, como los que pueden ocurrir al acceder a archivos o realizar operaciones matemáticas.

## Ejemplo básico de **try/catch**

```javascript
try {
  // Código que puede lanzar un error
  const resultado = JSON.parse('{"nombre": "Alice"}'); // Esto no lanzará un error
  console.log(resultado);
  
  const fallo = JSON.parse('{"nombre": "Alice"'); // Esto lanzará un error de sintaxis
} catch (error) {
  // Manejo del error
  console.error('Se produjo un error:', error.message);
}
```
En este ejemplo, el primer **JSON.parse **no lanza un error, pero el segundo lo hace. El bloque **catch** captura el error y muestra un mensaje adecuado.

## Propagación de errores en aplicaciones

En aplicaciones más grandes, es común propagar errores a través de funciones y manejar errores en un nivel superior. Esto ayuda a centralizar el manejo de errores y mantener el código más limpio.

## Ejemplo de propagación de errores

```javascript
// Función que puede lanzar un error
function divide(a, b) {
  if (b === 0) {
    throw new Error('No se puede dividir por cero');
  }
  return a / b;
}

// Función que maneja el error
function realizarOperacion() {
  try {
    const resultado = divide(10, 0);
    console.log(resultado);
  } catch (error) {
    console.error('Error en realizarOperacion:', error.message);
  }
}

realizarOperacion();
```
En este ejemplo, la función **divide** lanza un error si se intenta dividir por cero, y **realizarOperacion** maneja este error.

## Uso del objeto **Error**

Node.js proporciona un objeto **Error** que puedes usar para crear errores personalizados. El objeto **Error** tiene propiedades útiles como **message**, **name** y **stack**, que te permiten obtener información sobre el error.

## Creación de errores personalizados

Puedes extender el objeto **Error** para crear tipos de errores personalizados:

```javascript
class MiErrorPersonalizado extends Error {
  constructor(mensaje) {
    super(mensaje);
    this.name = 'MiErrorPersonalizado';
  }
}

function lanzarError() {
  throw new MiErrorPersonalizado('Este es un error personalizado');
}

try {
  lanzarError();
} catch (error) {
  console.error(`${error.name}: ${error.message}`);
  console.error('Pila de llamadas:', error.stack);
}
```
En este ejemplo, **MiErrorPersonalizado** es una clase que extiende el objeto **Error**. Cuando se lanza este error, puedes capturar y mostrar información detallada sobre él.

## Manejo de errores en aplicaciones asincrónicas

En aplicaciones asincrónicas, como las que usan **promesas** o **async/await**, el manejo de errores es un poco diferente.

## Manejo de errores con promesas

```javascript
function asyncOperation() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(new Error('Algo salió mal en la operación asincrónica'));
    }, 1000);
  });
}

asyncOperation()
  .then(result => console.log(result))
  .catch(error => console.error('Error en operación asincrónica:', error.message));
```

## Manejo de errores con **async/await**

```javascript
async function realizarOperacionAsincrona() {
  try {
    const resultado = await asyncOperation();
    console.log(resultado);
  } catch (error) {
    console.error('Error en operación asincrónica:', error.message);
  }
}

realizarOperacionAsincrona();
```

En estos ejemplos, **asyncOperation** devuelve una promesa que se rechaza con un error. Puedes manejar estos errores usando **catch** en promesas o un bloque **try/catch** con **async/await**.

## Resumen

*    **Captura de errores:** Usa **try/catch** para manejar errores sincrónicos.
*    **Propagación de errores:** Propaga errores a través de funciones y maneja errores en niveles superiores.
*    **Uso del objeto Error:** Crea errores personalizados extendiendo el objeto **Error**.
*    **Errores asincrónicos:** Maneja errores en promesas y **async/await** de manera adecuada.

# Manejo de formularios y datos del cliente

En aplicaciones web, es común procesar datos enviados por formularios HTML, manejar datos de cliente y comunicarse a través de JSON. Node.js y Express proporcionan herramientas y middleware para facilitar estas tareas.

## Procesar datos enviados por formularios HTML

Para procesar datos enviados a través de formularios HTML, necesitas capturar y manipular los datos que los usuarios envían. En una aplicación Express, puedes hacer esto utilizando el middleware adecuado para interpretar los datos del cuerpo de la solicitud.

## Ejemplo de formulario HTML

```html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Formulario de Ejemplo</title>
</head>
<body>
    <form action="/submit" method="POST">
        <label for="name">Nombre:</label>
        <input type="text" id="name" name="name" required>
        
        <label for="email">Correo electrónico:</label>
        <input type="email" id="email" name="email" required>
        
        <button type="submit">Enviar</button>
    </form>
</body>
</html>
```
## Configuración de Express para procesar datos de formularios

Para capturar los datos enviados por el formulario, debes usar middleware que pueda interpretar los datos del cuerpo de la solicitud. Express no lo hace por defecto, pero puedes usar **body-parser** para este propósito.

## Parseo de datos con **body-parser**

El middleware ***body-parser*** ayuda a analizar los datos enviados en las solicitudes HTTP. En versiones más recientes de Express, **body-parser** está integrado directamente en Express, y puedes usar **express.json()** y **express.urlencoded()** para procesar los datos del cuerpo.
Instalación de body-parser

Si estás usando una versión antigua de Express, puedes instalar **body-parser** como un paquete independiente:

```bash
npm install body-parser
```

## Configuración en Express

Usando **body-parser** (para versiones antiguas de Express)

```javascript
const express = require('express');
const bodyParser = require('body-parser');

const app = express();
const port = 3000;

// Middleware para analizar datos de formularios
app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());

app.post('/submit', (req, res) => {
  const { name, email } = req.body;
  res.send(`Nombre: ${name}, Correo electrónico: ${email}`);
});

app.listen(port, () => {
  console.log(`Servidor escuchando en http://localhost:${port}`);
});
```
Usando **express.json()** y **express.urlencoded()** (para versiones recientes de Express)

```javascript
const express = require('express');

const app = express();
const port = 3000;

// Middleware para analizar datos de formularios
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

app.post('/submit', (req, res) => {
  const { name, email } = req.body;
  res.send(`Nombre: ${name}, Correo electrónico: ${email}`);
});

app.listen(port, () => {
  console.log(`Servidor escuchando en http://localhost:${port}`);
});
```

## Envío y recepción de JSON

Las aplicaciones modernas a menudo usan JSON para enviar y recibir datos entre el cliente y el servidor. Express facilita la manipulación de JSON.

## Envío de JSON desde el servidor

Puedes enviar respuestas en formato JSON desde el servidor usando el método **res.json()**.

```javascript

app.get('/data', (req, res) => {
  const data = {
    mensaje: 'Este es un mensaje en JSON',
    status: 'exitoso'
  };
  res.json(data);
});
```
## Recepción de JSON en el servidor

Para recibir datos en formato JSON, asegúrate de usar el middleware **express.json()** y luego accede a los datos a través de **req.body**.

```javascript
app.post('/json', (req, res) => {
  const { nombre, edad } = req.body;
  res.json({ mensaje: `Recibido nombre: ${nombre} y edad: ${edad}` });
});
```
## Envío de JSON desde el cliente

Puedes usar JavaScript en el navegador para enviar datos JSON al servidor usando **fetch** o bibliotecas como **axios**.

### Usando fetch

```javascript
fetch('/json', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ nombre: 'Juan', edad: 30 })
})
  .then(response => response.json())
  .then(data => console.log(data));
```
### Usando **axios**

Primero, instala **axios**:

```bash
npm install axios
```
Luego, usa **axios** para enviar datos JSON:

```javascript
const axios = require('axios');

axios.post('/json', { nombre: 'Juan', edad: 30 })
  .then(response => console.log(response.data))
  .catch(error => console.error('Error:', error));
```
Resumen

*    **Procesar formularios HTML:** Usa middleware para interpretar datos del cuerpo de la solicitud **(express.urlencoded()**).

*    **Parseo de datos:** Utiliza express.json() para manejar datos JSON en las solicitudes.

*    **Envío y recepción de JSON:** Usa res.json() para enviar respuestas en JSON y req.body para acceder a los datos enviados en formato JSON.

# Autenticación y seguridad en Node.js

## Implementación de autenticación básica y con tokens
## Uso de JWT (JSON Web Tokens)
## Encriptación de contraseñas con bcrypt
## Protección de rutas en Express

# Manejo de sesiones y cookies

## Introducción a las sesiones en Express
## Uso de cookies y tokens de sesión
## Almacenamiento de sesiones en bases de datos

# Subida de archivos

## Manejo de archivos en formularios
## Uso de multer para cargar archivos
## Validación y almacenamiento de archivos

# WebSockets y tiempo real en Node.js

## Introducción a WebSockets
## Configuración de WebSockets con socket.io
## Implementación de un chat en tiempo real

# Testing en Node.js

## Introducción al testing
## Configuración de Mocha y Chai para pruebas
## Testing de rutas y controladores
## Mocking y pruebas de integración

# Despliegue de aplicaciones Node.js

## Preparación de una aplicación para producción
## Despliegue en Heroku
## Despliegue en servicios en la nube (AWS, DigitalOcean)
## Uso de herramientas como PM2 para gestionar aplicaciones en producción

# Optimización y mejores prácticas

## Mejorar el rendimiento de una aplicación Node.js
## Uso de middlewares eficientes en Express
## Buenas prácticas de manejo de errores y logging
## Escalabilidad y clustering en Node.js

# Proyecto Final: API RESTful Completa con Node.js y Express

# Diseño de la API
# Implementación de rutas y controladores
# Conexión con una base de datos
# Autenticación y autorización
# Testing y despliegue